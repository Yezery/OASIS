{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar interlaceUtils = require('./interlace');\nvar paethPredictor = require('./paeth-predictor');\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\nvar Filter = module.exports = function (bitmapInfo, dependencies) {\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  } else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  } else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  } else {\n    this._xComparison = 1;\n  }\n};\nFilter.prototype.start = function () {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\nFilter.prototype._unFilterType1 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\nFilter.prototype._unFilterType2 = function (rawData, unfilteredLine, byteWidth) {\n  var lastLine = this._lastLine;\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\nFilter.prototype._unFilterType3 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\nFilter.prototype._unFilterType4 = function (rawData, unfilteredLine, byteWidth) {\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\nFilter.prototype._reverseFilterLine = function (rawData) {\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  } else {\n    unfilteredLine = new Buffer(byteWidth);\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n  this.write(unfilteredLine);\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  } else {\n    this._lastLine = unfilteredLine;\n  }\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  } else {\n    this._lastLine = null;\n    this.complete();\n  }\n};","map":{"version":3,"names":["require","interlaceUtils","paethPredictor","getByteWidth","width","bpp","depth","byteWidth","Math","ceil","Filter","module","exports","bitmapInfo","dependencies","height","interlace","read","write","complete","_imageIndex","_images","passes","getImagePasses","i","length","push","lineIndex","_xComparison","prototype","start","_reverseFilterLine","bind","_unFilterType1","rawData","unfilteredLine","xComparison","xBiggerThan","x","rawByte","f1Left","_unFilterType2","lastLine","_lastLine","f2Up","_unFilterType3","f3Up","f3Left","f3Add","floor","_unFilterType4","f4Up","f4Left","f4UpLeft","f4Add","filter","currentImage","slice","Buffer","Error"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/pngjs-nozlib@1.0.0/node_modules/pngjs-nozlib/lib/filter-parse.js"],"sourcesContent":["'use strict';\n\nvar interlaceUtils = require('./interlace');\nvar paethPredictor = require('./paeth-predictor');\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nvar Filter = module.exports = function(bitmapInfo, dependencies) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  }\n  else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  }\n  else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  }\n  else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function() {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {\n\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function(rawData) {\n\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  }\n  else {\n\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  }\n  else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  }\n  else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAACA,OAAA;AAEb,IAAIC,cAAc,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC3C,IAAIE,cAAc,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAEjD,SAASG,YAAYA,CAACC,KAAK,EAAEC,GAAG,EAAEC,KAAK,EAAE;EACvC,IAAIC,SAAS,GAAGH,KAAK,GAAGC,GAAG;EAC3B,IAAIC,KAAK,KAAK,CAAC,EAAE;IACfC,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACF,SAAS,IAAI,CAAC,GAAGD,KAAK,CAAC,CAAC;EAChD;EACA,OAAOC,SAAS;AAClB;AAEA,IAAIG,MAAM,GAAGC,MAAM,CAACC,OAAO,GAAG,UAASC,UAAU,EAAEC,YAAY,EAAE;EAE/D,IAAIV,KAAK,GAAGS,UAAU,CAACT,KAAK;EAC5B,IAAIW,MAAM,GAAGF,UAAU,CAACE,MAAM;EAC9B,IAAIC,SAAS,GAAGH,UAAU,CAACG,SAAS;EACpC,IAAIX,GAAG,GAAGQ,UAAU,CAACR,GAAG;EACxB,IAAIC,KAAK,GAAGO,UAAU,CAACP,KAAK;EAE5B,IAAI,CAACW,IAAI,GAAGH,YAAY,CAACG,IAAI;EAC7B,IAAI,CAACC,KAAK,GAAGJ,YAAY,CAACI,KAAK;EAC/B,IAAI,CAACC,QAAQ,GAAGL,YAAY,CAACK,QAAQ;EAErC,IAAI,CAACC,WAAW,GAAG,CAAC;EACpB,IAAI,CAACC,OAAO,GAAG,EAAE;EACjB,IAAIL,SAAS,EAAE;IACb,IAAIM,MAAM,GAAGrB,cAAc,CAACsB,cAAc,CAACnB,KAAK,EAAEW,MAAM,CAAC;IACzD,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACtC,IAAI,CAACH,OAAO,CAACK,IAAI,CAAC;QAChBnB,SAAS,EAAEJ,YAAY,CAACmB,MAAM,CAACE,CAAC,CAAC,CAACpB,KAAK,EAAEC,GAAG,EAAEC,KAAK,CAAC;QACpDS,MAAM,EAAEO,MAAM,CAACE,CAAC,CAAC,CAACT,MAAM;QACxBY,SAAS,EAAE;MACb,CAAC,CAAC;IACJ;EACF,CAAC,MACI;IACH,IAAI,CAACN,OAAO,CAACK,IAAI,CAAC;MAChBnB,SAAS,EAAEJ,YAAY,CAACC,KAAK,EAAEC,GAAG,EAAEC,KAAK,CAAC;MAC1CS,MAAM,EAAEA,MAAM;MACdY,SAAS,EAAE;IACb,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA,IAAIrB,KAAK,KAAK,CAAC,EAAE;IACf,IAAI,CAACsB,YAAY,GAAGvB,GAAG;EACzB,CAAC,MACI,IAAIC,KAAK,KAAK,EAAE,EAAE;IACrB,IAAI,CAACsB,YAAY,GAAGvB,GAAG,GAAG,CAAC;EAC7B,CAAC,MACI;IACH,IAAI,CAACuB,YAAY,GAAG,CAAC;EACvB;AACF,CAAC;AAEDlB,MAAM,CAACmB,SAAS,CAACC,KAAK,GAAG,YAAW;EAClC,IAAI,CAACb,IAAI,CAAC,IAAI,CAACI,OAAO,CAAC,IAAI,CAACD,WAAW,CAAC,CAACb,SAAS,GAAG,CAAC,EAAE,IAAI,CAACwB,kBAAkB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC7F,CAAC;AAEDtB,MAAM,CAACmB,SAAS,CAACI,cAAc,GAAG,UAASC,OAAO,EAAEC,cAAc,EAAE5B,SAAS,EAAE;EAE7E,IAAI6B,WAAW,GAAG,IAAI,CAACR,YAAY;EACnC,IAAIS,WAAW,GAAGD,WAAW,GAAG,CAAC;EAEjC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,SAAS,EAAE+B,CAAC,EAAE,EAAE;IAClC,IAAIC,OAAO,GAAGL,OAAO,CAAC,CAAC,GAAGI,CAAC,CAAC;IAC5B,IAAIE,MAAM,GAAGF,CAAC,GAAGD,WAAW,GAAGF,cAAc,CAACG,CAAC,GAAGF,WAAW,CAAC,GAAG,CAAC;IAClED,cAAc,CAACG,CAAC,CAAC,GAAGC,OAAO,GAAGC,MAAM;EACtC;AACF,CAAC;AAED9B,MAAM,CAACmB,SAAS,CAACY,cAAc,GAAG,UAASP,OAAO,EAAEC,cAAc,EAAE5B,SAAS,EAAE;EAE7E,IAAImC,QAAQ,GAAG,IAAI,CAACC,SAAS;EAE7B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,SAAS,EAAE+B,CAAC,EAAE,EAAE;IAClC,IAAIC,OAAO,GAAGL,OAAO,CAAC,CAAC,GAAGI,CAAC,CAAC;IAC5B,IAAIM,IAAI,GAAGF,QAAQ,GAAGA,QAAQ,CAACJ,CAAC,CAAC,GAAG,CAAC;IACrCH,cAAc,CAACG,CAAC,CAAC,GAAGC,OAAO,GAAGK,IAAI;EACpC;AACF,CAAC;AAEDlC,MAAM,CAACmB,SAAS,CAACgB,cAAc,GAAG,UAASX,OAAO,EAAEC,cAAc,EAAE5B,SAAS,EAAE;EAE7E,IAAI6B,WAAW,GAAG,IAAI,CAACR,YAAY;EACnC,IAAIS,WAAW,GAAGD,WAAW,GAAG,CAAC;EACjC,IAAIM,QAAQ,GAAG,IAAI,CAACC,SAAS;EAE7B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,SAAS,EAAE+B,CAAC,EAAE,EAAE;IAClC,IAAIC,OAAO,GAAGL,OAAO,CAAC,CAAC,GAAGI,CAAC,CAAC;IAC5B,IAAIQ,IAAI,GAAGJ,QAAQ,GAAGA,QAAQ,CAACJ,CAAC,CAAC,GAAG,CAAC;IACrC,IAAIS,MAAM,GAAGT,CAAC,GAAGD,WAAW,GAAGF,cAAc,CAACG,CAAC,GAAGF,WAAW,CAAC,GAAG,CAAC;IAClE,IAAIY,KAAK,GAAGxC,IAAI,CAACyC,KAAK,CAAC,CAACF,MAAM,GAAGD,IAAI,IAAI,CAAC,CAAC;IAC3CX,cAAc,CAACG,CAAC,CAAC,GAAGC,OAAO,GAAGS,KAAK;EACrC;AACF,CAAC;AAEDtC,MAAM,CAACmB,SAAS,CAACqB,cAAc,GAAG,UAAShB,OAAO,EAAEC,cAAc,EAAE5B,SAAS,EAAE;EAE7E,IAAI6B,WAAW,GAAG,IAAI,CAACR,YAAY;EACnC,IAAIS,WAAW,GAAGD,WAAW,GAAG,CAAC;EACjC,IAAIM,QAAQ,GAAG,IAAI,CAACC,SAAS;EAE7B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,SAAS,EAAE+B,CAAC,EAAE,EAAE;IAClC,IAAIC,OAAO,GAAGL,OAAO,CAAC,CAAC,GAAGI,CAAC,CAAC;IAC5B,IAAIa,IAAI,GAAGT,QAAQ,GAAGA,QAAQ,CAACJ,CAAC,CAAC,GAAG,CAAC;IACrC,IAAIc,MAAM,GAAGd,CAAC,GAAGD,WAAW,GAAGF,cAAc,CAACG,CAAC,GAAGF,WAAW,CAAC,GAAG,CAAC;IAClE,IAAIiB,QAAQ,GAAGf,CAAC,GAAGD,WAAW,IAAIK,QAAQ,GAAGA,QAAQ,CAACJ,CAAC,GAAGF,WAAW,CAAC,GAAG,CAAC;IAC1E,IAAIkB,KAAK,GAAGpD,cAAc,CAACkD,MAAM,EAAED,IAAI,EAAEE,QAAQ,CAAC;IAClDlB,cAAc,CAACG,CAAC,CAAC,GAAGC,OAAO,GAAGe,KAAK;EACrC;AACF,CAAC;AAED5C,MAAM,CAACmB,SAAS,CAACE,kBAAkB,GAAG,UAASG,OAAO,EAAE;EAEtD,IAAIqB,MAAM,GAAGrB,OAAO,CAAC,CAAC,CAAC;EACvB,IAAIC,cAAc;EAClB,IAAIqB,YAAY,GAAG,IAAI,CAACnC,OAAO,CAAC,IAAI,CAACD,WAAW,CAAC;EACjD,IAAIb,SAAS,GAAGiD,YAAY,CAACjD,SAAS;EAEtC,IAAIgD,MAAM,KAAK,CAAC,EAAE;IAChBpB,cAAc,GAAGD,OAAO,CAACuB,KAAK,CAAC,CAAC,EAAElD,SAAS,GAAG,CAAC,CAAC;EAClD,CAAC,MACI;IAEH4B,cAAc,GAAG,IAAIuB,MAAM,CAACnD,SAAS,CAAC;IAEtC,QAAQgD,MAAM;MACZ,KAAK,CAAC;QACJ,IAAI,CAACtB,cAAc,CAACC,OAAO,EAAEC,cAAc,EAAE5B,SAAS,CAAC;QACvD;MACF,KAAK,CAAC;QACJ,IAAI,CAACkC,cAAc,CAACP,OAAO,EAAEC,cAAc,EAAE5B,SAAS,CAAC;QACvD;MACF,KAAK,CAAC;QACJ,IAAI,CAACsC,cAAc,CAACX,OAAO,EAAEC,cAAc,EAAE5B,SAAS,CAAC;QACvD;MACF,KAAK,CAAC;QACJ,IAAI,CAAC2C,cAAc,CAAChB,OAAO,EAAEC,cAAc,EAAE5B,SAAS,CAAC;QACvD;MACF;QACE,MAAM,IAAIoD,KAAK,CAAC,6BAA6B,GAAGJ,MAAM,CAAC;IAC3D;EACF;EAEA,IAAI,CAACrC,KAAK,CAACiB,cAAc,CAAC;EAE1BqB,YAAY,CAAC7B,SAAS,EAAE;EACxB,IAAI6B,YAAY,CAAC7B,SAAS,IAAI6B,YAAY,CAACzC,MAAM,EAAE;IACjD,IAAI,CAAC4B,SAAS,GAAG,IAAI;IACrB,IAAI,CAACvB,WAAW,EAAE;IAClBoC,YAAY,GAAG,IAAI,CAACnC,OAAO,CAAC,IAAI,CAACD,WAAW,CAAC;EAC/C,CAAC,MACI;IACH,IAAI,CAACuB,SAAS,GAAGR,cAAc;EACjC;EAEA,IAAIqB,YAAY,EAAE;IAChB;IACA,IAAI,CAACvC,IAAI,CAACuC,YAAY,CAACjD,SAAS,GAAG,CAAC,EAAE,IAAI,CAACwB,kBAAkB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAC3E,CAAC,MACI;IACH,IAAI,CAACW,SAAS,GAAG,IAAI;IACrB,IAAI,CAACxB,QAAQ,CAAC,CAAC;EACjB;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}