{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/* eslint-disable no-unreachable */\n\nimport * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { Key } from 'interface-datastore/key';\nimport errCode from 'err-code';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport * as dagPB from '@ipld/dag-pb';\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexport const OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexport const MFS_ROOT_KEY = new Key('/local/filesroot');\nexport const MFS_MAX_CHUNK_SIZE = 262144;\nexport const MFS_MAX_LINKS = 174;\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nexport const normalizePath = pathStr => {\n  const cid = CID.asCID(pathStr);\n  if (cid) {\n    return `/ipfs/${pathStr}`;\n  }\n  const str = pathStr.toString();\n  try {\n    return `/ipfs/${CID.parse(str)}`;\n  } catch {}\n  if (isIpfs.path(str)) {\n    return str;\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);\n  }\n};\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nexport const normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString();\n  }\n  path = path.toString();\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n  return path;\n};\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nexport const resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath);\n  if (path) {\n    options.path = path;\n  }\n  let lastCid = cid;\n  let lastRemainderPath = options.path || '';\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1);\n  }\n  if (options.path) {\n    try {\n      for await (const {\n        value,\n        remainderPath\n      } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break;\n        }\n        lastRemainderPath = remainderPath;\n        lastCid = value;\n      }\n    } catch ( /** @type {any} */err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`;\n        err.code = 'ERR_NO_LINK';\n      }\n      throw err;\n    }\n  }\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  };\n};\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nexport const mapFile = file => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`);\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir';\n  }\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n  return output;\n};\nexport const withTimeout = withTimeoutOption(\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nasync (promise, _options) => await promise);\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nexport const resolve = async function* (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await repo.blocks.get(cid, options);\n    return codec.decode(block);\n  };\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid);\n  let lastCid = cid;\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift();\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPB.code && Array.isArray(value.Links)) {\n      const link = value.Links.find(( /** @type {PBLink} */l) => l.Name === key);\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        };\n        value = await load(link.Hash);\n        lastCid = link.Hash;\n        continue;\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n    }\n    if (CID.asCID(value)) {\n      lastCid = value;\n      value = await load(value);\n    }\n  }\n  yield {\n    value,\n    remainderPath: ''\n  };\n};","map":{"version":3,"names":["isIpfs","CID","Key","errCode","withTimeoutOption","toCidAndPath","dagPB","ERR_BAD_PATH","OFFLINE_ERROR","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","normalizePath","pathStr","cid","asCID","str","toString","parse","path","Error","normalizeCidPath","Uint8Array","decode","indexOf","substring","length","charAt","resolvePath","repo","codecs","ipfsPath","options","lastCid","lastRemainderPath","startsWith","value","remainderPath","resolve","signal","err","message","split","code","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","undefined","withTimeout","promise","_options","load","codec","getCodec","block","blocks","get","parts","filter","Boolean","key","shift","Array","isArray","Links","link","find","l","Name","Hash","join","Object","prototype","hasOwnProperty","call"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/utils.js"],"sourcesContent":["/* eslint-disable no-unreachable */\n\nimport * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { Key } from 'interface-datastore/key'\nimport errCode from 'err-code'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport * as dagPB from '@ipld/dag-pb'\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\nexport const OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\nexport const MFS_ROOT_KEY = new Key('/local/filesroot')\nexport const MFS_MAX_CHUNK_SIZE = 262144\nexport const MFS_MAX_LINKS = 174\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nexport const normalizePath = (pathStr) => {\n  const cid = CID.asCID(pathStr)\n\n  if (cid) {\n    return `/ipfs/${pathStr}`\n  }\n\n  const str = pathStr.toString()\n\n  try {\n    return `/ipfs/${CID.parse(str)}`\n  } catch {}\n\n  if (isIpfs.path(str)) {\n    return str\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nexport const normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString()\n  }\n\n  path = path.toString()\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nexport const resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (path) {\n    options.path = path\n  }\n\n  let lastCid = cid\n  let lastRemainderPath = options.path || ''\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1)\n  }\n\n  if (options.path) {\n    try {\n      for await (const { value, remainderPath } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break\n        }\n\n        lastRemainderPath = remainderPath\n        lastCid = value\n      }\n    } catch (/** @type {any} */ err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  }\n}\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nexport const mapFile = (file) => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`)\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  }\n\n  if (file.type === 'directory') {\n    // @ts-expect-error - TS type can't be changed from File to Directory\n    output.type = 'dir'\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize()\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime\n    }\n  }\n\n  return output\n}\n\nexport const withTimeout = withTimeoutOption(\n  /**\n   * @template T\n   * @param {Promise<T>|T} promise\n   * @param {AbortOptions} [_options]\n   * @returns {Promise<T>}\n   */\n  async (promise, _options) => await promise\n)\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs').Multicodecs} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nexport const resolve = async function * (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPB.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((/** @type {PBLink} */ l) => l.Name === key)\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        }\n\n        value = await load(link.Hash)\n        lastCid = link.Hash\n\n        continue\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (CID.asCID(value)) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n\n  yield {\n    value,\n    remainderPath: ''\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}