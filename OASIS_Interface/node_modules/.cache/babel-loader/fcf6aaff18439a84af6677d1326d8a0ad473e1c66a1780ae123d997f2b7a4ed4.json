{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { CID } from 'multiformats/cid';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { base58btc } from 'multiformats/bases/base58';\n// @ts-ignore\nimport vd from 'varint-decoder';\nimport ve from '../utils/varint-encoder.js';\nimport { isMapEqual } from '../utils/index.js';\nimport { Message } from './message.js';\nimport { BitswapMessageEntry as Entry } from './entry.js';\nimport { CodeError } from '@libp2p/interfaces/errors';\n\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport class BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor(full) {\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map();\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map();\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n    const cidStr = cid.toString(base58btc);\n    const entry = this.wantlist.get(cidStr);\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58btc);\n    this.blocks.set(cidStr, block);\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave(cid) {\n    const cidStr = cid.toString(base58btc);\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58btc);\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel(cid) {\n    const cidStr = cid.toString(base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return Message.encode(msg).finish();\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      const version = cid.version;\n      const codec = cid.code;\n      const multihash = cid.multihash.code;\n      const digestLength = cid.multihash.digest.length;\n      const prefix = ve([version, codec, multihash, digestLength]);\n      msg.payload.push(new Message.Block({\n        prefix,\n        data\n      }));\n    }\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n    return Message.encode(msg).finish();\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) ||\n    // @TODO - Is this a bug ?\n    // @ts-expect-error - isMap equals map values to be objects not numbers\n    !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n    return true;\n  }\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach(entry => {\n      if (!entry.block) {\n        return;\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block);\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n    });\n  }\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      if (!blockPresence.cid) {\n        return;\n      }\n      const cid = CID.decode(blockPresence.cid);\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid);\n      } else {\n        msg.addDontHave(cid);\n      }\n    });\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await sha256.digest(b);\n      const cid = CID.createV0(hash);\n      msg.addBlock(cid, b);\n    }));\n    return msg;\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n      const values = vd(p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2];\n      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && (await hashLoader.getHasher(hashAlg));\n      if (!hasher) {\n        throw new CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG');\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data);\n      const cid = CID.create(cidVersion, multicodec, hash);\n      msg.addBlock(cid, p.data);\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n  return msg;\n};\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};","map":{"version":3,"names":["CID","sha256","base58btc","vd","ve","isMapEqual","Message","BitswapMessageEntry","Entry","CodeError","BitswapMessage","constructor","full","wantlist","Map","blocks","blockPresences","pendingBytes","empty","size","addEntry","cid","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","entry","get","Boolean","Have","set","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","bytes","Number","undefined","encode","finish","serializeToBitswap110","payload","data","parse","version","codec","code","multihash","digestLength","digest","length","prefix","push","bpType","BlockPresence","type","equals","other","Symbol","toStringTag","list","keys","deserialize","raw","hashLoader","decoded","decode","isFull","forEach","blockPresence","Promise","all","b","hash","createV0","p","cidVersion","multicodec","hashAlg","hasher","getHasher","create","blockPresenceSize","Wantlist"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/message/index.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { base58btc } from 'multiformats/bases/base58'\n// @ts-ignore\nimport vd from 'varint-decoder'\nimport ve from '../utils/varint-encoder.js'\nimport { isMapEqual } from '../utils/index.js'\nimport { Message } from './message.js'\nimport { BitswapMessageEntry as Entry } from './entry.js'\nimport { CodeError } from '@libp2p/interfaces/errors'\n\n/**\n * @typedef {import('../types').MultihashHasherLoader} MultihashHasherLoader\n */\n\nexport class BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor (full) {\n    this.full = full\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map()\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map()\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString(base58btc)\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock (cid, block) {\n    const cidStr = cid.toString(base58btc)\n    this.blocks.set(cidStr, block)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel (cid) {\n    const cidStr = cid.toString(base58btc)\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    }\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n      const version = cid.version\n      const codec = cid.code\n      const multihash = cid.multihash.code\n      const digestLength = cid.multihash.digest.length\n      const prefix = ve([\n        version, codec, multihash, digestLength\n      ])\n\n      msg.payload.push(\n        new Message.Block({\n          prefix,\n          data\n        })\n      )\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }))\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        // @TODO - Is this a bug ?\n        // @ts-expect-error - isMap equals map values to be objects not numbers\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {MultihashHasherLoader} [hashLoader]\n */\nBitswapMessage.deserialize = async (raw, hashLoader) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach((entry) => {\n      if (!entry.block) {\n        return\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block)\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave))\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      if (!blockPresence.cid) {\n        return\n      }\n\n      const cid = CID.decode(blockPresence.cid)\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await sha256.digest(b)\n      const cid = CID.createV0(hash)\n      msg.addBlock(cid, b)\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg)\n\n      if (!hasher) {\n        throw new CodeError('Unknown hash algorithm', 'ERR_UNKNOWN_HASH_ALG')\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data)\n      const cid = CID.create(cidVersion, multicodec, hash)\n      msg.addBlock(cid, p.data)\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}