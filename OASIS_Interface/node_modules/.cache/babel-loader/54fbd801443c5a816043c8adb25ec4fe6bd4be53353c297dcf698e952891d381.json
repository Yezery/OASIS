{"ast":null,"code":"import * as isIpfs from 'is-ipfs';\nimport { CID } from 'multiformats/cid';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolve as res } from '../utils.js';\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nexport function createResolve({\n  repo,\n  codecs,\n  bases,\n  name\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  async function resolve(path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n    const [, schema, hash, ...rest] = path.split('/'); // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;\n    const bytes = parseBytes(hash);\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash;\n      return `/${schema}/${str}`;\n    }\n    const cid = CID.decode(bytes);\n    path = rest.join('/');\n    const results = res(cid, path, codecs, repo, opts);\n    let value = cid;\n    let remainderPath = path;\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`;\n  }\n  return withTimeoutOption(resolve);\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes(str) {\n  try {\n    return peerIdFromString(str).toBytes();\n  } catch {\n    return CID.parse(str).bytes;\n  }\n}","map":{"version":3,"names":["isIpfs","CID","peerIdFromString","withTimeoutOption","resolve","res","createResolve","repo","codecs","bases","name","path","opts","Error","ipnsPath","resolvedPath","schema","hash","rest","split","base","cidBase","getBase","undefined","bytes","parseBytes","length","str","encoder","encode","cid","decode","join","results","value","remainderPath","result","asCID","toString","toBytes","parse"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/resolve.js"],"sourcesContent":["import * as isIpfs from 'is-ipfs'\nimport { CID } from 'multiformats/cid'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolve as res } from '../utils.js'\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-utils/src/multibases').Multibases} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nexport function createResolve ({ repo, codecs, bases, name }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]}\n   */\n  async function resolve (path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined\n    const bytes = parseBytes(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash\n\n      return `/${schema}/${str}`\n    }\n\n    const cid = CID.decode(bytes)\n\n    path = rest.join('/')\n\n    const results = res(cid, path, codecs, repo, opts)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return withTimeoutOption(resolve)\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes (str) {\n  try {\n    return peerIdFromString(str).toBytes()\n  } catch {\n    return CID.parse(str).bytes\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,SAAS;AACjC,SAASC,GAAG,QAAQ,kBAAkB;AACtC,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,iBAAiB,QAAQ,qCAAqC;AACvE,SAASC,OAAO,IAAIC,GAAG,QAAQ,aAAa;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAAE;EAAEC,IAAI;EAAEC,MAAM;EAAEC,KAAK;EAAEC;AAAK,CAAC,EAAE;EAC5D;AACF;AACA;EACE,eAAeN,OAAOA,CAAEO,IAAI,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAE;IACvC,IAAI,CAACZ,MAAM,CAACW,IAAI,CAACA,IAAI,CAAC,EAAE;MACtB,MAAM,IAAIE,KAAK,CAAC,mBAAmB,GAAGF,IAAI,CAAC;IAC7C;IAEA,IAAIX,MAAM,CAACc,QAAQ,CAACH,IAAI,CAAC,EAAE;MACzB,WAAW,MAAMI,YAAY,IAAIL,IAAI,CAACN,OAAO,CAACO,IAAI,EAAEC,IAAI,CAAC,EAAE;QACzDD,IAAI,GAAGI,YAAY;MACrB;IACF;IAEA,MAAM,GAAGC,MAAM,EAAEC,IAAI,EAAE,GAAGC,IAAI,CAAC,GAAGP,IAAI,CAACQ,KAAK,CAAC,GAAG,CAAC,EAAC;IAClD,MAAMC,IAAI,GAAGR,IAAI,CAACS,OAAO,GAAG,MAAMZ,KAAK,CAACa,OAAO,CAACV,IAAI,CAACS,OAAO,CAAC,GAAGE,SAAS;IACzE,MAAMC,KAAK,GAAGC,UAAU,CAACR,IAAI,CAAC;;IAE9B;IACA,IAAIC,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACrB,MAAMC,GAAG,GAAGP,IAAI,GAAGA,IAAI,CAACQ,OAAO,CAACC,MAAM,CAACL,KAAK,CAAC,GAAGP,IAAI;MAEpD,OAAQ,IAAGD,MAAO,IAAGW,GAAI,EAAC;IAC5B;IAEA,MAAMG,GAAG,GAAG7B,GAAG,CAAC8B,MAAM,CAACP,KAAK,CAAC;IAE7Bb,IAAI,GAAGO,IAAI,CAACc,IAAI,CAAC,GAAG,CAAC;IAErB,MAAMC,OAAO,GAAG5B,GAAG,CAACyB,GAAG,EAAEnB,IAAI,EAAEH,MAAM,EAAED,IAAI,EAAEK,IAAI,CAAC;IAClD,IAAIsB,KAAK,GAAGJ,GAAG;IACf,IAAIK,aAAa,GAAGxB,IAAI;IAExB,WAAW,MAAMyB,MAAM,IAAIH,OAAO,EAAE;MAClC,IAAIhC,GAAG,CAACoC,KAAK,CAACD,MAAM,CAACF,KAAK,CAAC,EAAE;QAC3BA,KAAK,GAAGE,MAAM,CAACF,KAAK;QACpBC,aAAa,GAAGC,MAAM,CAACD,aAAa;MACtC;IACF;IAEA,OAAQ,SAAQD,KAAK,CAACI,QAAQ,CAAClB,IAAI,IAAIA,IAAI,CAACQ,OAAO,CAAE,GAAEO,aAAa,GAAG,GAAG,GAAGA,aAAa,GAAG,EAAG,EAAC;EACnG;EAEA,OAAOhC,iBAAiB,CAACC,OAAO,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASqB,UAAUA,CAAEE,GAAG,EAAE;EACxB,IAAI;IACF,OAAOzB,gBAAgB,CAACyB,GAAG,CAAC,CAACY,OAAO,CAAC,CAAC;EACxC,CAAC,CAAC,MAAM;IACN,OAAOtC,GAAG,CAACuC,KAAK,CAACb,GAAG,CAAC,CAACH,KAAK;EAC7B;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}