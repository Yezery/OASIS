{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n *\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import { handshake } from 'it-handshake'\n *\n * // Create connected duplex streams\n * const [client, server] = duplexPair()\n * const clientShake = handshake(client)\n * const serverShake = handshake(server)\n *\n * clientShake.write('hello')\n * console.log('client: %s', await serverShake.read())\n * // > client: hello\n * serverShake.write('hi')\n * serverShake.rest() // the server has finished the handshake\n * console.log('server: %s', await clientShake.read())\n * // > server: hi\n * clientShake.rest() // the client has finished the handshake\n *\n * // Make the server echo responses\n * pipe(\n *   serverShake.stream,\n *   async function * (source) {\n *     for await (const message of source) {\n *       yield message\n *     }\n *   },\n *   serverShake.stream\n * )\n *\n * // Send and receive an echo through the handshake stream\n * pipe(\n *   ['echo'],\n *   clientShake.stream,\n *   async function * (source) {\n *     for await (const bufferList of source) {\n *       console.log('Echo response: %s', bufferList.slice())\n *       // > Echo response: echo\n *     }\n *   }\n * )\n * ```\n */\nimport { reader } from 'it-reader';\nimport { pushable } from 'it-pushable';\nimport defer from 'p-defer';\n// Convert a duplex stream into a reader and writer and rest stream\nexport function handshake(stream) {\n  const writer = pushable(); // Write bytes on demand to the sink\n  const source = reader(stream.source); // Read bytes on demand from the source\n  // Waits for a source to be passed to the rest stream's sink\n  const sourcePromise = defer();\n  let sinkErr;\n  const sinkPromise = stream.sink(async function* () {\n    yield* writer;\n    const source = await sourcePromise.promise;\n    yield* source;\n  }());\n  sinkPromise.catch(err => {\n    sinkErr = err;\n  });\n  const rest = {\n    sink: async source => {\n      if (sinkErr != null) {\n        await Promise.reject(sinkErr);\n        return;\n      }\n      sourcePromise.resolve(source);\n      await sinkPromise;\n    },\n    source\n  };\n  return {\n    reader: source,\n    writer,\n    stream: rest,\n    rest: () => writer.end(),\n    write: writer.push,\n    read: async () => {\n      const res = await source.next();\n      if (res.value != null) {\n        return res.value;\n      }\n    }\n  };\n}","map":{"version":3,"names":["reader","pushable","defer","handshake","stream","writer","source","sourcePromise","sinkErr","sinkPromise","sink","promise","catch","err","rest","Promise","reject","resolve","end","write","push","read","res","next","value"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,SAAiBA,MAAM,QAAQ,WAAW;AAC1C,SAASC,QAAQ,QAAQ,aAAa;AACtC,OAAOC,KAAK,MAAM,SAAS;AAc3B;AACA,OAAM,SAAUC,SAASA,CAA8DC,MAAwF;EAC7K,MAAMC,MAAM,GAAGJ,QAAQ,EAAS,EAAC;EACjC,MAAMK,MAAM,GAAGN,MAAM,CAACI,MAAM,CAACE,MAAM,CAAC,EAAC;EAErC;EACA,MAAMC,aAAa,GAAGL,KAAK,EAAiB;EAC5C,IAAIM,OAAc;EAElB,MAAMC,WAAW,GAAGL,MAAM,CAACM,IAAI,CAAE,mBAAgB;IAC/C,OAAQL,MAAM;IACd,MAAMC,MAAM,GAAG,MAAMC,aAAa,CAACI,OAAO;IAC1C,OAAQL,MAAM;EAChB,CAAC,CAAC,CAAE,CAAC;EAELG,WAAW,CAACG,KAAK,CAACC,GAAG,IAAG;IACtBL,OAAO,GAAGK,GAAG;EACf,CAAC,CAAC;EAEF,MAAMC,IAAI,GAAyE;IACjFJ,IAAI,EAAE,MAAMJ,MAAM,IAAG;MACnB,IAAIE,OAAO,IAAI,IAAI,EAAE;QACnB,MAAMO,OAAO,CAACC,MAAM,CAACR,OAAO,CAAC;QAAE;;MAGjCD,aAAa,CAACU,OAAO,CAACX,MAAM,CAAC;MAC7B,MAAMG,WAAW;IACnB,CAAC;IACDH;GACD;EAED,OAAO;IACLN,MAAM,EAAEM,MAAM;IACdD,MAAM;IACND,MAAM,EAAEU,IAAI;IACZA,IAAI,EAAEA,CAAA,KAAMT,MAAM,CAACa,GAAG,EAAE;IACxBC,KAAK,EAAEd,MAAM,CAACe,IAAI;IAClBC,IAAI,EAAE,MAAAA,CAAA,KAAW;MACf,MAAMC,GAAG,GAAG,MAAMhB,MAAM,CAACiB,IAAI,EAAE;MAE/B,IAAID,GAAG,CAACE,KAAK,IAAI,IAAI,EAAE;QACrB,OAAOF,GAAG,CAACE,KAAK;;IAEpB;GACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}