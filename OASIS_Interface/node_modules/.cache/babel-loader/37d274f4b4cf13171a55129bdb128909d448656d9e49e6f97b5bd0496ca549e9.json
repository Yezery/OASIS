{"ast":null,"code":"import { Token, Type } from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","map":{"version":3,"names":["Token","Type","uint","decodeErrPrefix","toToken","_data","_pos","prefix","length","array","decodeArrayCompact","data","pos","minor","_options","decodeArray8","_minor","options","readUint8","decodeArray16","readUint16","decodeArray32","readUint32","decodeArray64","l","readUint64","Error","decodeArrayIndefinite","allowIndefinite","Infinity","encodeArray","buf","token","encodeUintValue","majorEncoded","value","compareTokens","encodeUint","encodedSize"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.1/node_modules/cborg/lib/4array.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}