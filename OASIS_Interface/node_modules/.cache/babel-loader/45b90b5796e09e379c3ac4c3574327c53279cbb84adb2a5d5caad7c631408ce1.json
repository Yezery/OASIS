{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    if (opts.redis) {\n      this.client = opts.redis;\n    } else {\n      this.client = opts.storeClient;\n    }\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: incrTtlLuaScript\n      });\n    }\n  }\n\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    }\n    // ioredis client\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    }\n    // node-redis client\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n    return true;\n  }\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result;\n    // Support ioredis results format\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n    return res;\n  }\n  _upsert(rlKey, points, msDuration, forceExpire = false) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n      const secDuration = Math.floor(msDuration / 1000);\n      const multi = this.client.multi();\n      if (forceExpire) {\n        if (secDuration > 0) {\n          multi.set(rlKey, points, 'EX', secDuration);\n        } else {\n          multi.set(rlKey, points);\n        }\n        multi.pttl(rlKey).exec((err, res) => {\n          if (err) {\n            return reject(err);\n          }\n          return resolve(res);\n        });\n      } else {\n        if (secDuration > 0) {\n          const incrCallback = function (err, result) {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(result);\n          };\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);\n          } else {\n            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);\n          }\n        } else {\n          multi.incrby(rlKey, points).pttl(rlKey).exec((err, res) => {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(res);\n          });\n        }\n      }\n    });\n  }\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n      this.client.multi().get(rlKey).pttl(rlKey).exec((err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          const [points] = res;\n          if (points === null) {\n            return resolve(null);\n          }\n          resolve(res);\n        }\n      });\n    });\n  }\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res > 0);\n        }\n      });\n    });\n  }\n}\nmodule.exports = RateLimiterRedis;","map":{"version":3,"names":["RateLimiterStoreAbstract","require","RateLimiterRes","incrTtlLuaScript","RateLimiterRedis","constructor","opts","redis","client","storeClient","_rejectIfRedisNotReady","rejectIfRedisNotReady","defineCommand","numberOfKeys","lua","_isRedisReady","status","isReady","_getRateLimiterRes","rlKey","changedPoints","result","consumed","resTtlMs","Array","isArray","res","consumedPoints","parseInt","isFirstInDuration","remainingPoints","Math","max","points","msBeforeNext","_upsert","msDuration","forceExpire","Promise","resolve","reject","Error","secDuration","floor","multi","set","pttl","exec","err","incrCallback","rlflxIncr","eval","incrby","_get","get","_delete","del","module","exports"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterRedis.js"],"sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst incrTtlLuaScript = `redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') \\\nlocal consumed = redis.call('incrby', KEYS[1], ARGV[1]) \\\nlocal ttl = redis.call('pttl', KEYS[1]) \\\nif ttl == -1 then \\\n  redis.call('expire', KEYS[1], ARGV[2]) \\\n  ttl = 1000 * ARGV[2] \\\nend \\\nreturn {consumed, ttl} \\\n`;\n\nclass RateLimiterRedis extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   redis: RedisClient\n   *   rejectIfRedisNotReady: boolean = false - reject / invoke insuranceLimiter immediately when redis connection is not \"ready\"\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    if (opts.redis) {\n      this.client = opts.redis;\n    } else {\n      this.client = opts.storeClient;\n    }\n\n    this._rejectIfRedisNotReady = !!opts.rejectIfRedisNotReady;\n\n    if (typeof this.client.defineCommand === 'function') {\n      this.client.defineCommand(\"rlflxIncr\", {\n        numberOfKeys: 1,\n        lua: incrTtlLuaScript,\n      });\n    }\n  }\n\n  /**\n   * Prevent actual redis call if redis connection is not ready\n   * Because of different connection state checks for ioredis and node-redis, only this clients would be actually checked.\n   * For any other clients all the requests would be passed directly to redis client\n   * @return {boolean}\n   * @private\n   */\n  _isRedisReady() {\n    if (!this._rejectIfRedisNotReady) {\n      return true;\n    }\n    // ioredis client\n    if (this.client.status && this.client.status !== 'ready') {\n      return false;\n    }\n    // node-redis client\n    if (typeof this.client.isReady === 'function' && !this.client.isReady()) {\n      return false;\n    }\n    return true;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    let [consumed, resTtlMs] = result;\n    // Support ioredis results format\n    if (Array.isArray(consumed)) {\n      [, consumed] = consumed;\n      [, resTtlMs] = resTtlMs;\n    }\n\n    const res = new RateLimiterRes();\n    res.consumedPoints = parseInt(consumed);\n    res.isFirstInDuration = res.consumedPoints === changedPoints;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = resTtlMs;\n\n    return res;\n  }\n\n  _upsert(rlKey, points, msDuration, forceExpire = false) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      const secDuration = Math.floor(msDuration / 1000);\n      const multi = this.client.multi();\n      if (forceExpire) {\n        if (secDuration > 0) {\n          multi.set(rlKey, points, 'EX', secDuration);\n        } else {\n          multi.set(rlKey, points);\n        }\n\n        multi.pttl(rlKey)\n          .exec((err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          });\n      } else {\n        if (secDuration > 0) {\n          const incrCallback = function(err, result) {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(result);\n          };\n\n          if (typeof this.client.rlflxIncr === 'function') {\n            this.client.rlflxIncr(rlKey, points, secDuration, incrCallback);\n          } else {\n            this.client.eval(incrTtlLuaScript, 1, rlKey, points, secDuration, incrCallback);\n          }\n        } else {\n          multi.incrby(rlKey, points)\n            .pttl(rlKey)\n            .exec((err, res) => {\n              if (err) {\n                return reject(err);\n              }\n\n              return resolve(res);\n            });\n        }\n      }\n    });\n  }\n\n  _get(rlKey) {\n    return new Promise((resolve, reject) => {\n      if (!this._isRedisReady()) {\n        return reject(new Error('Redis connection is not ready'));\n      }\n\n      this.client\n        .multi()\n        .get(rlKey)\n        .pttl(rlKey)\n        .exec((err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            const [points] = res;\n            if (points === null) {\n              return resolve(null)\n            }\n\n            resolve(res);\n          }\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    return new Promise((resolve, reject) => {\n      this.client.del(rlKey, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res > 0);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = RateLimiterRedis;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}