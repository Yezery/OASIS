{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').RootsReader} RootsReader\n * @typedef {import('./coding').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor(version, roots, iterable) {\n    this._version = version;\n    this._roots = roots;\n    this._iterable = iterable;\n    this._decoded = false;\n  }\n  get version() {\n    return this._version;\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots() {\n    return this._roots;\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n    this._decoded = true;\n    return this._iterable[Symbol.asyncIterator]();\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes(bytes) {\n    const {\n      version,\n      roots,\n      iterator\n    } = await fromBytes(bytes);\n    return new CarBlockIterator(version, roots, iterator);\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable(asyncIterable) {\n    const {\n      version,\n      roots,\n      iterator\n    } = await fromIterable(asyncIterable);\n    return new CarBlockIterator(version, roots, iterator);\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator]() {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once');\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found');\n    }\n    this._decoded = true;\n    const iterable = this._iterable[Symbol.asyncIterator]();\n    return {\n      async next() {\n        const next = await iterable.next();\n        if (next.done) {\n          return next;\n        }\n        return {\n          done: false,\n          value: next.value.cid\n        };\n      }\n    };\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes(bytes) {\n    const {\n      version,\n      roots,\n      iterator\n    } = await fromBytes(bytes);\n    return new CarCIDIterator(version, roots, iterator);\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable(asyncIterable) {\n    const {\n      version,\n      roots,\n      iterator\n    } = await fromIterable(asyncIterable);\n    return new CarCIDIterator(version, roots, iterator);\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes(bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array');\n  }\n  return decodeIterator(bytesReader(bytes));\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable(asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable');\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable));\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator(reader) {\n  const decoder = createDecoder(reader);\n  const {\n    version,\n    roots\n  } = await decoder.header();\n  return {\n    version,\n    roots,\n    iterator: decoder.blocks()\n  };\n}","map":{"version":3,"names":["asyncIterableReader","bytesReader","createDecoder","CarIteratorBase","constructor","version","roots","iterable","_version","_roots","_iterable","_decoded","getRoots","CarBlockIterator","Symbol","asyncIterator","Error","fromBytes","bytes","iterator","fromIterable","asyncIterable","CarCIDIterator","next","done","value","cid","Uint8Array","TypeError","decodeIterator","reader","decoder","header","blocks"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/@ipld+car@5.2.3/node_modules/@ipld/car/src/iterator.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').RootsReader} RootsReader\n * @typedef {import('./coding').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}