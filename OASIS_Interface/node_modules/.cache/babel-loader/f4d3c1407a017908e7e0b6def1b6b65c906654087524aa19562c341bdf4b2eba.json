{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nconst ModuleError = require('module-error');\nconst {\n  Buffer\n} = require('buffer') || {};\nconst {\n  AbstractSublevelIterator,\n  AbstractSublevelKeyIterator,\n  AbstractSublevelValueIterator\n} = require('./abstract-sublevel-iterator');\nconst kPrefix = Symbol('prefix');\nconst kUpperBound = Symbol('upperBound');\nconst kPrefixRange = Symbol('prefixRange');\nconst kParent = Symbol('parent');\nconst kUnfix = Symbol('unfix');\nconst textEncoder = new TextEncoder();\nconst defaults = {\n  separator: '!'\n};\n\n// Wrapped to avoid circular dependency\nmodule.exports = function ({\n  AbstractLevel\n}) {\n  class AbstractSublevel extends AbstractLevel {\n    static defaults(options) {\n      // To help migrating from subleveldown to abstract-level\n      if (typeof options === 'string') {\n        throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {\n          code: 'LEVEL_LEGACY'\n        });\n      } else if (options && options.open) {\n        throw new ModuleError('The subleveldown open option has been removed', {\n          code: 'LEVEL_LEGACY'\n        });\n      }\n      if (options == null) {\n        return defaults;\n      } else if (!options.separator) {\n        return {\n          ...options,\n          separator: '!'\n        };\n      } else {\n        return options;\n      }\n    }\n\n    // TODO: add autoClose option, which if true, does parent.attachResource(this)\n    constructor(db, name, options) {\n      // Don't forward AbstractSublevel options to AbstractLevel\n      const {\n        separator,\n        manifest,\n        ...forward\n      } = AbstractSublevel.defaults(options);\n      name = trim(name, separator);\n\n      // Reserve one character between separator and name to give us an upper bound\n      const reserved = separator.charCodeAt(0) + 1;\n      const parent = db[kParent] || db;\n\n      // Keys should sort like ['!a!', '!a!!a!', '!a\"', '!aa!', '!b!'].\n      // Use ASCII for consistent length between string, Buffer and Uint8Array\n      if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {\n        throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {\n          code: 'LEVEL_INVALID_PREFIX'\n        });\n      }\n      super(mergeManifests(parent, manifest), forward);\n      const prefix = (db.prefix || '') + separator + name + separator;\n      const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);\n      this[kParent] = parent;\n      this[kPrefix] = new MultiFormat(prefix);\n      this[kUpperBound] = new MultiFormat(upperBound);\n      this[kUnfix] = new Unfixer();\n      this.nextTick = parent.nextTick;\n    }\n    prefixKey(key, keyFormat) {\n      if (keyFormat === 'utf8') {\n        return this[kPrefix].utf8 + key;\n      } else if (key.byteLength === 0) {\n        // Fast path for empty key (no copy)\n        return this[kPrefix][keyFormat];\n      } else if (keyFormat === 'view') {\n        const view = this[kPrefix].view;\n        const result = new Uint8Array(view.byteLength + key.byteLength);\n        result.set(view, 0);\n        result.set(key, view.byteLength);\n        return result;\n      } else {\n        const buffer = this[kPrefix].buffer;\n        return Buffer.concat([buffer, key], buffer.byteLength + key.byteLength);\n      }\n    }\n\n    // Not exposed for now.\n    [kPrefixRange](range, keyFormat) {\n      if (range.gte !== undefined) {\n        range.gte = this.prefixKey(range.gte, keyFormat);\n      } else if (range.gt !== undefined) {\n        range.gt = this.prefixKey(range.gt, keyFormat);\n      } else {\n        range.gte = this[kPrefix][keyFormat];\n      }\n      if (range.lte !== undefined) {\n        range.lte = this.prefixKey(range.lte, keyFormat);\n      } else if (range.lt !== undefined) {\n        range.lt = this.prefixKey(range.lt, keyFormat);\n      } else {\n        range.lte = this[kUpperBound][keyFormat];\n      }\n    }\n    get prefix() {\n      return this[kPrefix].utf8;\n    }\n    get db() {\n      return this[kParent];\n    }\n    _open(options, callback) {\n      // The parent db must open itself or be (re)opened by the user because\n      // a sublevel should not initiate state changes on the rest of the db.\n      this[kParent].open({\n        passive: true\n      }, callback);\n    }\n    _put(key, value, options, callback) {\n      this[kParent].put(key, value, options, callback);\n    }\n    _get(key, options, callback) {\n      this[kParent].get(key, options, callback);\n    }\n    _getMany(keys, options, callback) {\n      this[kParent].getMany(keys, options, callback);\n    }\n    _del(key, options, callback) {\n      this[kParent].del(key, options, callback);\n    }\n    _batch(operations, options, callback) {\n      this[kParent].batch(operations, options, callback);\n    }\n    _clear(options, callback) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding);\n      this[kParent].clear(options, callback);\n    }\n    _iterator(options) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].iterator(options);\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);\n      return new AbstractSublevelIterator(this, options, iterator, unfix);\n    }\n    _keys(options) {\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].keys(options);\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);\n      return new AbstractSublevelKeyIterator(this, options, iterator, unfix);\n    }\n    _values(options) {\n      this[kPrefixRange](options, options.keyEncoding);\n      const iterator = this[kParent].values(options);\n      return new AbstractSublevelValueIterator(this, options, iterator);\n    }\n  }\n  return {\n    AbstractSublevel\n  };\n};\nconst mergeManifests = function (parent, manifest) {\n  return {\n    // Inherit manifest of parent db\n    ...parent.supports,\n    // Disable unsupported features\n    createIfMissing: false,\n    errorIfExists: false,\n    // Unset additional events because we're not forwarding them\n    events: {},\n    // Unset additional methods (like approximateSize) which we can't support here unless\n    // the AbstractSublevel class is overridden by an implementation of `abstract-level`.\n    additionalMethods: {},\n    // Inherit manifest of custom AbstractSublevel subclass. Such a class is not\n    // allowed to override encodings.\n    ...manifest,\n    encodings: {\n      utf8: supportsEncoding(parent, 'utf8'),\n      buffer: supportsEncoding(parent, 'buffer'),\n      view: supportsEncoding(parent, 'view')\n    }\n  };\n};\nconst supportsEncoding = function (parent, encoding) {\n  // Prefer a non-transcoded encoding for optimal performance\n  return parent.supports.encodings[encoding] ? parent.keyEncoding(encoding).name === encoding : false;\n};\nclass MultiFormat {\n  constructor(key) {\n    this.utf8 = key;\n    this.view = textEncoder.encode(key);\n    this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {};\n  }\n}\nclass Unfixer {\n  constructor() {\n    this.cache = new Map();\n  }\n  get(prefixLength, keyFormat) {\n    let unfix = this.cache.get(keyFormat);\n    if (unfix === undefined) {\n      if (keyFormat === 'view') {\n        unfix = function (prefixLength, key) {\n          // Avoid Uint8Array#slice() because it copies\n          return key.subarray(prefixLength);\n        }.bind(null, prefixLength);\n      } else {\n        unfix = function (prefixLength, key) {\n          // Avoid Buffer#subarray() because it's slow\n          return key.slice(prefixLength);\n        }.bind(null, prefixLength);\n      }\n      this.cache.set(keyFormat, unfix);\n    }\n    return unfix;\n  }\n}\nconst trim = function (str, char) {\n  let start = 0;\n  let end = str.length;\n  while (start < end && str[start] === char) start++;\n  while (end > start && str[end - 1] === char) end--;\n  return str.slice(start, end);\n};","map":{"version":3,"names":["require","ModuleError","Buffer","AbstractSublevelIterator","AbstractSublevelKeyIterator","AbstractSublevelValueIterator","kPrefix","Symbol","kUpperBound","kPrefixRange","kParent","kUnfix","textEncoder","TextEncoder","defaults","separator","module","exports","AbstractLevel","AbstractSublevel","options","code","open","constructor","db","name","manifest","forward","trim","reserved","charCodeAt","parent","encode","every","x","mergeManifests","prefix","upperBound","slice","String","fromCharCode","MultiFormat","Unfixer","nextTick","prefixKey","key","keyFormat","utf8","byteLength","view","result","Uint8Array","set","buffer","concat","range","gte","undefined","gt","lte","lt","_open","callback","passive","_put","value","put","_get","get","_getMany","keys","getMany","_del","del","_batch","operations","batch","_clear","keyEncoding","clear","_iterator","iterator","unfix","length","_keys","_values","values","supports","createIfMissing","errorIfExists","events","additionalMethods","encodings","supportsEncoding","encoding","from","cache","Map","prefixLength","subarray","bind","str","char","start","end"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/abstract-level@1.0.3/node_modules/abstract-level/lib/abstract-sublevel.js"],"sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst { Buffer } = require('buffer') || {}\nconst {\n  AbstractSublevelIterator,\n  AbstractSublevelKeyIterator,\n  AbstractSublevelValueIterator\n} = require('./abstract-sublevel-iterator')\n\nconst kPrefix = Symbol('prefix')\nconst kUpperBound = Symbol('upperBound')\nconst kPrefixRange = Symbol('prefixRange')\nconst kParent = Symbol('parent')\nconst kUnfix = Symbol('unfix')\n\nconst textEncoder = new TextEncoder()\nconst defaults = { separator: '!' }\n\n// Wrapped to avoid circular dependency\nmodule.exports = function ({ AbstractLevel }) {\n  class AbstractSublevel extends AbstractLevel {\n    static defaults (options) {\n      // To help migrating from subleveldown to abstract-level\n      if (typeof options === 'string') {\n        throw new ModuleError('The subleveldown string shorthand for { separator } has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      } else if (options && options.open) {\n        throw new ModuleError('The subleveldown open option has been removed', {\n          code: 'LEVEL_LEGACY'\n        })\n      }\n\n      if (options == null) {\n        return defaults\n      } else if (!options.separator) {\n        return { ...options, separator: '!' }\n      } else {\n        return options\n      }\n    }\n\n    // TODO: add autoClose option, which if true, does parent.attachResource(this)\n    constructor (db, name, options) {\n      // Don't forward AbstractSublevel options to AbstractLevel\n      const { separator, manifest, ...forward } = AbstractSublevel.defaults(options)\n      name = trim(name, separator)\n\n      // Reserve one character between separator and name to give us an upper bound\n      const reserved = separator.charCodeAt(0) + 1\n      const parent = db[kParent] || db\n\n      // Keys should sort like ['!a!', '!a!!a!', '!a\"', '!aa!', '!b!'].\n      // Use ASCII for consistent length between string, Buffer and Uint8Array\n      if (!textEncoder.encode(name).every(x => x > reserved && x < 127)) {\n        throw new ModuleError(`Prefix must use bytes > ${reserved} < ${127}`, {\n          code: 'LEVEL_INVALID_PREFIX'\n        })\n      }\n\n      super(mergeManifests(parent, manifest), forward)\n\n      const prefix = (db.prefix || '') + separator + name + separator\n      const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved)\n\n      this[kParent] = parent\n      this[kPrefix] = new MultiFormat(prefix)\n      this[kUpperBound] = new MultiFormat(upperBound)\n      this[kUnfix] = new Unfixer()\n\n      this.nextTick = parent.nextTick\n    }\n\n    prefixKey (key, keyFormat) {\n      if (keyFormat === 'utf8') {\n        return this[kPrefix].utf8 + key\n      } else if (key.byteLength === 0) {\n        // Fast path for empty key (no copy)\n        return this[kPrefix][keyFormat]\n      } else if (keyFormat === 'view') {\n        const view = this[kPrefix].view\n        const result = new Uint8Array(view.byteLength + key.byteLength)\n\n        result.set(view, 0)\n        result.set(key, view.byteLength)\n\n        return result\n      } else {\n        const buffer = this[kPrefix].buffer\n        return Buffer.concat([buffer, key], buffer.byteLength + key.byteLength)\n      }\n    }\n\n    // Not exposed for now.\n    [kPrefixRange] (range, keyFormat) {\n      if (range.gte !== undefined) {\n        range.gte = this.prefixKey(range.gte, keyFormat)\n      } else if (range.gt !== undefined) {\n        range.gt = this.prefixKey(range.gt, keyFormat)\n      } else {\n        range.gte = this[kPrefix][keyFormat]\n      }\n\n      if (range.lte !== undefined) {\n        range.lte = this.prefixKey(range.lte, keyFormat)\n      } else if (range.lt !== undefined) {\n        range.lt = this.prefixKey(range.lt, keyFormat)\n      } else {\n        range.lte = this[kUpperBound][keyFormat]\n      }\n    }\n\n    get prefix () {\n      return this[kPrefix].utf8\n    }\n\n    get db () {\n      return this[kParent]\n    }\n\n    _open (options, callback) {\n      // The parent db must open itself or be (re)opened by the user because\n      // a sublevel should not initiate state changes on the rest of the db.\n      this[kParent].open({ passive: true }, callback)\n    }\n\n    _put (key, value, options, callback) {\n      this[kParent].put(key, value, options, callback)\n    }\n\n    _get (key, options, callback) {\n      this[kParent].get(key, options, callback)\n    }\n\n    _getMany (keys, options, callback) {\n      this[kParent].getMany(keys, options, callback)\n    }\n\n    _del (key, options, callback) {\n      this[kParent].del(key, options, callback)\n    }\n\n    _batch (operations, options, callback) {\n      this[kParent].batch(operations, options, callback)\n    }\n\n    _clear (options, callback) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      this[kParent].clear(options, callback)\n    }\n\n    _iterator (options) {\n      // TODO (refactor): move to AbstractLevel\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].iterator(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelIterator(this, options, iterator, unfix)\n    }\n\n    _keys (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].keys(options)\n      const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding)\n      return new AbstractSublevelKeyIterator(this, options, iterator, unfix)\n    }\n\n    _values (options) {\n      this[kPrefixRange](options, options.keyEncoding)\n      const iterator = this[kParent].values(options)\n      return new AbstractSublevelValueIterator(this, options, iterator)\n    }\n  }\n\n  return { AbstractSublevel }\n}\n\nconst mergeManifests = function (parent, manifest) {\n  return {\n    // Inherit manifest of parent db\n    ...parent.supports,\n\n    // Disable unsupported features\n    createIfMissing: false,\n    errorIfExists: false,\n\n    // Unset additional events because we're not forwarding them\n    events: {},\n\n    // Unset additional methods (like approximateSize) which we can't support here unless\n    // the AbstractSublevel class is overridden by an implementation of `abstract-level`.\n    additionalMethods: {},\n\n    // Inherit manifest of custom AbstractSublevel subclass. Such a class is not\n    // allowed to override encodings.\n    ...manifest,\n\n    encodings: {\n      utf8: supportsEncoding(parent, 'utf8'),\n      buffer: supportsEncoding(parent, 'buffer'),\n      view: supportsEncoding(parent, 'view')\n    }\n  }\n}\n\nconst supportsEncoding = function (parent, encoding) {\n  // Prefer a non-transcoded encoding for optimal performance\n  return parent.supports.encodings[encoding]\n    ? parent.keyEncoding(encoding).name === encoding\n    : false\n}\n\nclass MultiFormat {\n  constructor (key) {\n    this.utf8 = key\n    this.view = textEncoder.encode(key)\n    this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {}\n  }\n}\n\nclass Unfixer {\n  constructor () {\n    this.cache = new Map()\n  }\n\n  get (prefixLength, keyFormat) {\n    let unfix = this.cache.get(keyFormat)\n\n    if (unfix === undefined) {\n      if (keyFormat === 'view') {\n        unfix = function (prefixLength, key) {\n          // Avoid Uint8Array#slice() because it copies\n          return key.subarray(prefixLength)\n        }.bind(null, prefixLength)\n      } else {\n        unfix = function (prefixLength, key) {\n          // Avoid Buffer#subarray() because it's slow\n          return key.slice(prefixLength)\n        }.bind(null, prefixLength)\n      }\n\n      this.cache.set(keyFormat, unfix)\n    }\n\n    return unfix\n  }\n}\n\nconst trim = function (str, char) {\n  let start = 0\n  let end = str.length\n\n  while (start < end && str[start] === char) start++\n  while (end > start && str[end - 1] === char) end--\n\n  return str.slice(start, end)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}