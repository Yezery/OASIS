{"ast":null,"code":"import { createLock } from './utils/create-lock.js';\nimport * as isIpfs from 'is-ipfs';\nimport { createStat } from './stat.js';\nimport { createChmod } from './chmod.js';\nimport { createCp } from './cp.js';\nimport { createFlush } from './flush.js';\nimport { createMkdir } from './mkdir.js';\nimport { createMv } from './mv.js';\nimport { createRm } from './rm.js';\nimport { createTouch } from './touch.js';\nimport { createRead } from './read.js';\nimport { createWrite } from './write.js';\nimport { createLs } from './ls.js';\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: createStat\n};\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: createChmod,\n  cp: createCp,\n  flush: createFlush,\n  mkdir: createMkdir,\n  mv: createMv,\n  rm: createRm,\n  touch: createTouch\n};\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: createWrite,\n  read: createRead,\n  ls: createLs\n};\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n};\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  const lock = createLock(repoOwner);\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n\n  /** @type {Record<string, any>} */\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nexport function createFiles({\n  repo,\n  preload,\n  hashers,\n  options: constructorOptions\n}) {\n  const methods = createMfs({\n    repo,\n    repoOwner: constructorOptions.repoOwner !== false,\n    hashers\n  });\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n      if (paths.length) {\n        const options = args[args.length - 1];\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path));\n        }\n      }\n      return fn(...args);\n    };\n    return wrapped;\n  };\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function* ( /** @type {...any} */...args) {\n      for await (const file of methods.ls(...args)) {\n        yield {\n          ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n}","map":{"version":3,"names":["createLock","isIpfs","createStat","createChmod","createCp","createFlush","createMkdir","createMv","createRm","createTouch","createRead","createWrite","createLs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","repo","createMfs","assign","readLock","operation","writeLock","createFiles","preload","hashers","constructorOptions","methods","withPreload","fn","wrapped","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/index.js"],"sourcesContent":["import { createLock } from './utils/create-lock.js'\nimport * as isIpfs from 'is-ipfs'\nimport { createStat } from './stat.js'\nimport { createChmod } from './chmod.js'\nimport { createCp } from './cp.js'\nimport { createFlush } from './flush.js'\nimport { createMkdir } from './mkdir.js'\nimport { createMv } from './mv.js'\nimport { createRm } from './rm.js'\nimport { createTouch } from './touch.js'\nimport { createRead } from './read.js'\nimport { createWrite } from './write.js'\nimport { createLs } from './ls.js'\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: createStat\n}\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: createChmod,\n  cp: createCp,\n  flush: createFlush,\n  mkdir: createMkdir,\n  mv: createMv,\n  rm: createRm,\n  touch: createTouch\n}\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: createWrite,\n  read: createRead,\n  ls: createLs\n}\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n}\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  const lock = createLock(repoOwner)\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  /** @type {Record<string, any>} */\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nexport function createFiles ({ repo, preload, hashers, options: constructorOptions }) {\n  const methods = createMfs({\n    repo,\n    repoOwner: constructorOptions.repoOwner !== false,\n    hashers\n  })\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n      if (paths.length) {\n        const options = args[args.length - 1]\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path))\n        }\n      }\n\n      return fn(...args)\n    }\n\n    return wrapped\n  }\n\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function * (/** @type {...any} */ ...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}