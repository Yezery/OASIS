{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Key } from 'interface-datastore/key';\nimport { Libp2pRecord } from '@libp2p/record';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst log = logger('ipfs:ipns:offline-datastore');\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nexport class OfflineDatastore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(datastore) {\n    this._datastore = datastore;\n    /** @type {any[]} */\n    this.stores = [];\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put(key, value, options) {\n    // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n    }\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n    }\n    let routingKey;\n    try {\n      routingKey = this._routingKey(key);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Libp2pRecord(key, value, new Date());\n    await this._datastore.put(routingKey, record.serialize(), options);\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get(key, options) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n    }\n    let routingKey;\n    try {\n      routingKey = this._routingKey(key);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n    }\n    const res = await this._datastore.get(routingKey, options);\n\n    // Unmarshal libp2p record as the DHT does\n    let record;\n    try {\n      record = Libp2pRecord.deserialize(res);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n    return record.value;\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey(key) {\n    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false);\n  }\n}","map":{"version":3,"names":["Key","Libp2pRecord","errcode","logger","toString","uint8ArrayToString","log","OfflineDatastore","constructor","datastore","_datastore","stores","put","key","value","options","Uint8Array","Error","routingKey","_routingKey","err","error","record","Date","serialize","get","res","deserialize"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js"],"sourcesContent":["import { Key } from 'interface-datastore/key'\nimport { Libp2pRecord } from '@libp2p/record'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns:offline-datastore')\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nexport class OfflineDatastore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (datastore) {\n    this._datastore = datastore\n    /** @type {any[]} */\n    this.stores = []\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put (key, value, options) { // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Libp2pRecord(key, value, new Date())\n\n    await this._datastore.put(routingKey, record.serialize(), options)\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    const res = await this._datastore.get(routingKey, options)\n\n    // Unmarshal libp2p record as the DHT does\n    let record\n    try {\n      record = Libp2pRecord.deserialize(res)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    return record.value\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey (key) {\n    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false)\n  }\n}\n"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,yBAAyB;AAC7C,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,MAAM,QAAQ,gBAAgB;AACvC,SAASC,QAAQ,IAAIC,kBAAkB,QAAQ,uBAAuB;AAEtE,MAAMC,GAAG,GAAGH,MAAM,CAAC,6BAA6B,CAAC;;AAEjD;AACA;AACA;;AAEA;AACA;AACA,OAAO,MAAMI,gBAAgB,CAAC;EAC5B;AACF;AACA;EACEC,WAAWA,CAAEC,SAAS,EAAE;IACtB,IAAI,CAACC,UAAU,GAAGD,SAAS;IAC3B;IACA,IAAI,CAACE,MAAM,GAAG,EAAE;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,GAAGA,CAAEC,GAAG,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAAE;IAChC,IAAI,EAAEF,GAAG,YAAYG,UAAU,CAAC,EAAE;MAChC,MAAMd,OAAO,CAAC,IAAIe,KAAK,CAAC,4CAA4C,CAAC,EAAE,iBAAiB,CAAC;IAC3F;IAEA,IAAI,EAAEH,KAAK,YAAYE,UAAU,CAAC,EAAE;MAClC,MAAMd,OAAO,CAAC,IAAIe,KAAK,CAAC,8CAA8C,CAAC,EAAE,mBAAmB,CAAC;IAC/F;IAEA,IAAIC,UAAU;IAEd,IAAI;MACFA,UAAU,GAAG,IAAI,CAACC,WAAW,CAACN,GAAG,CAAC;IACpC,CAAC,CAAC,QAAO,kBAAmBO,GAAG,EAAE;MAC/Bd,GAAG,CAACe,KAAK,CAACD,GAAG,CAAC;MACd,MAAMlB,OAAO,CAAC,IAAIe,KAAK,CAAC,0CAA0C,CAAC,EAAE,4BAA4B,CAAC;IACpG;;IAEA;IACA,MAAMK,MAAM,GAAG,IAAIrB,YAAY,CAACY,GAAG,EAAEC,KAAK,EAAE,IAAIS,IAAI,CAAC,CAAC,CAAC;IAEvD,MAAM,IAAI,CAACb,UAAU,CAACE,GAAG,CAACM,UAAU,EAAEI,MAAM,CAACE,SAAS,CAAC,CAAC,EAAET,OAAO,CAAC;EACpE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMU,GAAGA,CAAEZ,GAAG,EAAEE,OAAO,EAAE;IACvB,IAAI,EAAEF,GAAG,YAAYG,UAAU,CAAC,EAAE;MAChC,MAAMd,OAAO,CAAC,IAAIe,KAAK,CAAC,4CAA4C,CAAC,EAAE,iBAAiB,CAAC;IAC3F;IAEA,IAAIC,UAAU;IAEd,IAAI;MACFA,UAAU,GAAG,IAAI,CAACC,WAAW,CAACN,GAAG,CAAC;IACpC,CAAC,CAAC,QAAO,kBAAmBO,GAAG,EAAE;MAC/Bd,GAAG,CAACe,KAAK,CAACD,GAAG,CAAC;MACd,MAAMlB,OAAO,CAAC,IAAIe,KAAK,CAAC,0CAA0C,CAAC,EAAE,4BAA4B,CAAC;IACpG;IAEA,MAAMS,GAAG,GAAG,MAAM,IAAI,CAAChB,UAAU,CAACe,GAAG,CAACP,UAAU,EAAEH,OAAO,CAAC;;IAE1D;IACA,IAAIO,MAAM;IACV,IAAI;MACFA,MAAM,GAAGrB,YAAY,CAAC0B,WAAW,CAACD,GAAG,CAAC;IACxC,CAAC,CAAC,QAAO,kBAAmBN,GAAG,EAAE;MAC/Bd,GAAG,CAACe,KAAK,CAACD,GAAG,CAAC;MACd,MAAMA,GAAG;IACX;IAEA,OAAOE,MAAM,CAACR,KAAK;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEK,WAAWA,CAAEN,GAAG,EAAE;IAChB,OAAO,IAAIb,GAAG,CAAC,cAAc,GAAGK,kBAAkB,CAACQ,GAAG,EAAE,QAAQ,CAAC,EAAE,KAAK,CAAC;EAC3E;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}