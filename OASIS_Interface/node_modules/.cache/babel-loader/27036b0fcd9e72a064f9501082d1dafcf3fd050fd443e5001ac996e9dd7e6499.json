{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WantListEntry as Entry } from './entry.js';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { Message } from '../message/message.js';\nimport { trackedMap } from '@libp2p/tracked-map';\nconst WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\n\n/**\n * @template T\n * @param {(v:T) => number} fn\n * @param {T[]} list\n * @returns {T[]}\n */\nconst sortBy = (fn, list) => {\n  return Array.prototype.slice.call(list, 0).sort((a, b) => {\n    const aa = fn(a);\n    const bb = fn(b);\n    return aa < bb ? -1 : aa > bb ? 1 : 0;\n  });\n};\n\n/**\n * @typedef {import('multiformats').CID} CID\n */\n\nexport class Wantlist {\n  /**\n   * @param {import('../stats').Stats} [stats]\n   * @param {import('@libp2p/interface-libp2p').Libp2p} [libp2p]\n   */\n  constructor(stats, libp2p) {\n    /** @type {Map<string, Entry>} */\n    this.set = libp2p ? trackedMap({\n      name: 'ipfs_bitswap_wantlist',\n      metrics: libp2p.metrics\n    }) : new Map();\n    this._stats = stats;\n  }\n  get length() {\n    return this.set.size;\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('../message/message').Message.Wantlist.WantType} wantType\n   */\n  add(cid, priority, wantType) {\n    const cidStr = cid.toString(base58btc);\n    const entry = this.set.get(cidStr);\n    if (entry) {\n      entry.inc();\n      entry.priority = priority;\n\n      // We can only overwrite want-have with want-block\n      if (entry.wantType === WantType.Have && wantType === WantType.Block) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.set.set(cidStr, new Entry(cid, priority, wantType));\n      if (this._stats) {\n        this._stats.push(null, 'wantListSize', 1);\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  remove(cid) {\n    const cidStr = cid.toString(base58btc);\n    const entry = this.set.get(cidStr);\n    if (!entry) {\n      return;\n    }\n    entry.dec();\n\n    // only delete when no refs are held\n    if (entry.hasRefs()) {\n      return;\n    }\n    this.set.delete(cidStr);\n    if (this._stats) {\n      this._stats.push(null, 'wantListSize', -1);\n    }\n  }\n\n  /**\n   * @param {string} cidStr\n   */\n  removeForce(cidStr) {\n    if (this.set.has(cidStr)) {\n      this.set.delete(cidStr);\n    }\n  }\n\n  /**\n   * @param {(entry:Entry, key:string) => void} fn\n   */\n  forEach(fn) {\n    return this.set.forEach(fn);\n  }\n  entries() {\n    return this.set.entries();\n  }\n  sortedEntries() {\n    // TODO: Figure out if this is an actual bug.\n    // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n    return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  contains(cid) {\n    const cidStr = cid.toString(base58btc);\n    return this.set.has(cidStr);\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  get(cid) {\n    const cidStr = cid.toString(base58btc);\n    return this.set.get(cidStr);\n  }\n}\nWantlist.Entry = Entry;","map":{"version":3,"names":["WantListEntry","Entry","base58btc","Message","trackedMap","WantType","Block","Wantlist","Have","sortBy","fn","list","Array","prototype","slice","call","sort","a","b","aa","bb","constructor","stats","libp2p","set","name","metrics","Map","_stats","length","size","add","cid","priority","wantType","cidStr","toString","entry","get","inc","push","remove","dec","hasRefs","delete","removeForce","has","forEach","entries","sortedEntries","o","key","from","contains"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/wantlist/index.js"],"sourcesContent":["\nimport { WantListEntry as Entry } from './entry.js'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { Message } from '../message/message.js'\nimport { trackedMap } from '@libp2p/tracked-map'\n\nconst WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\n\n/**\n * @template T\n * @param {(v:T) => number} fn\n * @param {T[]} list\n * @returns {T[]}\n */\nconst sortBy = (fn, list) => {\n  return Array.prototype.slice.call(list, 0).sort((a, b) => {\n    const aa = fn(a)\n    const bb = fn(b)\n    return aa < bb ? -1 : aa > bb ? 1 : 0\n  })\n}\n\n/**\n * @typedef {import('multiformats').CID} CID\n */\n\nexport class Wantlist {\n  /**\n   * @param {import('../stats').Stats} [stats]\n   * @param {import('@libp2p/interface-libp2p').Libp2p} [libp2p]\n   */\n  constructor (stats, libp2p) {\n    /** @type {Map<string, Entry>} */\n    this.set = libp2p\n      ? trackedMap({\n        name: 'ipfs_bitswap_wantlist',\n        metrics: libp2p.metrics\n      })\n      : new Map()\n    this._stats = stats\n  }\n\n  get length () {\n    return this.set.size\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('../message/message').Message.Wantlist.WantType} wantType\n   */\n  add (cid, priority, wantType) {\n    const cidStr = cid.toString(base58btc)\n    const entry = this.set.get(cidStr)\n\n    if (entry) {\n      entry.inc()\n      entry.priority = priority\n\n      // We can only overwrite want-have with want-block\n      if (entry.wantType === WantType.Have && wantType === WantType.Block) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.set.set(cidStr, new Entry(cid, priority, wantType))\n      if (this._stats) {\n        this._stats.push(null, 'wantListSize', 1)\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  remove (cid) {\n    const cidStr = cid.toString(base58btc)\n    const entry = this.set.get(cidStr)\n\n    if (!entry) {\n      return\n    }\n\n    entry.dec()\n\n    // only delete when no refs are held\n    if (entry.hasRefs()) {\n      return\n    }\n\n    this.set.delete(cidStr)\n    if (this._stats) {\n      this._stats.push(null, 'wantListSize', -1)\n    }\n  }\n\n  /**\n   * @param {string} cidStr\n   */\n  removeForce (cidStr) {\n    if (this.set.has(cidStr)) {\n      this.set.delete(cidStr)\n    }\n  }\n\n  /**\n   * @param {(entry:Entry, key:string) => void} fn\n   */\n  forEach (fn) {\n    return this.set.forEach(fn)\n  }\n\n  entries () {\n    return this.set.entries()\n  }\n\n  sortedEntries () {\n    // TODO: Figure out if this is an actual bug.\n    // @ts-expect-error - Property 'key' does not exist on type 'WantListEntry'\n    return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())))\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  contains (cid) {\n    const cidStr = cid.toString(base58btc)\n    return this.set.has(cidStr)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  get (cid) {\n    const cidStr = cid.toString(base58btc)\n    return this.set.get(cidStr)\n  }\n}\n\nWantlist.Entry = Entry\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}