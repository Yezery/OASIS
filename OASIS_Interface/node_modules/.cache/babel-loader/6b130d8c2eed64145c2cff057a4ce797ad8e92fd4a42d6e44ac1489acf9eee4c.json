{"ast":null,"code":"import { importer } from 'ipfs-unixfs-importer';\nimport { normaliseInput } from 'ipfs-core-utils/files/normalise-input-multiple';\nimport { parseChunkerString } from './utils.js';\nimport { pipe } from 'it-pipe';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport mergeOpts from 'merge-options';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs-importer').ImportResult} ImportResult\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n */\n\n/**\n * @template T\n *\n * @typedef {import('it-stream-types').Source<T>} Source<T>\n */\n\n/**\n * @typedef {object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../../types').Preload} preload\n * @property {Multihashes} hashers\n * @property {import('ipfs-core-types/src/root').ShardingOptions} [options]\n * @param {Context} context\n */\nexport function createAddAll({\n  repo,\n  preload,\n  hashers,\n  options\n}) {\n  const isShardingEnabled = options && options.sharding;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"addAll\"]}\n   */\n  async function* addAll(source, options = {}) {\n    const opts = mergeOptions({\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      strategy: 'balanced'\n    }, options, {\n      ...parseChunkerString(options.chunker)\n    });\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n    if (opts.strategy === 'trickle') {\n      opts.leafType = 'raw';\n      opts.reduceSingleLeafToSelf = false;\n    }\n    if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n      // if the cid version is 1 or above, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true;\n    }\n    if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n      // if a non-default hash alg has been specified, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true;\n    }\n    delete opts.trickle;\n\n    /** @type {Record<string, number>} */\n    const totals = {};\n    if (opts.progress) {\n      const prog = opts.progress;\n\n      /**\n       * @param {number} bytes\n       * @param {string} path\n       */\n      opts.progress = (bytes, path) => {\n        if (!totals[path]) {\n          totals[path] = 0;\n        }\n        totals[path] += bytes;\n        prog(totals[path], path);\n      };\n    }\n\n    /** @type {MultihashHasher | undefined} */\n    let hasher;\n    if (opts.hashAlg != null) {\n      hasher = await hashers.getHasher(opts.hashAlg);\n    }\n    const iterator = pipe(normaliseInput(source),\n    /**\n     * @param {Source<import('ipfs-unixfs-importer').ImportCandidate>} source\n     */\n    source => importer(source, repo.blocks, {\n      ...opts,\n      hasher,\n      pin: false\n    }), transformFile(opts), preloadFile(preload, opts), pinFile(repo, opts));\n    const releaseLock = await repo.gcLock.readLock();\n    try {\n      for await (const added of iterator) {\n        const path = added.path ?? added.cid.toString();\n\n        // do not keep file totals around forever\n        delete totals[path];\n        yield {\n          ...added,\n          path\n        };\n      }\n    } finally {\n      releaseLock();\n    }\n  }\n  return withTimeoutOption(addAll);\n}\n\n/**\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction transformFile(opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function* transformFile(source) {\n    for await (const file of source) {\n      let cid = file.cid;\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n      let path = file.path ? file.path : cid.toString();\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n      yield {\n        path,\n        cid: cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      };\n    }\n  }\n  return transformFile;\n}\n\n/**\n * @param {(cid: CID) => void} preload\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction preloadFile(preload, opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function* maybePreloadFile(source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n      if (shouldPreload) {\n        preload(file.cid);\n      }\n      yield file;\n    }\n  }\n  return maybePreloadFile;\n}\n\n/**\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction pinFile(repo, opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function* maybePinFile(source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !(file.path && file.path.includes('/'));\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n      if (shouldPin) {\n        await repo.pins.pinRecursively(file.cid);\n      }\n      yield file;\n    }\n  }\n  return maybePinFile;\n}","map":{"version":3,"names":["importer","normaliseInput","parseChunkerString","pipe","withTimeoutOption","mergeOpts","mergeOptions","bind","ignoreUndefined","createAddAll","repo","preload","hashers","options","isShardingEnabled","sharding","addAll","source","opts","shardSplitThreshold","Infinity","strategy","chunker","hashAlg","cidVersion","trickle","leafType","reduceSingleLeafToSelf","rawLeaves","undefined","totals","progress","prog","bytes","path","hasher","getHasher","iterator","blocks","pin","transformFile","preloadFile","pinFile","releaseLock","gcLock","readLock","added","cid","toString","file","toV1","wrapWithDirectory","size","mode","unixfs","mtime","maybePreloadFile","isRootFile","includes","shouldPreload","onlyHash","maybePinFile","isRootDir","shouldPin","pins","pinRecursively"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/add-all/index.js"],"sourcesContent":["import { importer } from 'ipfs-unixfs-importer'\nimport { normaliseInput } from 'ipfs-core-utils/files/normalise-input-multiple'\nimport { parseChunkerString } from './utils.js'\nimport { pipe } from 'it-pipe'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport mergeOpts from 'merge-options'\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs-importer').ImportResult} ImportResult\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/multihashes').Multihashes} Multihashes\n */\n\n/**\n * @template T\n *\n * @typedef {import('it-stream-types').Source<T>} Source<T>\n */\n\n/**\n * @typedef {object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../../types').Preload} preload\n * @property {Multihashes} hashers\n * @property {import('ipfs-core-types/src/root').ShardingOptions} [options]\n * @param {Context} context\n */\nexport function createAddAll ({ repo, preload, hashers, options }) {\n  const isShardingEnabled = options && options.sharding\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    const opts = mergeOptions({\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      strategy: 'balanced'\n    }, options, {\n      ...parseChunkerString(options.chunker)\n    })\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle'\n    }\n\n    if (opts.strategy === 'trickle') {\n      opts.leafType = 'raw'\n      opts.reduceSingleLeafToSelf = false\n    }\n\n    if (opts.cidVersion > 0 && opts.rawLeaves === undefined) {\n      // if the cid version is 1 or above, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true\n    }\n\n    if (opts.hashAlg !== undefined && opts.rawLeaves === undefined) {\n      // if a non-default hash alg has been specified, use raw leaves as this is\n      // what go does.\n      opts.rawLeaves = true\n    }\n\n    delete opts.trickle\n\n    /** @type {Record<string, number>} */\n    const totals = {}\n\n    if (opts.progress) {\n      const prog = opts.progress\n\n      /**\n       * @param {number} bytes\n       * @param {string} path\n       */\n      opts.progress = (bytes, path) => {\n        if (!totals[path]) {\n          totals[path] = 0\n        }\n\n        totals[path] += bytes\n\n        prog(totals[path], path)\n      }\n    }\n\n    /** @type {MultihashHasher | undefined} */\n    let hasher\n\n    if (opts.hashAlg != null) {\n      hasher = await hashers.getHasher(opts.hashAlg)\n    }\n\n    const iterator = pipe(\n      normaliseInput(source),\n      /**\n       * @param {Source<import('ipfs-unixfs-importer').ImportCandidate>} source\n       */\n      source => importer(source, repo.blocks, {\n        ...opts,\n        hasher,\n        pin: false\n      }),\n      transformFile(opts),\n      preloadFile(preload, opts),\n      pinFile(repo, opts)\n    )\n\n    const releaseLock = await repo.gcLock.readLock()\n\n    try {\n      for await (const added of iterator) {\n        const path = added.path ?? added.cid.toString()\n\n        // do not keep file totals around forever\n        delete totals[path]\n\n        yield {\n          ...added,\n          path\n        }\n      }\n    } finally {\n      releaseLock()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n\n/**\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction transformFile (opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function * transformFile (source) {\n    for await (const file of source) {\n      let cid = file.cid\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      let path = file.path ? file.path : cid.toString()\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = ''\n      }\n\n      yield {\n        path,\n        cid: cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      }\n    }\n  }\n\n  return transformFile\n}\n\n/**\n * @param {(cid: CID) => void} preload\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction preloadFile (preload, opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function * maybePreloadFile (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory\n        ? file.path === ''\n        : !file.path.includes('/')\n\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n      if (shouldPreload) {\n        preload(file.cid)\n      }\n\n      yield file\n    }\n  }\n\n  return maybePreloadFile\n}\n\n/**\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-types/src/root').AddAllOptions} opts\n */\nfunction pinFile (repo, opts) {\n  /**\n   * @param {Source<ImportResult>} source\n   */\n  async function * maybePinFile (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !(file.path && file.path.includes('/'))\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash\n\n      if (shouldPin) {\n        await repo.pins.pinRecursively(file.cid)\n      }\n\n      yield file\n    }\n  }\n\n  return maybePinFile\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}