{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Key } from 'interface-datastore/key';\nimport PQueue from 'p-queue';\nimport _get from 'just-safe-get';\nimport _set from 'just-safe-set';\nimport errCode from 'err-code';\nimport { NotFoundError } from './errors.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { getWithFallback, hasWithFallback } from './utils/level.js';\n\n// @ts-ignore types are broken in p-queue@6.x.x - also, if we imported via esm\n// we can use the default, if via cjs we need to get the default via prop access\nconst Queue = PQueue.default ? PQueue.default : PQueue;\nconst configKey = new Key('config');\n\n/**\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {Datastore} store\n */\nexport function config(store) {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll(options = {}) {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);\n      return JSON.parse(uint8ArrayToString(encodedValue));\n    },\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get(key, options = {}) {\n      if (key == null) {\n        throw new NotFoundError(`Key ${key} does not exist in config`);\n      }\n      const config = await this.getAll(options);\n      const value = _get(config, key);\n      if (value === undefined) {\n        throw new NotFoundError(`Key ${key} does not exist in config`);\n      }\n      return value;\n    },\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set(key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace(value, options = {}) {\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migration to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store);\n    }\n  };\n  return configStore;\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n    const key = m.key;\n    const value = m.value;\n    if (key) {\n      const config = await configStore.getAll();\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value);\n      }\n      return _saveAll(config);\n    }\n    return _saveAll(value);\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n}","map":{"version":3,"names":["Key","PQueue","_get","_set","errCode","NotFoundError","toString","uint8ArrayToString","fromString","uint8ArrayFromString","getWithFallback","hasWithFallback","Queue","default","configKey","config","store","setQueue","concurrency","configStore","getAll","options","encodedValue","get","bind","has","JSON","parse","key","value","undefined","set","String","Error","Uint8Array","add","_maybeDoSet","signal","replace","exists","m","aborted","_saveAll","buf","stringify","put"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/config.js"],"sourcesContent":["\nimport { Key } from 'interface-datastore/key'\nimport PQueue from 'p-queue'\nimport _get from 'just-safe-get'\nimport _set from 'just-safe-set'\nimport errCode from 'err-code'\nimport { NotFoundError } from './errors.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { getWithFallback, hasWithFallback } from './utils/level.js'\n\n// @ts-ignore types are broken in p-queue@6.x.x - also, if we imported via esm\n// we can use the default, if via cjs we need to get the default via prop access\nconst Queue = PQueue.default ? PQueue.default : PQueue\n\nconst configKey = new Key('config')\n\n/**\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {Datastore} store\n */\nexport function config (store) {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store)\n\n      return JSON.parse(uint8ArrayToString(encodedValue))\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get (key, options = {}) {\n      if (key == null) {\n        throw new NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const config = await this.getAll(options)\n      const value = _get(config, key)\n\n      if (value === undefined) {\n        throw new NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set (key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace (value, options = {}) {\n      if (!value || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists () { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migration to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store)\n    }\n  }\n\n  return configStore\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.getAll()\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value)\n      }\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"],"mappings":";;;AACA,SAASA,GAAG,QAAQ,yBAAyB;AAC7C,OAAOC,MAAM,MAAM,SAAS;AAC5B,OAAOC,IAAI,MAAM,eAAe;AAChC,OAAOC,IAAI,MAAM,eAAe;AAChC,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,aAAa,QAAQ,aAAa;AAC3C,SAASC,QAAQ,IAAIC,kBAAkB,QAAQ,uBAAuB;AACtE,SAASC,UAAU,IAAIC,oBAAoB,QAAQ,yBAAyB;AAC5E,SAASC,eAAe,EAAEC,eAAe,QAAQ,kBAAkB;;AAEnE;AACA;AACA,MAAMC,KAAK,GAAGX,MAAM,CAACY,OAAO,GAAGZ,MAAM,CAACY,OAAO,GAAGZ,MAAM;AAEtD,MAAMa,SAAS,GAAG,IAAId,GAAG,CAAC,QAAQ,CAAC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAASe,MAAMA,CAAEC,KAAK,EAAE;EAC7B,MAAMC,QAAQ,GAAG,IAAIL,KAAK,CAAC;IAAEM,WAAW,EAAE;EAAE,CAAC,CAAC;EAE9C,MAAMC,WAAW,GAAG;IAClB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,MAAMC,MAAMA,CAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;MAAE;MAC5B;MACA;MACA;MACA,MAAMC,YAAY,GAAG,MAAMZ,eAAe,CAACI,SAAS,EAAEE,KAAK,CAACO,GAAG,CAACC,IAAI,CAACR,KAAK,CAAC,EAAEA,KAAK,CAACS,GAAG,CAACD,IAAI,CAACR,KAAK,CAAC,EAAEA,KAAK,CAAC;MAE1G,OAAOU,IAAI,CAACC,KAAK,CAACpB,kBAAkB,CAACe,YAAY,CAAC,CAAC;IACrD,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,MAAMC,GAAGA,CAAEK,GAAG,EAAEP,OAAO,GAAG,CAAC,CAAC,EAAE;MAC5B,IAAIO,GAAG,IAAI,IAAI,EAAE;QACf,MAAM,IAAIvB,aAAa,CAAE,OAAMuB,GAAI,2BAA0B,CAAC;MAChE;MAEA,MAAMb,MAAM,GAAG,MAAM,IAAI,CAACK,MAAM,CAACC,OAAO,CAAC;MACzC,MAAMQ,KAAK,GAAG3B,IAAI,CAACa,MAAM,EAAEa,GAAG,CAAC;MAE/B,IAAIC,KAAK,KAAKC,SAAS,EAAE;QACvB,MAAM,IAAIzB,aAAa,CAAE,OAAMuB,GAAI,2BAA0B,CAAC;MAChE;MAEA,OAAOC,KAAK;IACd,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIE,GAAGA,CAAEH,GAAG,EAAEC,KAAK,EAAER,OAAO,GAAG,CAAC,CAAC,EAAE;MAC7B;MACA,IAAI,OAAOO,GAAG,KAAK,QAAQ,IAAI,EAAEA,GAAG,YAAYI,MAAM,CAAC,EAAE;QACvD,MAAM5B,OAAO,CAAC,IAAI6B,KAAK,CAAC,oBAAoB,GAAG,OAAOL,GAAG,CAAC,EAAE,iBAAiB,CAAC;MAChF;MAEA,IAAIC,KAAK,KAAKC,SAAS,IAAKD,KAAK,YAAYK,UAAW,EAAE;QACxD,MAAM9B,OAAO,CAAC,IAAI6B,KAAK,CAAC,sBAAsB,GAAG,OAAOJ,KAAK,CAAC,EAAE,mBAAmB,CAAC;MACtF;MAEA,OAAOZ,QAAQ,CAACkB,GAAG,CAAC,MAAMC,WAAW,CAAC;QACpCR,GAAG,EAAEA,GAAG;QACRC,KAAK,EAAEA;MACT,CAAC,EAAER,OAAO,CAACgB,MAAM,CAAC,CAAC;IACrB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,OAAOA,CAAET,KAAK,EAAER,OAAO,GAAG,CAAC,CAAC,EAAE;MAC5B,IAAI,CAACQ,KAAK,IAAKA,KAAK,YAAYK,UAAW,EAAE;QAC3C,MAAM9B,OAAO,CAAC,IAAI6B,KAAK,CAAC,sBAAsB,GAAG,OAAOJ,KAAK,CAAC,EAAE,mBAAmB,CAAC;MACtF;MAEA,OAAOZ,QAAQ,CAACkB,GAAG,CAAC,MAAMC,WAAW,CAAC;QACpCR,GAAG,EAAEE,SAAS;QACdD,KAAK,EAAEA;MACT,CAAC,EAAER,OAAO,CAACgB,MAAM,CAAC,CAAC;IACrB,CAAC;IAED;AACJ;AACA;AACA;IACI,MAAME,MAAMA,CAAA,EAAI;MAAE;MAChB;MACA;MACA;MACA,OAAO5B,eAAe,CAACG,SAAS,EAAEE,KAAK,CAACS,GAAG,CAACD,IAAI,CAACR,KAAK,CAAC,EAAEA,KAAK,CAAC;IACjE;EACF,CAAC;EAED,OAAOG,WAAW;;EAElB;AACF;AACA;AACA;EACE,eAAeiB,WAAWA,CAAEI,CAAC,EAAEH,MAAM,EAAE;IACrC,IAAIA,MAAM,IAAIA,MAAM,CAACI,OAAO,EAAE;MAC5B;IACF;IAEA,MAAMb,GAAG,GAAGY,CAAC,CAACZ,GAAG;IACjB,MAAMC,KAAK,GAAGW,CAAC,CAACX,KAAK;IACrB,IAAID,GAAG,EAAE;MACP,MAAMb,MAAM,GAAG,MAAMI,WAAW,CAACC,MAAM,CAAC,CAAC;MACzC,IAAI,OAAOL,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;QACjDZ,IAAI,CAACY,MAAM,EAAEa,GAAG,EAAEC,KAAK,CAAC;MAC1B;MACA,OAAOa,QAAQ,CAAC3B,MAAM,CAAC;IACzB;IACA,OAAO2B,QAAQ,CAACb,KAAK,CAAC;EACxB;;EAEA;AACF;AACA;EACE,SAASa,QAAQA,CAAE3B,MAAM,EAAE;IACzB,MAAM4B,GAAG,GAAGlC,oBAAoB,CAACiB,IAAI,CAACkB,SAAS,CAAC7B,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IACjE,OAAOC,KAAK,CAAC6B,GAAG,CAAC/B,SAAS,EAAE6B,GAAG,CAAC;EAClC;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}