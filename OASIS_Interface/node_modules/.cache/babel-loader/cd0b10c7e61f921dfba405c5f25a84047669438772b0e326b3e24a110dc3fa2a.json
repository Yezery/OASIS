{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n    this.tableName = opts.tableName;\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createTable().then(() => {\n        this.tableCreated = true;\n        if (this.clearExpiredByTimeout) {\n          this._clearExpiredHourAgo();\n        }\n        if (typeof cb === 'function') {\n          cb();\n        }\n      }).catch(err => {\n        if (typeof cb === 'function') {\n          cb(err);\n        } else {\n          throw err;\n        }\n      });\n    } else {\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n  clearExpired(expire) {\n    return new Promise(resolve => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,\n        values: [expire]\n      };\n      this._query(q).then(() => {\n        resolve();\n      }).catch(() => {\n        // Deleting expired query is not critical\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n      .then(() => {\n        this._clearExpiredHourAgo();\n      });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      case 'typeorm':\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt()\n      }).then(() => {\n        resolve();\n      }).catch(err => {\n        if (err.code === '23505') {\n          // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n          // Postgres doesn't handle concurrent table creation\n          // It is supposed, that table is created by another worker\n          resolve();\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( \n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n  get clientType() {\n    return this._clientType;\n  }\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (constructorName === 'Pool' || constructorName === 'BoundPool') {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n    this._clientType = value.toLowerCase();\n  }\n  get tableName() {\n    return this._tableName;\n  }\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n  get tableCreated() {\n    return this._tableCreated;\n  }\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire ? Math.max(row.expire - Date.now(), 0) : -1;\n    return res;\n  }\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = {\n      name: `${prefix}:${q.name}`,\n      text: q.text,\n      values: q.values\n    };\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(conn => {\n        conn.query(queryObj).then(res => {\n          resolve(res);\n          this._releaseConnection(conn);\n        }).catch(err => {\n          reject(err);\n          this._releaseConnection(conn);\n        });\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire ? ' $3 ' : ` CASE\n             WHEN ${this.tableName}.expire <= $4 THEN $3\n             ELSE ${this.tableName}.expire\n            END `;\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this.tableName}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()]\n    });\n  }\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()]\n      }).then(res => {\n        if (res.rowCount === 0) {\n          res = null;\n        }\n        resolve(res);\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  }\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this.tableName} WHERE key = $1`,\n      values: [rlKey]\n    }).then(res => res.rowCount > 0);\n  }\n}\nmodule.exports = RateLimiterPostgres;","map":{"version":3,"names":["RateLimiterStoreAbstract","require","RateLimiterRes","RateLimiterPostgres","constructor","opts","cb","client","storeClient","clientType","storeType","tableName","clearExpiredByTimeout","tableCreated","_createTable","then","_clearExpiredHourAgo","catch","err","clearExpired","expire","Promise","resolve","q","name","text","values","_query","_clearExpiredTimeoutId","clearTimeout","setTimeout","Date","now","unref","_getConnection","connectionManager","getConnection","acquireConnection","driver","master","_releaseConnection","conn","releaseConnection","reject","_getCreateTableStmt","code","_clientType","value","constructorName","Error","toLowerCase","_tableName","keyPrefix","_tableCreated","_clearExpiredByTimeout","Boolean","_getRateLimiterRes","rlKey","changedPoints","result","res","row","rows","isFirstInDuration","points","consumedPoints","remainingPoints","Math","max","msBeforeNext","prefix","queryObj","query","_upsert","key","msDuration","forceExpire","newExpire","expireQ","_get","rowCount","_delete","module","exports"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterPostgres.js"],"sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterPostgres extends RateLimiterStoreAbstract {\n  /**\n   * @callback callback\n   * @param {Object} err\n   *\n   * @param {Object} opts\n   * @param {callback} cb\n   * Defaults {\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   storeClient: postgresClient,\n   *   storeType: 'knex', // required only for Knex instance\n   *   tableName: 'string',\n   * }\n   */\n  constructor(opts, cb = null) {\n    super(opts);\n\n    this.client = opts.storeClient;\n    this.clientType = opts.storeType;\n\n    this.tableName = opts.tableName;\n\n    this.clearExpiredByTimeout = opts.clearExpiredByTimeout;\n\n    this.tableCreated = opts.tableCreated;\n    if (!this.tableCreated) {\n      this._createTable()\n        .then(() => {\n          this.tableCreated = true;\n          if (this.clearExpiredByTimeout) {\n            this._clearExpiredHourAgo();\n          }\n          if (typeof cb === 'function') {\n            cb();\n          }\n        })\n        .catch((err) => {\n          if (typeof cb === 'function') {\n            cb(err);\n          } else {\n            throw err;\n          }\n        });\n    } else {\n      if (typeof cb === 'function') {\n        cb();\n      }\n    }\n  }\n\n  clearExpired(expire) {\n    return new Promise((resolve) => {\n      const q = {\n        name: 'rlflx-clear-expired',\n        text: `DELETE FROM ${this.tableName} WHERE expire < $1`,\n        values: [expire],\n      };\n      this._query(q)\n        .then(() => {\n          resolve();\n        })\n        .catch(() => {\n          // Deleting expired query is not critical\n          resolve();\n        });\n    });\n  }\n\n  /**\n   * Delete all rows expired 1 hour ago once per 5 minutes\n   *\n   * @private\n   */\n  _clearExpiredHourAgo() {\n    if (this._clearExpiredTimeoutId) {\n      clearTimeout(this._clearExpiredTimeoutId);\n    }\n    this._clearExpiredTimeoutId = setTimeout(() => {\n      this.clearExpired(Date.now() - 3600000) // Never rejected\n        .then(() => {\n          this._clearExpiredHourAgo();\n        });\n    }, 300000);\n    this._clearExpiredTimeoutId.unref();\n  }\n\n  /**\n   *\n   * @return Promise<any>\n   * @private\n   */\n  _getConnection() {\n    switch (this.clientType) {\n      case 'pool':\n        return Promise.resolve(this.client);\n      case 'sequelize':\n        return this.client.connectionManager.getConnection();\n      case 'knex':\n        return this.client.client.acquireConnection();\n      case 'typeorm':\n        return Promise.resolve(this.client.driver.master);\n      default:\n        return Promise.resolve(this.client);\n    }\n  }\n\n  _releaseConnection(conn) {\n    switch (this.clientType) {\n      case 'pool':\n        return true;\n      case 'sequelize':\n        return this.client.connectionManager.releaseConnection(conn);\n      case 'knex':\n        return this.client.client.releaseConnection(conn);\n      case 'typeorm':\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @private\n   */\n  _createTable() {\n    return new Promise((resolve, reject) => {\n      this._query({\n        text: this._getCreateTableStmt(),\n      })\n        .then(() => {\n          resolve();\n        })\n        .catch((err) => {\n          if (err.code === '23505') {\n            // Error: duplicate key value violates unique constraint \"pg_type_typname_nsp_index\"\n            // Postgres doesn't handle concurrent table creation\n            // It is supposed, that table is created by another worker\n            resolve();\n          } else {\n            reject(err);\n          }\n        });\n    });\n  }\n\n  _getCreateTableStmt() {\n    return `CREATE TABLE IF NOT EXISTS ${this.tableName} ( \n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`;\n  }\n\n  get clientType() {\n    return this._clientType;\n  }\n\n  set clientType(value) {\n    const constructorName = this.client.constructor.name;\n\n    if (typeof value === 'undefined') {\n      if (constructorName === 'Client') {\n        value = 'client';\n      } else if (\n        constructorName === 'Pool' ||\n        constructorName === 'BoundPool'\n      ) {\n        value = 'pool';\n      } else if (constructorName === 'Sequelize') {\n        value = 'sequelize';\n      } else {\n        throw new Error('storeType is not defined');\n      }\n    }\n\n    this._clientType = value.toLowerCase();\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get tableCreated() {\n    return this._tableCreated\n  }\n\n  set tableCreated(value) {\n    this._tableCreated = typeof value === 'undefined' ? false : !!value;\n  }\n\n  get clearExpiredByTimeout() {\n    return this._clearExpiredByTimeout;\n  }\n\n  set clearExpiredByTimeout(value) {\n    this._clearExpiredByTimeout = typeof value === 'undefined' ? true : Boolean(value);\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    const row = result.rows[0];\n\n    res.isFirstInDuration = changedPoints === row.points;\n    res.consumedPoints = res.isFirstInDuration ? changedPoints : row.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = row.expire\n      ? Math.max(row.expire - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _query(q) {\n    const prefix = this.tableName.toLowerCase();\n    const queryObj = { name: `${prefix}:${q.name}`, text: q.text, values: q.values };\n    return new Promise((resolve, reject) => {\n      this._getConnection()\n        .then((conn) => {\n          conn.query(queryObj)\n            .then((res) => {\n              resolve(res);\n              this._releaseConnection(conn);\n            })\n            .catch((err) => {\n              reject(err);\n              this._releaseConnection(conn);\n            });\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    const newExpire = msDuration > 0 ? Date.now() + msDuration : null;\n    const expireQ = forceExpire\n      ? ' $3 '\n      : ` CASE\n             WHEN ${this.tableName}.expire <= $4 THEN $3\n             ELSE ${this.tableName}.expire\n            END `;\n\n    return this._query({\n      name: forceExpire ? 'rlflx-upsert-force' : 'rlflx-upsert',\n      text: `\n            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this.tableName}.expire <= $4 OR 1=${forceExpire ? 1 : 0}) THEN $2\n                          ELSE ${this.tableName}.points + ($2)\n                         END,\n                expire = ${expireQ}\n            RETURNING points, expire;`,\n      values: [key, points, newExpire, Date.now()],\n    });\n  }\n\n  _get(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return new Promise((resolve, reject) => {\n      this._query({\n        name: 'rlflx-get',\n        text: `\n            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,\n        values: [rlKey, Date.now()],\n      })\n        .then((res) => {\n          if (res.rowCount === 0) {\n            res = null;\n          }\n          resolve(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  _delete(rlKey) {\n    if (!this.tableCreated) {\n      return Promise.reject(Error('Table is not created yet'));\n    }\n\n    return this._query({\n      name: 'rlflx-delete',\n      text: `DELETE FROM ${this.tableName} WHERE key = $1`,\n      values: [rlKey],\n    })\n      .then(res => res.rowCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterPostgres;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}