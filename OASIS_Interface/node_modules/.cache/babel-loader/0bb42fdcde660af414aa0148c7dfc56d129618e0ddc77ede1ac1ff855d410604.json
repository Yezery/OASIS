{"ast":null,"code":"import { connect } from 'it-ws/client';\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri';\nimport { AbortError } from '@libp2p/interfaces/errors';\nimport pDefer from 'p-defer';\nimport { logger } from '@libp2p/logger';\nimport { isBrowser, isWebWorker } from 'wherearewe';\nimport { createListener } from './listener.js';\nimport { socketToMaConn } from './socket-to-conn.js';\nimport * as filters from './filters.js';\nimport { symbol } from '@libp2p/interface-transport';\nconst log = logger('libp2p:websockets');\nclass WebSockets {\n  constructor(init) {\n    this.init = init;\n  }\n  get [Symbol.toStringTag]() {\n    return '@libp2p/websockets';\n  }\n  get [symbol]() {\n    return true;\n  }\n  async dial(ma, options) {\n    log('dialing %s', ma);\n    options = options ?? {};\n    const socket = await this._connect(ma, options);\n    const maConn = socketToMaConn(socket, ma);\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await options.upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n  async _connect(ma, options) {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError();\n    }\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const errorPromise = pDefer();\n    const errfn = err => {\n      log.error('connection error:', err);\n      errorPromise.reject(err);\n    };\n    const rawSocket = connect(toUri(ma), this.init);\n    if (rawSocket.socket.on != null) {\n      rawSocket.socket.on('error', errfn);\n    } else {\n      rawSocket.socket.onerror = errfn;\n    }\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise]);\n      log('connected %s', ma);\n      return rawSocket;\n    }\n    // Allow abort via signal during connect\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError());\n        rawSocket.close().catch(err => {\n          log.error('error closing raw socket', err);\n        });\n      };\n      // Already aborted?\n      if (options?.signal?.aborted === true) {\n        onAbort();\n        return;\n      }\n      options?.signal?.addEventListener('abort', onAbort);\n    });\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort);\n      }\n    }\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener(options) {\n    return createListener({\n      ...this.init,\n      ...options\n    });\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs);\n    }\n    // Browser\n    if (isBrowser || isWebWorker) {\n      return filters.wss(multiaddrs);\n    }\n    return filters.all(multiaddrs);\n  }\n}\nexport function webSockets(init = {}) {\n  return () => {\n    return new WebSockets(init);\n  };\n}","map":{"version":3,"names":["connect","multiaddrToUri","toUri","AbortError","pDefer","logger","isBrowser","isWebWorker","createListener","socketToMaConn","filters","symbol","log","WebSockets","constructor","init","Symbol","toStringTag","dial","ma","options","socket","_connect","maConn","remoteAddr","conn","upgrader","upgradeOutbound","signal","aborted","cOpts","toOptions","host","port","errorPromise","errfn","err","error","reject","rawSocket","on","onerror","Promise","race","connected","promise","onAbort","abort","resolve","close","catch","addEventListener","removeEventListener","filter","multiaddrs","Array","isArray","wss","all","webSockets"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}