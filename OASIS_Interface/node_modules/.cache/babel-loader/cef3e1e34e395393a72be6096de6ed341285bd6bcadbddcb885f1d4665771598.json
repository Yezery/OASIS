{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @template {any} T\n * @typedef {import('./coding').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop() {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create() {\n  /** @type {T[]} */\n  const chunkQueue = [];\n  /** @type {Promise<void> | null} */\n  let drainer = null;\n  let drainerResolver = noop;\n  let ended = false;\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null;\n  let outWaitResolver = noop;\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise(resolve => {\n        drainerResolver = () => {\n          drainer = null;\n          drainerResolver = noop;\n          resolve();\n        };\n      });\n    }\n    return drainer;\n  };\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write(chunk) {\n      chunkQueue.push(chunk);\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    },\n    async end() {\n      ended = true;\n      const drainer = makeDrainer();\n      outWaitResolver();\n      await drainer;\n    }\n  };\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next() {\n      const chunk = chunkQueue.shift();\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver();\n        }\n        return {\n          done: false,\n          value: chunk\n        };\n      }\n      if (ended) {\n        drainerResolver();\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n      if (!outWait) {\n        outWait = new Promise(resolve => {\n          outWaitResolver = () => {\n            outWait = null;\n            outWaitResolver = noop;\n            return resolve(iterator.next());\n          };\n        });\n      }\n      return outWait;\n    }\n  };\n  return {\n    writer,\n    iterator\n  };\n}","map":{"version":3,"names":["noop","create","chunkQueue","drainer","drainerResolver","ended","outWait","outWaitResolver","makeDrainer","Promise","resolve","writer","write","chunk","push","end","iterator","next","shift","length","done","value","undefined"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/@ipld+car@5.2.3/node_modules/@ipld/car/src/iterator-channel.js"],"sourcesContent":["/**\n * @template {any} T\n * @typedef {import('./coding').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop () {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create () {\n  /** @type {T[]} */\n  const chunkQueue = []\n  /** @type {Promise<void> | null} */\n  let drainer = null\n  let drainerResolver = noop\n  let ended = false\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null\n  let outWaitResolver = noop\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise((resolve) => {\n        drainerResolver = () => {\n          drainer = null\n          drainerResolver = noop\n          resolve()\n        }\n      })\n    }\n    return drainer\n  }\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write (chunk) {\n      chunkQueue.push(chunk)\n      const drainer = makeDrainer()\n      outWaitResolver()\n      return drainer\n    },\n\n    async end () {\n      ended = true\n      const drainer = makeDrainer()\n      outWaitResolver()\n      await drainer\n    }\n  }\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next () {\n      const chunk = chunkQueue.shift()\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver()\n        }\n        return { done: false, value: chunk }\n      }\n\n      if (ended) {\n        drainerResolver()\n        return { done: true, value: undefined }\n      }\n\n      if (!outWait) {\n        outWait = new Promise((resolve) => {\n          outWaitResolver = () => {\n            outWait = null\n            outWaitResolver = noop\n            return resolve(iterator.next())\n          }\n        })\n      }\n\n      return outWait\n    }\n  }\n\n  return { writer, iterator }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;;AAEA,SAASA,IAAIA,CAAA,EAAI,CAAC;;AAElB;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAAA,EAAI;EACxB;EACA,MAAMC,UAAU,GAAG,EAAE;EACrB;EACA,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,eAAe,GAAGJ,IAAI;EAC1B,IAAIK,KAAK,GAAG,KAAK;EACjB;EACA,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,eAAe,GAAGP,IAAI;EAE1B,MAAMQ,WAAW,GAAGA,CAAA,KAAM;IACxB,IAAI,CAACL,OAAO,EAAE;MACZA,OAAO,GAAG,IAAIM,OAAO,CAAEC,OAAO,IAAK;QACjCN,eAAe,GAAGA,CAAA,KAAM;UACtBD,OAAO,GAAG,IAAI;UACdC,eAAe,GAAGJ,IAAI;UACtBU,OAAO,CAAC,CAAC;QACX,CAAC;MACH,CAAC,CAAC;IACJ;IACA,OAAOP,OAAO;EAChB,CAAC;;EAED;AACF;AACA;EACE,MAAMQ,MAAM,GAAG;IACb;AACJ;AACA;AACA;IACIC,KAAKA,CAAEC,KAAK,EAAE;MACZX,UAAU,CAACY,IAAI,CAACD,KAAK,CAAC;MACtB,MAAMV,OAAO,GAAGK,WAAW,CAAC,CAAC;MAC7BD,eAAe,CAAC,CAAC;MACjB,OAAOJ,OAAO;IAChB,CAAC;IAED,MAAMY,GAAGA,CAAA,EAAI;MACXV,KAAK,GAAG,IAAI;MACZ,MAAMF,OAAO,GAAGK,WAAW,CAAC,CAAC;MAC7BD,eAAe,CAAC,CAAC;MACjB,MAAMJ,OAAO;IACf;EACF,CAAC;;EAED;EACA,MAAMa,QAAQ,GAAG;IACf;IACA,MAAMC,IAAIA,CAAA,EAAI;MACZ,MAAMJ,KAAK,GAAGX,UAAU,CAACgB,KAAK,CAAC,CAAC;MAChC,IAAIL,KAAK,EAAE;QACT,IAAIX,UAAU,CAACiB,MAAM,KAAK,CAAC,EAAE;UAC3Bf,eAAe,CAAC,CAAC;QACnB;QACA,OAAO;UAAEgB,IAAI,EAAE,KAAK;UAAEC,KAAK,EAAER;QAAM,CAAC;MACtC;MAEA,IAAIR,KAAK,EAAE;QACTD,eAAe,CAAC,CAAC;QACjB,OAAO;UAAEgB,IAAI,EAAE,IAAI;UAAEC,KAAK,EAAEC;QAAU,CAAC;MACzC;MAEA,IAAI,CAAChB,OAAO,EAAE;QACZA,OAAO,GAAG,IAAIG,OAAO,CAAEC,OAAO,IAAK;UACjCH,eAAe,GAAGA,CAAA,KAAM;YACtBD,OAAO,GAAG,IAAI;YACdC,eAAe,GAAGP,IAAI;YACtB,OAAOU,OAAO,CAACM,QAAQ,CAACC,IAAI,CAAC,CAAC,CAAC;UACjC,CAAC;QACH,CAAC,CAAC;MACJ;MAEA,OAAOX,OAAO;IAChB;EACF,CAAC;EAED,OAAO;IAAEK,MAAM;IAAEK;EAAS,CAAC;AAC7B"},"metadata":{},"sourceType":"module","externalDependencies":[]}