{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  supports\n} = require('level-supports');\nconst {\n  Transcoder\n} = require('level-transcoder');\nconst {\n  EventEmitter\n} = require('events');\nconst {\n  fromCallback\n} = require('catering');\nconst ModuleError = require('module-error');\nconst {\n  AbstractIterator\n} = require('./abstract-iterator');\nconst {\n  DefaultKeyIterator,\n  DefaultValueIterator\n} = require('./lib/default-kv-iterator');\nconst {\n  DeferredIterator,\n  DeferredKeyIterator,\n  DeferredValueIterator\n} = require('./lib/deferred-iterator');\nconst {\n  DefaultChainedBatch\n} = require('./lib/default-chained-batch');\nconst {\n  getCallback,\n  getOptions\n} = require('./lib/common');\nconst rangeOptions = require('./lib/range-options');\nconst kPromise = Symbol('promise');\nconst kLanded = Symbol('landed');\nconst kResources = Symbol('resources');\nconst kCloseResources = Symbol('closeResources');\nconst kOperations = Symbol('operations');\nconst kUndefer = Symbol('undefer');\nconst kDeferOpen = Symbol('deferOpen');\nconst kOptions = Symbol('options');\nconst kStatus = Symbol('status');\nconst kDefaultOptions = Symbol('defaultOptions');\nconst kTranscoder = Symbol('transcoder');\nconst kKeyEncoding = Symbol('keyEncoding');\nconst kValueEncoding = Symbol('valueEncoding');\nconst noop = () => {};\nclass AbstractLevel extends EventEmitter {\n  constructor(manifest, options) {\n    super();\n    if (typeof manifest !== 'object' || manifest === null) {\n      throw new TypeError(\"The first argument 'manifest' must be an object\");\n    }\n    options = getOptions(options);\n    const {\n      keyEncoding,\n      valueEncoding,\n      passive,\n      ...forward\n    } = options;\n    this[kResources] = new Set();\n    this[kOperations] = [];\n    this[kDeferOpen] = true;\n    this[kOptions] = forward;\n    this[kStatus] = 'opening';\n    this.supports = supports(manifest, {\n      status: true,\n      promises: true,\n      clear: true,\n      getMany: true,\n      deferredOpen: true,\n      // TODO (next major): add seek\n      snapshots: manifest.snapshots !== false,\n      permanence: manifest.permanence !== false,\n      // TODO: remove from level-supports because it's always supported\n      keyIterator: true,\n      valueIterator: true,\n      iteratorNextv: true,\n      iteratorAll: true,\n      encodings: manifest.encodings || {},\n      events: Object.assign({}, manifest.events, {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: true,\n        clear: true\n      })\n    });\n    this[kTranscoder] = new Transcoder(formats(this));\n    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8');\n    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8');\n\n    // Add custom and transcoder encodings to manifest\n    for (const encoding of this[kTranscoder].encodings()) {\n      if (!this.supports.encodings[encoding.commonName]) {\n        this.supports.encodings[encoding.commonName] = true;\n      }\n    }\n    this[kDefaultOptions] = {\n      empty: Object.freeze({}),\n      entry: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName,\n        valueEncoding: this[kValueEncoding].commonName\n      }),\n      key: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName\n      })\n    };\n\n    // Let subclass finish its constructor\n    this.nextTick(() => {\n      if (this[kDeferOpen]) {\n        this.open({\n          passive: false\n        }, noop);\n      }\n    });\n  }\n  get status() {\n    return this[kStatus];\n  }\n  keyEncoding(encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);\n  }\n  valueEncoding(encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);\n  }\n  open(options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = {\n      ...this[kOptions],\n      ...getOptions(options)\n    };\n    options.createIfMissing = options.createIfMissing !== false;\n    options.errorIfExists = !!options.errorIfExists;\n    const maybeOpened = err => {\n      if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);\n      } else if (this[kStatus] !== 'open') {\n        callback(new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN',\n          cause: err\n        }));\n      } else {\n        callback();\n      }\n    };\n    if (options.passive) {\n      if (this[kStatus] === 'opening') {\n        this.once(kLanded, maybeOpened);\n      } else {\n        this.nextTick(maybeOpened);\n      }\n    } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {\n      this[kDeferOpen] = false;\n      this[kStatus] = 'opening';\n      this.emit('opening');\n      this._open(options, err => {\n        if (err) {\n          this[kStatus] = 'closed';\n\n          // Resources must be safe to close in any db state\n          this[kCloseResources](() => {\n            this.emit(kLanded);\n            maybeOpened(err);\n          });\n          this[kUndefer]();\n          return;\n        }\n        this[kStatus] = 'open';\n        this[kUndefer]();\n        this.emit(kLanded);\n\n        // Only emit public event if pending state changes are done\n        if (this[kStatus] === 'open') this.emit('open');\n\n        // TODO (next major): remove this alias\n        if (this[kStatus] === 'open') this.emit('ready');\n        maybeOpened();\n      });\n    } else if (this[kStatus] === 'open') {\n      this.nextTick(maybeOpened);\n    } else {\n      this.once(kLanded, () => this.open(options, callback));\n    }\n    return callback[kPromise];\n  }\n  _open(options, callback) {\n    this.nextTick(callback);\n  }\n  close(callback) {\n    callback = fromCallback(callback, kPromise);\n    const maybeClosed = err => {\n      if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? maybeClosed(err) : maybeClosed);\n      } else if (this[kStatus] !== 'closed') {\n        callback(new ModuleError('Database is not closed', {\n          code: 'LEVEL_DATABASE_NOT_CLOSED',\n          cause: err\n        }));\n      } else {\n        callback();\n      }\n    };\n    if (this[kStatus] === 'open') {\n      this[kStatus] = 'closing';\n      this.emit('closing');\n      const cancel = err => {\n        this[kStatus] = 'open';\n        this[kUndefer]();\n        this.emit(kLanded);\n        maybeClosed(err);\n      };\n      this[kCloseResources](() => {\n        this._close(err => {\n          if (err) return cancel(err);\n          this[kStatus] = 'closed';\n          this[kUndefer]();\n          this.emit(kLanded);\n\n          // Only emit public event if pending state changes are done\n          if (this[kStatus] === 'closed') this.emit('closed');\n          maybeClosed();\n        });\n      });\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(maybeClosed);\n    } else {\n      this.once(kLanded, () => this.close(callback));\n    }\n    return callback[kPromise];\n  }\n  [kCloseResources](callback) {\n    if (this[kResources].size === 0) {\n      return this.nextTick(callback);\n    }\n    let pending = this[kResources].size;\n    let sync = true;\n    const next = () => {\n      if (--pending === 0) {\n        // We don't have tests for generic resources, so dezalgo\n        if (sync) this.nextTick(callback);else callback();\n      }\n    };\n\n    // In parallel so that all resources know they are closed\n    for (const resource of this[kResources]) {\n      resource.close(next);\n    }\n    sync = false;\n    this[kResources].clear();\n  }\n  _close(callback) {\n    this.nextTick(callback);\n  }\n  get(key, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.get(key, options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    const err = this._checkKey(key);\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format;\n\n    // Forward encoding options to the underlying store\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {\n      if (err) {\n        // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)\n        if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {\n          if (!err.code) err.code = 'LEVEL_NOT_FOUND'; // Preferred way going forward\n          if (!err.notFound) err.notFound = true; // Same as level-errors\n          if (!err.status) err.status = 404; // Same as level-errors\n        }\n\n        return callback(err);\n      }\n      try {\n        value = valueEncoding.decode(value);\n      } catch (err) {\n        return callback(new ModuleError('Could not decode value', {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }));\n      }\n      callback(null, value);\n    });\n    return callback[kPromise];\n  }\n  _get(key, options, callback) {\n    this.nextTick(callback, new Error('NotFound'));\n  }\n  getMany(keys, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.getMany(keys, options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    if (!Array.isArray(keys)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'keys' must be an array\"));\n      return callback[kPromise];\n    }\n    if (keys.length === 0) {\n      this.nextTick(callback, null, []);\n      return callback[kPromise];\n    }\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format;\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n    const mappedKeys = new Array(keys.length);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const err = this._checkKey(key);\n      if (err) {\n        this.nextTick(callback, err);\n        return callback[kPromise];\n      }\n      mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat);\n    }\n    this._getMany(mappedKeys, options, (err, values) => {\n      if (err) return callback(err);\n      try {\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] !== undefined) {\n            values[i] = valueEncoding.decode(values[i]);\n          }\n        }\n      } catch (err) {\n        return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }));\n      }\n      callback(null, values);\n    });\n    return callback[kPromise];\n  }\n  _getMany(keys, options, callback) {\n    this.nextTick(callback, null, new Array(keys.length).fill(undefined));\n  }\n  put(key, value, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].entry);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.put(key, value, options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    const err = this._checkKey(key) || this._checkValue(value);\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options.valueEncoding);\n    const keyFormat = keyEncoding.format;\n    const valueFormat = valueEncoding.format;\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat,\n        valueEncoding: valueFormat\n      });\n    }\n    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);\n    const mappedValue = valueEncoding.encode(value);\n    this._put(mappedKey, mappedValue, options, err => {\n      if (err) return callback(err);\n      this.emit('put', key, value);\n      callback();\n    });\n    return callback[kPromise];\n  }\n  _put(key, value, options, callback) {\n    this.nextTick(callback);\n  }\n  del(key, options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].key);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.del(key, options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    const err = this._checkKey(key);\n    if (err) {\n      this.nextTick(callback, err);\n      return callback[kPromise];\n    }\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    const keyFormat = keyEncoding.format;\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat) {\n      options = Object.assign({}, options, {\n        keyEncoding: keyFormat\n      });\n    }\n    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, err => {\n      if (err) return callback(err);\n      this.emit('del', key);\n      callback();\n    });\n    return callback[kPromise];\n  }\n  _del(key, options, callback) {\n    this.nextTick(callback);\n  }\n  batch(operations, options, callback) {\n    if (!arguments.length) {\n      if (this[kStatus] === 'opening') return new DefaultChainedBatch(this);\n      if (this[kStatus] !== 'open') {\n        throw new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN'\n        });\n      }\n      return this._chainedBatch();\n    }\n    if (typeof operations === 'function') callback = operations;else callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].empty);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.batch(operations, options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    if (!Array.isArray(operations)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'operations' must be an array\"));\n      return callback[kPromise];\n    }\n    if (operations.length === 0) {\n      this.nextTick(callback);\n      return callback[kPromise];\n    }\n    const mapped = new Array(operations.length);\n    const {\n      keyEncoding: ke,\n      valueEncoding: ve,\n      ...forward\n    } = options;\n    for (let i = 0; i < operations.length; i++) {\n      if (typeof operations[i] !== 'object' || operations[i] === null) {\n        this.nextTick(callback, new TypeError('A batch operation must be an object'));\n        return callback[kPromise];\n      }\n      const op = Object.assign({}, operations[i]);\n      if (op.type !== 'put' && op.type !== 'del') {\n        this.nextTick(callback, new TypeError(\"A batch operation must have a type property that is 'put' or 'del'\"));\n        return callback[kPromise];\n      }\n      const err = this._checkKey(op.key);\n      if (err) {\n        this.nextTick(callback, err);\n        return callback[kPromise];\n      }\n      const db = op.sublevel != null ? op.sublevel : this;\n      const keyEncoding = db.keyEncoding(op.keyEncoding || ke);\n      const keyFormat = keyEncoding.format;\n      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);\n      op.keyEncoding = keyFormat;\n      if (op.type === 'put') {\n        const valueErr = this._checkValue(op.value);\n        if (valueErr) {\n          this.nextTick(callback, valueErr);\n          return callback[kPromise];\n        }\n        const valueEncoding = db.valueEncoding(op.valueEncoding || ve);\n        op.value = valueEncoding.encode(op.value);\n        op.valueEncoding = valueEncoding.format;\n      }\n\n      // Prevent double prefixing\n      if (db !== this) {\n        op.sublevel = null;\n      }\n      mapped[i] = op;\n    }\n    this._batch(mapped, forward, err => {\n      if (err) return callback(err);\n      this.emit('batch', operations);\n      callback();\n    });\n    return callback[kPromise];\n  }\n  _batch(operations, options, callback) {\n    this.nextTick(callback);\n  }\n  sublevel(name, options) {\n    return this._sublevel(name, AbstractSublevel.defaults(options));\n  }\n  _sublevel(name, options) {\n    return new AbstractSublevel(this, name, options);\n  }\n  prefixKey(key, keyFormat) {\n    return key;\n  }\n  clear(options, callback) {\n    callback = getCallback(options, callback);\n    callback = fromCallback(callback, kPromise);\n    options = getOptions(options, this[kDefaultOptions].empty);\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.clear(options, callback));\n      return callback[kPromise];\n    }\n    if (maybeError(this, callback)) {\n      return callback[kPromise];\n    }\n    const original = options;\n    const keyEncoding = this.keyEncoding(options.keyEncoding);\n    options = rangeOptions(options, keyEncoding);\n    options.keyEncoding = keyEncoding.format;\n    if (options.limit === 0) {\n      this.nextTick(callback);\n    } else {\n      this._clear(options, err => {\n        if (err) return callback(err);\n        this.emit('clear', original);\n        callback();\n      });\n    }\n    return callback[kPromise];\n  }\n  _clear(options, callback) {\n    this.nextTick(callback);\n  }\n  iterator(options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding);\n    options.keys = options.keys !== false;\n    options.values = options.values !== false;\n\n    // We need the original encoding options in AbstractIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding;\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n    if (this[kStatus] === 'opening') {\n      return new DeferredIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n    return this._iterator(options);\n  }\n  _iterator(options) {\n    return new AbstractIterator(this, options);\n  }\n  keys(options) {\n    // Also include valueEncoding (though unused) because we may fallback to _iterator()\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding);\n\n    // We need the original encoding options in AbstractKeyIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding;\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n    if (this[kStatus] === 'opening') {\n      return new DeferredKeyIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n    return this._keys(options);\n  }\n  _keys(options) {\n    return new DefaultKeyIterator(this, options);\n  }\n  values(options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding);\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding);\n    options = rangeOptions(options, keyEncoding);\n\n    // We need the original encoding options in AbstractValueIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding;\n    options[AbstractIterator.valueEncoding] = valueEncoding;\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format;\n    options.valueEncoding = valueEncoding.format;\n    if (this[kStatus] === 'opening') {\n      return new DeferredValueIterator(this, options);\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      });\n    }\n    return this._values(options);\n  }\n  _values(options) {\n    return new DefaultValueIterator(this, options);\n  }\n  defer(fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The first argument must be a function');\n    }\n    this[kOperations].push(fn);\n  }\n  [kUndefer]() {\n    if (this[kOperations].length === 0) {\n      return;\n    }\n    const operations = this[kOperations];\n    this[kOperations] = [];\n    for (const op of operations) {\n      op();\n    }\n  }\n\n  // TODO: docs and types\n  attachResource(resource) {\n    if (typeof resource !== 'object' || resource === null || typeof resource.close !== 'function') {\n      throw new TypeError('The first argument must be a resource object');\n    }\n    this[kResources].add(resource);\n  }\n\n  // TODO: docs and types\n  detachResource(resource) {\n    this[kResources].delete(resource);\n  }\n  _chainedBatch() {\n    return new DefaultChainedBatch(this);\n  }\n  _checkKey(key) {\n    if (key === null || key === undefined) {\n      return new ModuleError('Key cannot be null or undefined', {\n        code: 'LEVEL_INVALID_KEY'\n      });\n    }\n  }\n  _checkValue(value) {\n    if (value === null || value === undefined) {\n      return new ModuleError('Value cannot be null or undefined', {\n        code: 'LEVEL_INVALID_VALUE'\n      });\n    }\n  }\n}\n\n// Expose browser-compatible nextTick for dependents\n// TODO: after we drop node 10, also use queueMicrotask in node\nAbstractLevel.prototype.nextTick = require('./lib/next-tick');\nconst {\n  AbstractSublevel\n} = require('./lib/abstract-sublevel')({\n  AbstractLevel\n});\nexports.AbstractLevel = AbstractLevel;\nexports.AbstractSublevel = AbstractSublevel;\nconst maybeError = function (db, callback) {\n  if (db[kStatus] !== 'open') {\n    db.nextTick(callback, new ModuleError('Database is not open', {\n      code: 'LEVEL_DATABASE_NOT_OPEN'\n    }));\n    return true;\n  }\n  return false;\n};\nconst formats = function (db) {\n  return Object.keys(db.supports.encodings).filter(k => !!db.supports.encodings[k]);\n};","map":{"version":3,"names":["require","supports","Transcoder","EventEmitter","fromCallback","ModuleError","AbstractIterator","DefaultKeyIterator","DefaultValueIterator","DeferredIterator","DeferredKeyIterator","DeferredValueIterator","DefaultChainedBatch","getCallback","getOptions","rangeOptions","kPromise","Symbol","kLanded","kResources","kCloseResources","kOperations","kUndefer","kDeferOpen","kOptions","kStatus","kDefaultOptions","kTranscoder","kKeyEncoding","kValueEncoding","noop","AbstractLevel","constructor","manifest","options","TypeError","keyEncoding","valueEncoding","passive","forward","Set","status","promises","clear","getMany","deferredOpen","snapshots","permanence","keyIterator","valueIterator","iteratorNextv","iteratorAll","encodings","events","Object","assign","opening","open","closing","closed","put","del","batch","formats","encoding","commonName","empty","freeze","entry","key","nextTick","callback","createIfMissing","errorIfExists","maybeOpened","err","once","code","cause","emit","_open","close","maybeClosed","cancel","_close","size","pending","sync","next","resource","get","defer","maybeError","_checkKey","keyFormat","format","valueFormat","_get","prefixKey","encode","value","notFound","test","decode","Error","keys","Array","isArray","length","mappedKeys","i","_getMany","values","undefined","fill","_checkValue","mappedKey","mappedValue","_put","_del","operations","arguments","_chainedBatch","mapped","ke","ve","op","type","db","sublevel","valueErr","_batch","name","_sublevel","AbstractSublevel","defaults","original","limit","_clear","iterator","_iterator","_keys","_values","fn","push","attachResource","add","detachResource","delete","prototype","exports","filter","k"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/abstract-level@1.0.3/node_modules/abstract-level/abstract-level.js"],"sourcesContent":["'use strict'\n\nconst { supports } = require('level-supports')\nconst { Transcoder } = require('level-transcoder')\nconst { EventEmitter } = require('events')\nconst { fromCallback } = require('catering')\nconst ModuleError = require('module-error')\nconst { AbstractIterator } = require('./abstract-iterator')\nconst { DefaultKeyIterator, DefaultValueIterator } = require('./lib/default-kv-iterator')\nconst { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = require('./lib/deferred-iterator')\nconst { DefaultChainedBatch } = require('./lib/default-chained-batch')\nconst { getCallback, getOptions } = require('./lib/common')\nconst rangeOptions = require('./lib/range-options')\n\nconst kPromise = Symbol('promise')\nconst kLanded = Symbol('landed')\nconst kResources = Symbol('resources')\nconst kCloseResources = Symbol('closeResources')\nconst kOperations = Symbol('operations')\nconst kUndefer = Symbol('undefer')\nconst kDeferOpen = Symbol('deferOpen')\nconst kOptions = Symbol('options')\nconst kStatus = Symbol('status')\nconst kDefaultOptions = Symbol('defaultOptions')\nconst kTranscoder = Symbol('transcoder')\nconst kKeyEncoding = Symbol('keyEncoding')\nconst kValueEncoding = Symbol('valueEncoding')\nconst noop = () => {}\n\nclass AbstractLevel extends EventEmitter {\n  constructor (manifest, options) {\n    super()\n\n    if (typeof manifest !== 'object' || manifest === null) {\n      throw new TypeError(\"The first argument 'manifest' must be an object\")\n    }\n\n    options = getOptions(options)\n    const { keyEncoding, valueEncoding, passive, ...forward } = options\n\n    this[kResources] = new Set()\n    this[kOperations] = []\n    this[kDeferOpen] = true\n    this[kOptions] = forward\n    this[kStatus] = 'opening'\n\n    this.supports = supports(manifest, {\n      status: true,\n      promises: true,\n      clear: true,\n      getMany: true,\n      deferredOpen: true,\n\n      // TODO (next major): add seek\n      snapshots: manifest.snapshots !== false,\n      permanence: manifest.permanence !== false,\n\n      // TODO: remove from level-supports because it's always supported\n      keyIterator: true,\n      valueIterator: true,\n      iteratorNextv: true,\n      iteratorAll: true,\n\n      encodings: manifest.encodings || {},\n      events: Object.assign({}, manifest.events, {\n        opening: true,\n        open: true,\n        closing: true,\n        closed: true,\n        put: true,\n        del: true,\n        batch: true,\n        clear: true\n      })\n    })\n\n    this[kTranscoder] = new Transcoder(formats(this))\n    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8')\n    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8')\n\n    // Add custom and transcoder encodings to manifest\n    for (const encoding of this[kTranscoder].encodings()) {\n      if (!this.supports.encodings[encoding.commonName]) {\n        this.supports.encodings[encoding.commonName] = true\n      }\n    }\n\n    this[kDefaultOptions] = {\n      empty: Object.freeze({}),\n      entry: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName,\n        valueEncoding: this[kValueEncoding].commonName\n      }),\n      key: Object.freeze({\n        keyEncoding: this[kKeyEncoding].commonName\n      })\n    }\n\n    // Let subclass finish its constructor\n    this.nextTick(() => {\n      if (this[kDeferOpen]) {\n        this.open({ passive: false }, noop)\n      }\n    })\n  }\n\n  get status () {\n    return this[kStatus]\n  }\n\n  keyEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding])\n  }\n\n  valueEncoding (encoding) {\n    return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding])\n  }\n\n  open (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n\n    options = { ...this[kOptions], ...getOptions(options) }\n\n    options.createIfMissing = options.createIfMissing !== false\n    options.errorIfExists = !!options.errorIfExists\n\n    const maybeOpened = (err) => {\n      if (this[kStatus] === 'closing' || this[kStatus] === 'opening') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened)\n      } else if (this[kStatus] !== 'open') {\n        callback(new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (options.passive) {\n      if (this[kStatus] === 'opening') {\n        this.once(kLanded, maybeOpened)\n      } else {\n        this.nextTick(maybeOpened)\n      }\n    } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {\n      this[kDeferOpen] = false\n      this[kStatus] = 'opening'\n      this.emit('opening')\n\n      this._open(options, (err) => {\n        if (err) {\n          this[kStatus] = 'closed'\n\n          // Resources must be safe to close in any db state\n          this[kCloseResources](() => {\n            this.emit(kLanded)\n            maybeOpened(err)\n          })\n\n          this[kUndefer]()\n          return\n        }\n\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n\n        // Only emit public event if pending state changes are done\n        if (this[kStatus] === 'open') this.emit('open')\n\n        // TODO (next major): remove this alias\n        if (this[kStatus] === 'open') this.emit('ready')\n\n        maybeOpened()\n      })\n    } else if (this[kStatus] === 'open') {\n      this.nextTick(maybeOpened)\n    } else {\n      this.once(kLanded, () => this.open(options, callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  _open (options, callback) {\n    this.nextTick(callback)\n  }\n\n  close (callback) {\n    callback = fromCallback(callback, kPromise)\n\n    const maybeClosed = (err) => {\n      if (this[kStatus] === 'opening' || this[kStatus] === 'closing') {\n        // Wait until pending state changes are done\n        this.once(kLanded, err ? maybeClosed(err) : maybeClosed)\n      } else if (this[kStatus] !== 'closed') {\n        callback(new ModuleError('Database is not closed', {\n          code: 'LEVEL_DATABASE_NOT_CLOSED',\n          cause: err\n        }))\n      } else {\n        callback()\n      }\n    }\n\n    if (this[kStatus] === 'open') {\n      this[kStatus] = 'closing'\n      this.emit('closing')\n\n      const cancel = (err) => {\n        this[kStatus] = 'open'\n        this[kUndefer]()\n        this.emit(kLanded)\n        maybeClosed(err)\n      }\n\n      this[kCloseResources](() => {\n        this._close((err) => {\n          if (err) return cancel(err)\n\n          this[kStatus] = 'closed'\n          this[kUndefer]()\n          this.emit(kLanded)\n\n          // Only emit public event if pending state changes are done\n          if (this[kStatus] === 'closed') this.emit('closed')\n\n          maybeClosed()\n        })\n      })\n    } else if (this[kStatus] === 'closed') {\n      this.nextTick(maybeClosed)\n    } else {\n      this.once(kLanded, () => this.close(callback))\n    }\n\n    return callback[kPromise]\n  }\n\n  [kCloseResources] (callback) {\n    if (this[kResources].size === 0) {\n      return this.nextTick(callback)\n    }\n\n    let pending = this[kResources].size\n    let sync = true\n\n    const next = () => {\n      if (--pending === 0) {\n        // We don't have tests for generic resources, so dezalgo\n        if (sync) this.nextTick(callback)\n        else callback()\n      }\n    }\n\n    // In parallel so that all resources know they are closed\n    for (const resource of this[kResources]) {\n      resource.close(next)\n    }\n\n    sync = false\n    this[kResources].clear()\n  }\n\n  _close (callback) {\n    this.nextTick(callback)\n  }\n\n  get (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.get(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options to the underlying store\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      // Avoid spread operator because of https://bugs.chromium.org/p/chromium/issues/detail?id=1204540\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err, value) => {\n      if (err) {\n        // Normalize not found error for backwards compatibility with abstract-leveldown and level(up)\n        if (err.code === 'LEVEL_NOT_FOUND' || err.notFound || /NotFound/i.test(err)) {\n          if (!err.code) err.code = 'LEVEL_NOT_FOUND' // Preferred way going forward\n          if (!err.notFound) err.notFound = true // Same as level-errors\n          if (!err.status) err.status = 404 // Same as level-errors\n        }\n\n        return callback(err)\n      }\n\n      try {\n        value = valueEncoding.decode(value)\n      } catch (err) {\n        return callback(new ModuleError('Could not decode value', {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, value)\n    })\n\n    return callback[kPromise]\n  }\n\n  _get (key, options, callback) {\n    this.nextTick(callback, new Error('NotFound'))\n  }\n\n  getMany (keys, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.getMany(keys, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(keys)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'keys' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (keys.length === 0) {\n      this.nextTick(callback, null, [])\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKeys = new Array(keys.length)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const err = this._checkKey(key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    }\n\n    this._getMany(mappedKeys, options, (err, values) => {\n      if (err) return callback(err)\n\n      try {\n        for (let i = 0; i < values.length; i++) {\n          if (values[i] !== undefined) {\n            values[i] = valueEncoding.decode(values[i])\n          }\n        }\n      } catch (err) {\n        return callback(new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {\n          code: 'LEVEL_DECODE_ERROR',\n          cause: err\n        }))\n      }\n\n      callback(null, values)\n    })\n\n    return callback[kPromise]\n  }\n\n  _getMany (keys, options, callback) {\n    this.nextTick(callback, null, new Array(keys.length).fill(undefined))\n  }\n\n  put (key, value, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].entry)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.put(key, value, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key) || this._checkValue(value)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options.valueEncoding)\n    const keyFormat = keyEncoding.format\n    const valueFormat = valueEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat })\n    }\n\n    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat)\n    const mappedValue = valueEncoding.encode(value)\n\n    this._put(mappedKey, mappedValue, options, (err) => {\n      if (err) return callback(err)\n      this.emit('put', key, value)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _put (key, value, options, callback) {\n    this.nextTick(callback)\n  }\n\n  del (key, options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].key)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.del(key, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const err = this._checkKey(key)\n\n    if (err) {\n      this.nextTick(callback, err)\n      return callback[kPromise]\n    }\n\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n    const keyFormat = keyEncoding.format\n\n    // Forward encoding options\n    if (options.keyEncoding !== keyFormat) {\n      options = Object.assign({}, options, { keyEncoding: keyFormat })\n    }\n\n    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err) => {\n      if (err) return callback(err)\n      this.emit('del', key)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _del (key, options, callback) {\n    this.nextTick(callback)\n  }\n\n  batch (operations, options, callback) {\n    if (!arguments.length) {\n      if (this[kStatus] === 'opening') return new DefaultChainedBatch(this)\n      if (this[kStatus] !== 'open') {\n        throw new ModuleError('Database is not open', {\n          code: 'LEVEL_DATABASE_NOT_OPEN'\n        })\n      }\n      return this._chainedBatch()\n    }\n\n    if (typeof operations === 'function') callback = operations\n    else callback = getCallback(options, callback)\n\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.batch(operations, options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    if (!Array.isArray(operations)) {\n      this.nextTick(callback, new TypeError(\"The first argument 'operations' must be an array\"))\n      return callback[kPromise]\n    }\n\n    if (operations.length === 0) {\n      this.nextTick(callback)\n      return callback[kPromise]\n    }\n\n    const mapped = new Array(operations.length)\n    const { keyEncoding: ke, valueEncoding: ve, ...forward } = options\n\n    for (let i = 0; i < operations.length; i++) {\n      if (typeof operations[i] !== 'object' || operations[i] === null) {\n        this.nextTick(callback, new TypeError('A batch operation must be an object'))\n        return callback[kPromise]\n      }\n\n      const op = Object.assign({}, operations[i])\n\n      if (op.type !== 'put' && op.type !== 'del') {\n        this.nextTick(callback, new TypeError(\"A batch operation must have a type property that is 'put' or 'del'\"))\n        return callback[kPromise]\n      }\n\n      const err = this._checkKey(op.key)\n\n      if (err) {\n        this.nextTick(callback, err)\n        return callback[kPromise]\n      }\n\n      const db = op.sublevel != null ? op.sublevel : this\n      const keyEncoding = db.keyEncoding(op.keyEncoding || ke)\n      const keyFormat = keyEncoding.format\n\n      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat)\n      op.keyEncoding = keyFormat\n\n      if (op.type === 'put') {\n        const valueErr = this._checkValue(op.value)\n\n        if (valueErr) {\n          this.nextTick(callback, valueErr)\n          return callback[kPromise]\n        }\n\n        const valueEncoding = db.valueEncoding(op.valueEncoding || ve)\n\n        op.value = valueEncoding.encode(op.value)\n        op.valueEncoding = valueEncoding.format\n      }\n\n      // Prevent double prefixing\n      if (db !== this) {\n        op.sublevel = null\n      }\n\n      mapped[i] = op\n    }\n\n    this._batch(mapped, forward, (err) => {\n      if (err) return callback(err)\n      this.emit('batch', operations)\n      callback()\n    })\n\n    return callback[kPromise]\n  }\n\n  _batch (operations, options, callback) {\n    this.nextTick(callback)\n  }\n\n  sublevel (name, options) {\n    return this._sublevel(name, AbstractSublevel.defaults(options))\n  }\n\n  _sublevel (name, options) {\n    return new AbstractSublevel(this, name, options)\n  }\n\n  prefixKey (key, keyFormat) {\n    return key\n  }\n\n  clear (options, callback) {\n    callback = getCallback(options, callback)\n    callback = fromCallback(callback, kPromise)\n    options = getOptions(options, this[kDefaultOptions].empty)\n\n    if (this[kStatus] === 'opening') {\n      this.defer(() => this.clear(options, callback))\n      return callback[kPromise]\n    }\n\n    if (maybeError(this, callback)) {\n      return callback[kPromise]\n    }\n\n    const original = options\n    const keyEncoding = this.keyEncoding(options.keyEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keyEncoding = keyEncoding.format\n\n    if (options.limit === 0) {\n      this.nextTick(callback)\n    } else {\n      this._clear(options, (err) => {\n        if (err) return callback(err)\n        this.emit('clear', original)\n        callback()\n      })\n    }\n\n    return callback[kPromise]\n  }\n\n  _clear (options, callback) {\n    this.nextTick(callback)\n  }\n\n  iterator (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n    options.keys = options.keys !== false\n    options.values = options.values !== false\n\n    // We need the original encoding options in AbstractIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._iterator(options)\n  }\n\n  _iterator (options) {\n    return new AbstractIterator(this, options)\n  }\n\n  keys (options) {\n    // Also include valueEncoding (though unused) because we may fallback to _iterator()\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractKeyIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredKeyIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._keys(options)\n  }\n\n  _keys (options) {\n    return new DefaultKeyIterator(this, options)\n  }\n\n  values (options) {\n    const keyEncoding = this.keyEncoding(options && options.keyEncoding)\n    const valueEncoding = this.valueEncoding(options && options.valueEncoding)\n\n    options = rangeOptions(options, keyEncoding)\n\n    // We need the original encoding options in AbstractValueIterator in order to decode data\n    options[AbstractIterator.keyEncoding] = keyEncoding\n    options[AbstractIterator.valueEncoding] = valueEncoding\n\n    // Forward encoding options to private API\n    options.keyEncoding = keyEncoding.format\n    options.valueEncoding = valueEncoding.format\n\n    if (this[kStatus] === 'opening') {\n      return new DeferredValueIterator(this, options)\n    } else if (this[kStatus] !== 'open') {\n      throw new ModuleError('Database is not open', {\n        code: 'LEVEL_DATABASE_NOT_OPEN'\n      })\n    }\n\n    return this._values(options)\n  }\n\n  _values (options) {\n    return new DefaultValueIterator(this, options)\n  }\n\n  defer (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The first argument must be a function')\n    }\n\n    this[kOperations].push(fn)\n  }\n\n  [kUndefer] () {\n    if (this[kOperations].length === 0) {\n      return\n    }\n\n    const operations = this[kOperations]\n    this[kOperations] = []\n\n    for (const op of operations) {\n      op()\n    }\n  }\n\n  // TODO: docs and types\n  attachResource (resource) {\n    if (typeof resource !== 'object' || resource === null ||\n      typeof resource.close !== 'function') {\n      throw new TypeError('The first argument must be a resource object')\n    }\n\n    this[kResources].add(resource)\n  }\n\n  // TODO: docs and types\n  detachResource (resource) {\n    this[kResources].delete(resource)\n  }\n\n  _chainedBatch () {\n    return new DefaultChainedBatch(this)\n  }\n\n  _checkKey (key) {\n    if (key === null || key === undefined) {\n      return new ModuleError('Key cannot be null or undefined', {\n        code: 'LEVEL_INVALID_KEY'\n      })\n    }\n  }\n\n  _checkValue (value) {\n    if (value === null || value === undefined) {\n      return new ModuleError('Value cannot be null or undefined', {\n        code: 'LEVEL_INVALID_VALUE'\n      })\n    }\n  }\n}\n\n// Expose browser-compatible nextTick for dependents\n// TODO: after we drop node 10, also use queueMicrotask in node\nAbstractLevel.prototype.nextTick = require('./lib/next-tick')\n\nconst { AbstractSublevel } = require('./lib/abstract-sublevel')({ AbstractLevel })\n\nexports.AbstractLevel = AbstractLevel\nexports.AbstractSublevel = AbstractSublevel\n\nconst maybeError = function (db, callback) {\n  if (db[kStatus] !== 'open') {\n    db.nextTick(callback, new ModuleError('Database is not open', {\n      code: 'LEVEL_DATABASE_NOT_OPEN'\n    }))\n    return true\n  }\n\n  return false\n}\n\nconst formats = function (db) {\n  return Object.keys(db.supports.encodings)\n    .filter(k => !!db.supports.encodings[k])\n}\n"],"mappings":"AAAA,YAAY;;AAAAA,OAAA;AAEZ,MAAM;EAAEC;AAAS,CAAC,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAM;EAAEE;AAAW,CAAC,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAM;EAAEG;AAAa,CAAC,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC1C,MAAM;EAAEI;AAAa,CAAC,GAAGJ,OAAO,CAAC,UAAU,CAAC;AAC5C,MAAMK,WAAW,GAAGL,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAM;EAAEM;AAAiB,CAAC,GAAGN,OAAO,CAAC,qBAAqB,CAAC;AAC3D,MAAM;EAAEO,kBAAkB;EAAEC;AAAqB,CAAC,GAAGR,OAAO,CAAC,2BAA2B,CAAC;AACzF,MAAM;EAAES,gBAAgB;EAAEC,mBAAmB;EAAEC;AAAsB,CAAC,GAAGX,OAAO,CAAC,yBAAyB,CAAC;AAC3G,MAAM;EAAEY;AAAoB,CAAC,GAAGZ,OAAO,CAAC,6BAA6B,CAAC;AACtE,MAAM;EAAEa,WAAW;EAAEC;AAAW,CAAC,GAAGd,OAAO,CAAC,cAAc,CAAC;AAC3D,MAAMe,YAAY,GAAGf,OAAO,CAAC,qBAAqB,CAAC;AAEnD,MAAMgB,QAAQ,GAAGC,MAAM,CAAC,SAAS,CAAC;AAClC,MAAMC,OAAO,GAAGD,MAAM,CAAC,QAAQ,CAAC;AAChC,MAAME,UAAU,GAAGF,MAAM,CAAC,WAAW,CAAC;AACtC,MAAMG,eAAe,GAAGH,MAAM,CAAC,gBAAgB,CAAC;AAChD,MAAMI,WAAW,GAAGJ,MAAM,CAAC,YAAY,CAAC;AACxC,MAAMK,QAAQ,GAAGL,MAAM,CAAC,SAAS,CAAC;AAClC,MAAMM,UAAU,GAAGN,MAAM,CAAC,WAAW,CAAC;AACtC,MAAMO,QAAQ,GAAGP,MAAM,CAAC,SAAS,CAAC;AAClC,MAAMQ,OAAO,GAAGR,MAAM,CAAC,QAAQ,CAAC;AAChC,MAAMS,eAAe,GAAGT,MAAM,CAAC,gBAAgB,CAAC;AAChD,MAAMU,WAAW,GAAGV,MAAM,CAAC,YAAY,CAAC;AACxC,MAAMW,YAAY,GAAGX,MAAM,CAAC,aAAa,CAAC;AAC1C,MAAMY,cAAc,GAAGZ,MAAM,CAAC,eAAe,CAAC;AAC9C,MAAMa,IAAI,GAAGA,CAAA,KAAM,CAAC,CAAC;AAErB,MAAMC,aAAa,SAAS5B,YAAY,CAAC;EACvC6B,WAAWA,CAAEC,QAAQ,EAAEC,OAAO,EAAE;IAC9B,KAAK,CAAC,CAAC;IAEP,IAAI,OAAOD,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,IAAI,EAAE;MACrD,MAAM,IAAIE,SAAS,CAAC,iDAAiD,CAAC;IACxE;IAEAD,OAAO,GAAGpB,UAAU,CAACoB,OAAO,CAAC;IAC7B,MAAM;MAAEE,WAAW;MAAEC,aAAa;MAAEC,OAAO;MAAE,GAAGC;IAAQ,CAAC,GAAGL,OAAO;IAEnE,IAAI,CAACf,UAAU,CAAC,GAAG,IAAIqB,GAAG,CAAC,CAAC;IAC5B,IAAI,CAACnB,WAAW,CAAC,GAAG,EAAE;IACtB,IAAI,CAACE,UAAU,CAAC,GAAG,IAAI;IACvB,IAAI,CAACC,QAAQ,CAAC,GAAGe,OAAO;IACxB,IAAI,CAACd,OAAO,CAAC,GAAG,SAAS;IAEzB,IAAI,CAACxB,QAAQ,GAAGA,QAAQ,CAACgC,QAAQ,EAAE;MACjCQ,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,IAAI;MACXC,OAAO,EAAE,IAAI;MACbC,YAAY,EAAE,IAAI;MAElB;MACAC,SAAS,EAAEb,QAAQ,CAACa,SAAS,KAAK,KAAK;MACvCC,UAAU,EAAEd,QAAQ,CAACc,UAAU,KAAK,KAAK;MAEzC;MACAC,WAAW,EAAE,IAAI;MACjBC,aAAa,EAAE,IAAI;MACnBC,aAAa,EAAE,IAAI;MACnBC,WAAW,EAAE,IAAI;MAEjBC,SAAS,EAAEnB,QAAQ,CAACmB,SAAS,IAAI,CAAC,CAAC;MACnCC,MAAM,EAAEC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEtB,QAAQ,CAACoB,MAAM,EAAE;QACzCG,OAAO,EAAE,IAAI;QACbC,IAAI,EAAE,IAAI;QACVC,OAAO,EAAE,IAAI;QACbC,MAAM,EAAE,IAAI;QACZC,GAAG,EAAE,IAAI;QACTC,GAAG,EAAE,IAAI;QACTC,KAAK,EAAE,IAAI;QACXnB,KAAK,EAAE;MACT,CAAC;IACH,CAAC,CAAC;IAEF,IAAI,CAAChB,WAAW,CAAC,GAAG,IAAIzB,UAAU,CAAC6D,OAAO,CAAC,IAAI,CAAC,CAAC;IACjD,IAAI,CAACnC,YAAY,CAAC,GAAG,IAAI,CAACD,WAAW,CAAC,CAACqC,QAAQ,CAAC5B,WAAW,IAAI,MAAM,CAAC;IACtE,IAAI,CAACP,cAAc,CAAC,GAAG,IAAI,CAACF,WAAW,CAAC,CAACqC,QAAQ,CAAC3B,aAAa,IAAI,MAAM,CAAC;;IAE1E;IACA,KAAK,MAAM2B,QAAQ,IAAI,IAAI,CAACrC,WAAW,CAAC,CAACyB,SAAS,CAAC,CAAC,EAAE;MACpD,IAAI,CAAC,IAAI,CAACnD,QAAQ,CAACmD,SAAS,CAACY,QAAQ,CAACC,UAAU,CAAC,EAAE;QACjD,IAAI,CAAChE,QAAQ,CAACmD,SAAS,CAACY,QAAQ,CAACC,UAAU,CAAC,GAAG,IAAI;MACrD;IACF;IAEA,IAAI,CAACvC,eAAe,CAAC,GAAG;MACtBwC,KAAK,EAAEZ,MAAM,CAACa,MAAM,CAAC,CAAC,CAAC,CAAC;MACxBC,KAAK,EAAEd,MAAM,CAACa,MAAM,CAAC;QACnB/B,WAAW,EAAE,IAAI,CAACR,YAAY,CAAC,CAACqC,UAAU;QAC1C5B,aAAa,EAAE,IAAI,CAACR,cAAc,CAAC,CAACoC;MACtC,CAAC,CAAC;MACFI,GAAG,EAAEf,MAAM,CAACa,MAAM,CAAC;QACjB/B,WAAW,EAAE,IAAI,CAACR,YAAY,CAAC,CAACqC;MAClC,CAAC;IACH,CAAC;;IAED;IACA,IAAI,CAACK,QAAQ,CAAC,MAAM;MAClB,IAAI,IAAI,CAAC/C,UAAU,CAAC,EAAE;QACpB,IAAI,CAACkC,IAAI,CAAC;UAAEnB,OAAO,EAAE;QAAM,CAAC,EAAER,IAAI,CAAC;MACrC;IACF,CAAC,CAAC;EACJ;EAEA,IAAIW,MAAMA,CAAA,EAAI;IACZ,OAAO,IAAI,CAAChB,OAAO,CAAC;EACtB;EAEAW,WAAWA,CAAE4B,QAAQ,EAAE;IACrB,OAAO,IAAI,CAACrC,WAAW,CAAC,CAACqC,QAAQ,CAACA,QAAQ,IAAI,IAAI,GAAGA,QAAQ,GAAG,IAAI,CAACpC,YAAY,CAAC,CAAC;EACrF;EAEAS,aAAaA,CAAE2B,QAAQ,EAAE;IACvB,OAAO,IAAI,CAACrC,WAAW,CAAC,CAACqC,QAAQ,CAACA,QAAQ,IAAI,IAAI,GAAGA,QAAQ,GAAG,IAAI,CAACnC,cAAc,CAAC,CAAC;EACvF;EAEA4B,IAAIA,CAAEvB,OAAO,EAAEqC,QAAQ,EAAE;IACvBA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAE3CkB,OAAO,GAAG;MAAE,GAAG,IAAI,CAACV,QAAQ,CAAC;MAAE,GAAGV,UAAU,CAACoB,OAAO;IAAE,CAAC;IAEvDA,OAAO,CAACsC,eAAe,GAAGtC,OAAO,CAACsC,eAAe,KAAK,KAAK;IAC3DtC,OAAO,CAACuC,aAAa,GAAG,CAAC,CAACvC,OAAO,CAACuC,aAAa;IAE/C,MAAMC,WAAW,GAAIC,GAAG,IAAK;MAC3B,IAAI,IAAI,CAAClD,OAAO,CAAC,KAAK,SAAS,IAAI,IAAI,CAACA,OAAO,CAAC,KAAK,SAAS,EAAE;QAC9D;QACA,IAAI,CAACmD,IAAI,CAAC1D,OAAO,EAAEyD,GAAG,GAAG,MAAMD,WAAW,CAACC,GAAG,CAAC,GAAGD,WAAW,CAAC;MAChE,CAAC,MAAM,IAAI,IAAI,CAACjD,OAAO,CAAC,KAAK,MAAM,EAAE;QACnC8C,QAAQ,CAAC,IAAIlE,WAAW,CAAC,sBAAsB,EAAE;UAC/CwE,IAAI,EAAE,yBAAyB;UAC/BC,KAAK,EAAEH;QACT,CAAC,CAAC,CAAC;MACL,CAAC,MAAM;QACLJ,QAAQ,CAAC,CAAC;MACZ;IACF,CAAC;IAED,IAAIrC,OAAO,CAACI,OAAO,EAAE;MACnB,IAAI,IAAI,CAACb,OAAO,CAAC,KAAK,SAAS,EAAE;QAC/B,IAAI,CAACmD,IAAI,CAAC1D,OAAO,EAAEwD,WAAW,CAAC;MACjC,CAAC,MAAM;QACL,IAAI,CAACJ,QAAQ,CAACI,WAAW,CAAC;MAC5B;IACF,CAAC,MAAM,IAAI,IAAI,CAACjD,OAAO,CAAC,KAAK,QAAQ,IAAI,IAAI,CAACF,UAAU,CAAC,EAAE;MACzD,IAAI,CAACA,UAAU,CAAC,GAAG,KAAK;MACxB,IAAI,CAACE,OAAO,CAAC,GAAG,SAAS;MACzB,IAAI,CAACsD,IAAI,CAAC,SAAS,CAAC;MAEpB,IAAI,CAACC,KAAK,CAAC9C,OAAO,EAAGyC,GAAG,IAAK;QAC3B,IAAIA,GAAG,EAAE;UACP,IAAI,CAAClD,OAAO,CAAC,GAAG,QAAQ;;UAExB;UACA,IAAI,CAACL,eAAe,CAAC,CAAC,MAAM;YAC1B,IAAI,CAAC2D,IAAI,CAAC7D,OAAO,CAAC;YAClBwD,WAAW,CAACC,GAAG,CAAC;UAClB,CAAC,CAAC;UAEF,IAAI,CAACrD,QAAQ,CAAC,CAAC,CAAC;UAChB;QACF;QAEA,IAAI,CAACG,OAAO,CAAC,GAAG,MAAM;QACtB,IAAI,CAACH,QAAQ,CAAC,CAAC,CAAC;QAChB,IAAI,CAACyD,IAAI,CAAC7D,OAAO,CAAC;;QAElB;QACA,IAAI,IAAI,CAACO,OAAO,CAAC,KAAK,MAAM,EAAE,IAAI,CAACsD,IAAI,CAAC,MAAM,CAAC;;QAE/C;QACA,IAAI,IAAI,CAACtD,OAAO,CAAC,KAAK,MAAM,EAAE,IAAI,CAACsD,IAAI,CAAC,OAAO,CAAC;QAEhDL,WAAW,CAAC,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,IAAI,CAACjD,OAAO,CAAC,KAAK,MAAM,EAAE;MACnC,IAAI,CAAC6C,QAAQ,CAACI,WAAW,CAAC;IAC5B,CAAC,MAAM;MACL,IAAI,CAACE,IAAI,CAAC1D,OAAO,EAAE,MAAM,IAAI,CAACuC,IAAI,CAACvB,OAAO,EAAEqC,QAAQ,CAAC,CAAC;IACxD;IAEA,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEAgE,KAAKA,CAAE9C,OAAO,EAAEqC,QAAQ,EAAE;IACxB,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEAU,KAAKA,CAAEV,QAAQ,EAAE;IACfA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAE3C,MAAMkE,WAAW,GAAIP,GAAG,IAAK;MAC3B,IAAI,IAAI,CAAClD,OAAO,CAAC,KAAK,SAAS,IAAI,IAAI,CAACA,OAAO,CAAC,KAAK,SAAS,EAAE;QAC9D;QACA,IAAI,CAACmD,IAAI,CAAC1D,OAAO,EAAEyD,GAAG,GAAGO,WAAW,CAACP,GAAG,CAAC,GAAGO,WAAW,CAAC;MAC1D,CAAC,MAAM,IAAI,IAAI,CAACzD,OAAO,CAAC,KAAK,QAAQ,EAAE;QACrC8C,QAAQ,CAAC,IAAIlE,WAAW,CAAC,wBAAwB,EAAE;UACjDwE,IAAI,EAAE,2BAA2B;UACjCC,KAAK,EAAEH;QACT,CAAC,CAAC,CAAC;MACL,CAAC,MAAM;QACLJ,QAAQ,CAAC,CAAC;MACZ;IACF,CAAC;IAED,IAAI,IAAI,CAAC9C,OAAO,CAAC,KAAK,MAAM,EAAE;MAC5B,IAAI,CAACA,OAAO,CAAC,GAAG,SAAS;MACzB,IAAI,CAACsD,IAAI,CAAC,SAAS,CAAC;MAEpB,MAAMI,MAAM,GAAIR,GAAG,IAAK;QACtB,IAAI,CAAClD,OAAO,CAAC,GAAG,MAAM;QACtB,IAAI,CAACH,QAAQ,CAAC,CAAC,CAAC;QAChB,IAAI,CAACyD,IAAI,CAAC7D,OAAO,CAAC;QAClBgE,WAAW,CAACP,GAAG,CAAC;MAClB,CAAC;MAED,IAAI,CAACvD,eAAe,CAAC,CAAC,MAAM;QAC1B,IAAI,CAACgE,MAAM,CAAET,GAAG,IAAK;UACnB,IAAIA,GAAG,EAAE,OAAOQ,MAAM,CAACR,GAAG,CAAC;UAE3B,IAAI,CAAClD,OAAO,CAAC,GAAG,QAAQ;UACxB,IAAI,CAACH,QAAQ,CAAC,CAAC,CAAC;UAChB,IAAI,CAACyD,IAAI,CAAC7D,OAAO,CAAC;;UAElB;UACA,IAAI,IAAI,CAACO,OAAO,CAAC,KAAK,QAAQ,EAAE,IAAI,CAACsD,IAAI,CAAC,QAAQ,CAAC;UAEnDG,WAAW,CAAC,CAAC;QACf,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,IAAI,CAACzD,OAAO,CAAC,KAAK,QAAQ,EAAE;MACrC,IAAI,CAAC6C,QAAQ,CAACY,WAAW,CAAC;IAC5B,CAAC,MAAM;MACL,IAAI,CAACN,IAAI,CAAC1D,OAAO,EAAE,MAAM,IAAI,CAAC+D,KAAK,CAACV,QAAQ,CAAC,CAAC;IAChD;IAEA,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEA,CAACI,eAAe,EAAGmD,QAAQ,EAAE;IAC3B,IAAI,IAAI,CAACpD,UAAU,CAAC,CAACkE,IAAI,KAAK,CAAC,EAAE;MAC/B,OAAO,IAAI,CAACf,QAAQ,CAACC,QAAQ,CAAC;IAChC;IAEA,IAAIe,OAAO,GAAG,IAAI,CAACnE,UAAU,CAAC,CAACkE,IAAI;IACnC,IAAIE,IAAI,GAAG,IAAI;IAEf,MAAMC,IAAI,GAAGA,CAAA,KAAM;MACjB,IAAI,EAAEF,OAAO,KAAK,CAAC,EAAE;QACnB;QACA,IAAIC,IAAI,EAAE,IAAI,CAACjB,QAAQ,CAACC,QAAQ,CAAC,MAC5BA,QAAQ,CAAC,CAAC;MACjB;IACF,CAAC;;IAED;IACA,KAAK,MAAMkB,QAAQ,IAAI,IAAI,CAACtE,UAAU,CAAC,EAAE;MACvCsE,QAAQ,CAACR,KAAK,CAACO,IAAI,CAAC;IACtB;IAEAD,IAAI,GAAG,KAAK;IACZ,IAAI,CAACpE,UAAU,CAAC,CAACwB,KAAK,CAAC,CAAC;EAC1B;EAEAyC,MAAMA,CAAEb,QAAQ,EAAE;IAChB,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEAmB,GAAGA,CAAErB,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,EAAE;IAC3BA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAAC0C,KAAK,CAAC;IAE1D,IAAI,IAAI,CAAC3C,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAACD,GAAG,CAACrB,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MAClD,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAM2D,GAAG,GAAG,IAAI,CAACkB,SAAS,CAACxB,GAAG,CAAC;IAE/B,IAAIM,GAAG,EAAE;MACP,IAAI,CAACL,QAAQ,CAACC,QAAQ,EAAEI,GAAG,CAAC;MAC5B,OAAOJ,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAMoB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,CAACE,WAAW,CAAC;IACzD,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,CAACG,aAAa,CAAC;IAC/D,MAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAAM;IACpC,MAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAM;;IAExC;IACA,IAAI7D,OAAO,CAACE,WAAW,KAAK0D,SAAS,IAAI5D,OAAO,CAACG,aAAa,KAAK2D,WAAW,EAAE;MAC9E;MACA9D,OAAO,GAAGoB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAErB,OAAO,EAAE;QAAEE,WAAW,EAAE0D,SAAS;QAAEzD,aAAa,EAAE2D;MAAY,CAAC,CAAC;IAC9F;IAEA,IAAI,CAACC,IAAI,CAAC,IAAI,CAACC,SAAS,CAAC9D,WAAW,CAAC+D,MAAM,CAAC9B,GAAG,CAAC,EAAEyB,SAAS,CAAC,EAAE5D,OAAO,EAAE,CAACyC,GAAG,EAAEyB,KAAK,KAAK;MACrF,IAAIzB,GAAG,EAAE;QACP;QACA,IAAIA,GAAG,CAACE,IAAI,KAAK,iBAAiB,IAAIF,GAAG,CAAC0B,QAAQ,IAAI,WAAW,CAACC,IAAI,CAAC3B,GAAG,CAAC,EAAE;UAC3E,IAAI,CAACA,GAAG,CAACE,IAAI,EAAEF,GAAG,CAACE,IAAI,GAAG,iBAAiB,EAAC;UAC5C,IAAI,CAACF,GAAG,CAAC0B,QAAQ,EAAE1B,GAAG,CAAC0B,QAAQ,GAAG,IAAI,EAAC;UACvC,IAAI,CAAC1B,GAAG,CAAClC,MAAM,EAAEkC,GAAG,CAAClC,MAAM,GAAG,GAAG,EAAC;QACpC;;QAEA,OAAO8B,QAAQ,CAACI,GAAG,CAAC;MACtB;MAEA,IAAI;QACFyB,KAAK,GAAG/D,aAAa,CAACkE,MAAM,CAACH,KAAK,CAAC;MACrC,CAAC,CAAC,OAAOzB,GAAG,EAAE;QACZ,OAAOJ,QAAQ,CAAC,IAAIlE,WAAW,CAAC,wBAAwB,EAAE;UACxDwE,IAAI,EAAE,oBAAoB;UAC1BC,KAAK,EAAEH;QACT,CAAC,CAAC,CAAC;MACL;MAEAJ,QAAQ,CAAC,IAAI,EAAE6B,KAAK,CAAC;IACvB,CAAC,CAAC;IAEF,OAAO7B,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEAiF,IAAIA,CAAE5B,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,EAAE;IAC5B,IAAI,CAACD,QAAQ,CAACC,QAAQ,EAAE,IAAIiC,KAAK,CAAC,UAAU,CAAC,CAAC;EAChD;EAEA5D,OAAOA,CAAE6D,IAAI,EAAEvE,OAAO,EAAEqC,QAAQ,EAAE;IAChCA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAAC0C,KAAK,CAAC;IAE1D,IAAI,IAAI,CAAC3C,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAAC/C,OAAO,CAAC6D,IAAI,EAAEvE,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MACvD,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI,CAAC0F,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;MACxB,IAAI,CAACnC,QAAQ,CAACC,QAAQ,EAAE,IAAIpC,SAAS,CAAC,4CAA4C,CAAC,CAAC;MACpF,OAAOoC,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAIyF,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,IAAI,CAACtC,QAAQ,CAACC,QAAQ,EAAE,IAAI,EAAE,EAAE,CAAC;MACjC,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAMoB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,CAACE,WAAW,CAAC;IACzD,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,CAACG,aAAa,CAAC;IAC/D,MAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAAM;IACpC,MAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAM;;IAExC;IACA,IAAI7D,OAAO,CAACE,WAAW,KAAK0D,SAAS,IAAI5D,OAAO,CAACG,aAAa,KAAK2D,WAAW,EAAE;MAC9E9D,OAAO,GAAGoB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAErB,OAAO,EAAE;QAAEE,WAAW,EAAE0D,SAAS;QAAEzD,aAAa,EAAE2D;MAAY,CAAC,CAAC;IAC9F;IAEA,MAAMa,UAAU,GAAG,IAAIH,KAAK,CAACD,IAAI,CAACG,MAAM,CAAC;IAEzC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACG,MAAM,EAAEE,CAAC,EAAE,EAAE;MACpC,MAAMzC,GAAG,GAAGoC,IAAI,CAACK,CAAC,CAAC;MACnB,MAAMnC,GAAG,GAAG,IAAI,CAACkB,SAAS,CAACxB,GAAG,CAAC;MAE/B,IAAIM,GAAG,EAAE;QACP,IAAI,CAACL,QAAQ,CAACC,QAAQ,EAAEI,GAAG,CAAC;QAC5B,OAAOJ,QAAQ,CAACvD,QAAQ,CAAC;MAC3B;MAEA6F,UAAU,CAACC,CAAC,CAAC,GAAG,IAAI,CAACZ,SAAS,CAAC9D,WAAW,CAAC+D,MAAM,CAAC9B,GAAG,CAAC,EAAEyB,SAAS,CAAC;IACpE;IAEA,IAAI,CAACiB,QAAQ,CAACF,UAAU,EAAE3E,OAAO,EAAE,CAACyC,GAAG,EAAEqC,MAAM,KAAK;MAClD,IAAIrC,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;MAE7B,IAAI;QACF,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACJ,MAAM,EAAEE,CAAC,EAAE,EAAE;UACtC,IAAIE,MAAM,CAACF,CAAC,CAAC,KAAKG,SAAS,EAAE;YAC3BD,MAAM,CAACF,CAAC,CAAC,GAAGzE,aAAa,CAACkE,MAAM,CAACS,MAAM,CAACF,CAAC,CAAC,CAAC;UAC7C;QACF;MACF,CAAC,CAAC,OAAOnC,GAAG,EAAE;QACZ,OAAOJ,QAAQ,CAAC,IAAIlE,WAAW,CAAE,mCAAkC2G,MAAM,CAACJ,MAAO,WAAU,EAAE;UAC3F/B,IAAI,EAAE,oBAAoB;UAC1BC,KAAK,EAAEH;QACT,CAAC,CAAC,CAAC;MACL;MAEAJ,QAAQ,CAAC,IAAI,EAAEyC,MAAM,CAAC;IACxB,CAAC,CAAC;IAEF,OAAOzC,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEA+F,QAAQA,CAAEN,IAAI,EAAEvE,OAAO,EAAEqC,QAAQ,EAAE;IACjC,IAAI,CAACD,QAAQ,CAACC,QAAQ,EAAE,IAAI,EAAE,IAAImC,KAAK,CAACD,IAAI,CAACG,MAAM,CAAC,CAACM,IAAI,CAACD,SAAS,CAAC,CAAC;EACvE;EAEArD,GAAGA,CAAES,GAAG,EAAE+B,KAAK,EAAElE,OAAO,EAAEqC,QAAQ,EAAE;IAClCA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAAC0C,KAAK,CAAC;IAE1D,IAAI,IAAI,CAAC3C,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAAC/B,GAAG,CAACS,GAAG,EAAE+B,KAAK,EAAElE,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MACzD,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAM2D,GAAG,GAAG,IAAI,CAACkB,SAAS,CAACxB,GAAG,CAAC,IAAI,IAAI,CAAC8C,WAAW,CAACf,KAAK,CAAC;IAE1D,IAAIzB,GAAG,EAAE;MACP,IAAI,CAACL,QAAQ,CAACC,QAAQ,EAAEI,GAAG,CAAC;MAC5B,OAAOJ,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAMoB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,CAACE,WAAW,CAAC;IACzD,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,CAACG,aAAa,CAAC;IAC/D,MAAMyD,SAAS,GAAG1D,WAAW,CAAC2D,MAAM;IACpC,MAAMC,WAAW,GAAG3D,aAAa,CAAC0D,MAAM;;IAExC;IACA,IAAI7D,OAAO,CAACE,WAAW,KAAK0D,SAAS,IAAI5D,OAAO,CAACG,aAAa,KAAK2D,WAAW,EAAE;MAC9E9D,OAAO,GAAGoB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAErB,OAAO,EAAE;QAAEE,WAAW,EAAE0D,SAAS;QAAEzD,aAAa,EAAE2D;MAAY,CAAC,CAAC;IAC9F;IAEA,MAAMoB,SAAS,GAAG,IAAI,CAAClB,SAAS,CAAC9D,WAAW,CAAC+D,MAAM,CAAC9B,GAAG,CAAC,EAAEyB,SAAS,CAAC;IACpE,MAAMuB,WAAW,GAAGhF,aAAa,CAAC8D,MAAM,CAACC,KAAK,CAAC;IAE/C,IAAI,CAACkB,IAAI,CAACF,SAAS,EAAEC,WAAW,EAAEnF,OAAO,EAAGyC,GAAG,IAAK;MAClD,IAAIA,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;MAC7B,IAAI,CAACI,IAAI,CAAC,KAAK,EAAEV,GAAG,EAAE+B,KAAK,CAAC;MAC5B7B,QAAQ,CAAC,CAAC;IACZ,CAAC,CAAC;IAEF,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEAsG,IAAIA,CAAEjD,GAAG,EAAE+B,KAAK,EAAElE,OAAO,EAAEqC,QAAQ,EAAE;IACnC,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEAV,GAAGA,CAAEQ,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,EAAE;IAC3BA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAAC2C,GAAG,CAAC;IAExD,IAAI,IAAI,CAAC5C,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAAC9B,GAAG,CAACQ,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MAClD,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAM2D,GAAG,GAAG,IAAI,CAACkB,SAAS,CAACxB,GAAG,CAAC;IAE/B,IAAIM,GAAG,EAAE;MACP,IAAI,CAACL,QAAQ,CAACC,QAAQ,EAAEI,GAAG,CAAC;MAC5B,OAAOJ,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAMoB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,CAACE,WAAW,CAAC;IACzD,MAAM0D,SAAS,GAAG1D,WAAW,CAAC2D,MAAM;;IAEpC;IACA,IAAI7D,OAAO,CAACE,WAAW,KAAK0D,SAAS,EAAE;MACrC5D,OAAO,GAAGoB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAErB,OAAO,EAAE;QAAEE,WAAW,EAAE0D;MAAU,CAAC,CAAC;IAClE;IAEA,IAAI,CAACyB,IAAI,CAAC,IAAI,CAACrB,SAAS,CAAC9D,WAAW,CAAC+D,MAAM,CAAC9B,GAAG,CAAC,EAAEyB,SAAS,CAAC,EAAE5D,OAAO,EAAGyC,GAAG,IAAK;MAC9E,IAAIA,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;MAC7B,IAAI,CAACI,IAAI,CAAC,KAAK,EAAEV,GAAG,CAAC;MACrBE,QAAQ,CAAC,CAAC;IACZ,CAAC,CAAC;IAEF,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEAuG,IAAIA,CAAElD,GAAG,EAAEnC,OAAO,EAAEqC,QAAQ,EAAE;IAC5B,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEAT,KAAKA,CAAE0D,UAAU,EAAEtF,OAAO,EAAEqC,QAAQ,EAAE;IACpC,IAAI,CAACkD,SAAS,CAACb,MAAM,EAAE;MACrB,IAAI,IAAI,CAACnF,OAAO,CAAC,KAAK,SAAS,EAAE,OAAO,IAAIb,mBAAmB,CAAC,IAAI,CAAC;MACrE,IAAI,IAAI,CAACa,OAAO,CAAC,KAAK,MAAM,EAAE;QAC5B,MAAM,IAAIpB,WAAW,CAAC,sBAAsB,EAAE;UAC5CwE,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;MACA,OAAO,IAAI,CAAC6C,aAAa,CAAC,CAAC;IAC7B;IAEA,IAAI,OAAOF,UAAU,KAAK,UAAU,EAAEjD,QAAQ,GAAGiD,UAAU,MACtDjD,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IAE9CA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAACwC,KAAK,CAAC;IAE1D,IAAI,IAAI,CAACzC,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAAC7B,KAAK,CAAC0D,UAAU,EAAEtF,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MAC3D,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI,CAAC0F,KAAK,CAACC,OAAO,CAACa,UAAU,CAAC,EAAE;MAC9B,IAAI,CAAClD,QAAQ,CAACC,QAAQ,EAAE,IAAIpC,SAAS,CAAC,kDAAkD,CAAC,CAAC;MAC1F,OAAOoC,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAIwG,UAAU,CAACZ,MAAM,KAAK,CAAC,EAAE;MAC3B,IAAI,CAACtC,QAAQ,CAACC,QAAQ,CAAC;MACvB,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAM2G,MAAM,GAAG,IAAIjB,KAAK,CAACc,UAAU,CAACZ,MAAM,CAAC;IAC3C,MAAM;MAAExE,WAAW,EAAEwF,EAAE;MAAEvF,aAAa,EAAEwF,EAAE;MAAE,GAAGtF;IAAQ,CAAC,GAAGL,OAAO;IAElE,KAAK,IAAI4E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,UAAU,CAACZ,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC1C,IAAI,OAAOU,UAAU,CAACV,CAAC,CAAC,KAAK,QAAQ,IAAIU,UAAU,CAACV,CAAC,CAAC,KAAK,IAAI,EAAE;QAC/D,IAAI,CAACxC,QAAQ,CAACC,QAAQ,EAAE,IAAIpC,SAAS,CAAC,qCAAqC,CAAC,CAAC;QAC7E,OAAOoC,QAAQ,CAACvD,QAAQ,CAAC;MAC3B;MAEA,MAAM8G,EAAE,GAAGxE,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEiE,UAAU,CAACV,CAAC,CAAC,CAAC;MAE3C,IAAIgB,EAAE,CAACC,IAAI,KAAK,KAAK,IAAID,EAAE,CAACC,IAAI,KAAK,KAAK,EAAE;QAC1C,IAAI,CAACzD,QAAQ,CAACC,QAAQ,EAAE,IAAIpC,SAAS,CAAC,oEAAoE,CAAC,CAAC;QAC5G,OAAOoC,QAAQ,CAACvD,QAAQ,CAAC;MAC3B;MAEA,MAAM2D,GAAG,GAAG,IAAI,CAACkB,SAAS,CAACiC,EAAE,CAACzD,GAAG,CAAC;MAElC,IAAIM,GAAG,EAAE;QACP,IAAI,CAACL,QAAQ,CAACC,QAAQ,EAAEI,GAAG,CAAC;QAC5B,OAAOJ,QAAQ,CAACvD,QAAQ,CAAC;MAC3B;MAEA,MAAMgH,EAAE,GAAGF,EAAE,CAACG,QAAQ,IAAI,IAAI,GAAGH,EAAE,CAACG,QAAQ,GAAG,IAAI;MACnD,MAAM7F,WAAW,GAAG4F,EAAE,CAAC5F,WAAW,CAAC0F,EAAE,CAAC1F,WAAW,IAAIwF,EAAE,CAAC;MACxD,MAAM9B,SAAS,GAAG1D,WAAW,CAAC2D,MAAM;MAEpC+B,EAAE,CAACzD,GAAG,GAAG2D,EAAE,CAAC9B,SAAS,CAAC9D,WAAW,CAAC+D,MAAM,CAAC2B,EAAE,CAACzD,GAAG,CAAC,EAAEyB,SAAS,CAAC;MAC5DgC,EAAE,CAAC1F,WAAW,GAAG0D,SAAS;MAE1B,IAAIgC,EAAE,CAACC,IAAI,KAAK,KAAK,EAAE;QACrB,MAAMG,QAAQ,GAAG,IAAI,CAACf,WAAW,CAACW,EAAE,CAAC1B,KAAK,CAAC;QAE3C,IAAI8B,QAAQ,EAAE;UACZ,IAAI,CAAC5D,QAAQ,CAACC,QAAQ,EAAE2D,QAAQ,CAAC;UACjC,OAAO3D,QAAQ,CAACvD,QAAQ,CAAC;QAC3B;QAEA,MAAMqB,aAAa,GAAG2F,EAAE,CAAC3F,aAAa,CAACyF,EAAE,CAACzF,aAAa,IAAIwF,EAAE,CAAC;QAE9DC,EAAE,CAAC1B,KAAK,GAAG/D,aAAa,CAAC8D,MAAM,CAAC2B,EAAE,CAAC1B,KAAK,CAAC;QACzC0B,EAAE,CAACzF,aAAa,GAAGA,aAAa,CAAC0D,MAAM;MACzC;;MAEA;MACA,IAAIiC,EAAE,KAAK,IAAI,EAAE;QACfF,EAAE,CAACG,QAAQ,GAAG,IAAI;MACpB;MAEAN,MAAM,CAACb,CAAC,CAAC,GAAGgB,EAAE;IAChB;IAEA,IAAI,CAACK,MAAM,CAACR,MAAM,EAAEpF,OAAO,EAAGoC,GAAG,IAAK;MACpC,IAAIA,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;MAC7B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEyC,UAAU,CAAC;MAC9BjD,QAAQ,CAAC,CAAC;IACZ,CAAC,CAAC;IAEF,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEAmH,MAAMA,CAAEX,UAAU,EAAEtF,OAAO,EAAEqC,QAAQ,EAAE;IACrC,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEA0D,QAAQA,CAAEG,IAAI,EAAElG,OAAO,EAAE;IACvB,OAAO,IAAI,CAACmG,SAAS,CAACD,IAAI,EAAEE,gBAAgB,CAACC,QAAQ,CAACrG,OAAO,CAAC,CAAC;EACjE;EAEAmG,SAASA,CAAED,IAAI,EAAElG,OAAO,EAAE;IACxB,OAAO,IAAIoG,gBAAgB,CAAC,IAAI,EAAEF,IAAI,EAAElG,OAAO,CAAC;EAClD;EAEAgE,SAASA,CAAE7B,GAAG,EAAEyB,SAAS,EAAE;IACzB,OAAOzB,GAAG;EACZ;EAEA1B,KAAKA,CAAET,OAAO,EAAEqC,QAAQ,EAAE;IACxBA,QAAQ,GAAG1D,WAAW,CAACqB,OAAO,EAAEqC,QAAQ,CAAC;IACzCA,QAAQ,GAAGnE,YAAY,CAACmE,QAAQ,EAAEvD,QAAQ,CAAC;IAC3CkB,OAAO,GAAGpB,UAAU,CAACoB,OAAO,EAAE,IAAI,CAACR,eAAe,CAAC,CAACwC,KAAK,CAAC;IAE1D,IAAI,IAAI,CAACzC,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,IAAI,CAACkE,KAAK,CAAC,MAAM,IAAI,CAAChD,KAAK,CAACT,OAAO,EAAEqC,QAAQ,CAAC,CAAC;MAC/C,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,IAAI4E,UAAU,CAAC,IAAI,EAAErB,QAAQ,CAAC,EAAE;MAC9B,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;IAC3B;IAEA,MAAMwH,QAAQ,GAAGtG,OAAO;IACxB,MAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,CAACE,WAAW,CAAC;IAEzDF,OAAO,GAAGnB,YAAY,CAACmB,OAAO,EAAEE,WAAW,CAAC;IAC5CF,OAAO,CAACE,WAAW,GAAGA,WAAW,CAAC2D,MAAM;IAExC,IAAI7D,OAAO,CAACuG,KAAK,KAAK,CAAC,EAAE;MACvB,IAAI,CAACnE,QAAQ,CAACC,QAAQ,CAAC;IACzB,CAAC,MAAM;MACL,IAAI,CAACmE,MAAM,CAACxG,OAAO,EAAGyC,GAAG,IAAK;QAC5B,IAAIA,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;QAC7B,IAAI,CAACI,IAAI,CAAC,OAAO,EAAEyD,QAAQ,CAAC;QAC5BjE,QAAQ,CAAC,CAAC;MACZ,CAAC,CAAC;IACJ;IAEA,OAAOA,QAAQ,CAACvD,QAAQ,CAAC;EAC3B;EAEA0H,MAAMA,CAAExG,OAAO,EAAEqC,QAAQ,EAAE;IACzB,IAAI,CAACD,QAAQ,CAACC,QAAQ,CAAC;EACzB;EAEAoE,QAAQA,CAAEzG,OAAO,EAAE;IACjB,MAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,IAAIA,OAAO,CAACE,WAAW,CAAC;IACpE,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,IAAIA,OAAO,CAACG,aAAa,CAAC;IAE1EH,OAAO,GAAGnB,YAAY,CAACmB,OAAO,EAAEE,WAAW,CAAC;IAC5CF,OAAO,CAACuE,IAAI,GAAGvE,OAAO,CAACuE,IAAI,KAAK,KAAK;IACrCvE,OAAO,CAAC8E,MAAM,GAAG9E,OAAO,CAAC8E,MAAM,KAAK,KAAK;;IAEzC;IACA9E,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAW,CAAC,GAAGA,WAAW;IACnDF,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAa,CAAC,GAAGA,aAAa;;IAEvD;IACAH,OAAO,CAACE,WAAW,GAAGA,WAAW,CAAC2D,MAAM;IACxC7D,OAAO,CAACG,aAAa,GAAGA,aAAa,CAAC0D,MAAM;IAE5C,IAAI,IAAI,CAACtE,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,OAAO,IAAIhB,gBAAgB,CAAC,IAAI,EAAEyB,OAAO,CAAC;IAC5C,CAAC,MAAM,IAAI,IAAI,CAACT,OAAO,CAAC,KAAK,MAAM,EAAE;MACnC,MAAM,IAAIpB,WAAW,CAAC,sBAAsB,EAAE;QAC5CwE,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;IAEA,OAAO,IAAI,CAAC+D,SAAS,CAAC1G,OAAO,CAAC;EAChC;EAEA0G,SAASA,CAAE1G,OAAO,EAAE;IAClB,OAAO,IAAI5B,gBAAgB,CAAC,IAAI,EAAE4B,OAAO,CAAC;EAC5C;EAEAuE,IAAIA,CAAEvE,OAAO,EAAE;IACb;IACA,MAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,IAAIA,OAAO,CAACE,WAAW,CAAC;IACpE,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,IAAIA,OAAO,CAACG,aAAa,CAAC;IAE1EH,OAAO,GAAGnB,YAAY,CAACmB,OAAO,EAAEE,WAAW,CAAC;;IAE5C;IACAF,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAW,CAAC,GAAGA,WAAW;IACnDF,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAa,CAAC,GAAGA,aAAa;;IAEvD;IACAH,OAAO,CAACE,WAAW,GAAGA,WAAW,CAAC2D,MAAM;IACxC7D,OAAO,CAACG,aAAa,GAAGA,aAAa,CAAC0D,MAAM;IAE5C,IAAI,IAAI,CAACtE,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,OAAO,IAAIf,mBAAmB,CAAC,IAAI,EAAEwB,OAAO,CAAC;IAC/C,CAAC,MAAM,IAAI,IAAI,CAACT,OAAO,CAAC,KAAK,MAAM,EAAE;MACnC,MAAM,IAAIpB,WAAW,CAAC,sBAAsB,EAAE;QAC5CwE,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;IAEA,OAAO,IAAI,CAACgE,KAAK,CAAC3G,OAAO,CAAC;EAC5B;EAEA2G,KAAKA,CAAE3G,OAAO,EAAE;IACd,OAAO,IAAI3B,kBAAkB,CAAC,IAAI,EAAE2B,OAAO,CAAC;EAC9C;EAEA8E,MAAMA,CAAE9E,OAAO,EAAE;IACf,MAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,OAAO,IAAIA,OAAO,CAACE,WAAW,CAAC;IACpE,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACH,OAAO,IAAIA,OAAO,CAACG,aAAa,CAAC;IAE1EH,OAAO,GAAGnB,YAAY,CAACmB,OAAO,EAAEE,WAAW,CAAC;;IAE5C;IACAF,OAAO,CAAC5B,gBAAgB,CAAC8B,WAAW,CAAC,GAAGA,WAAW;IACnDF,OAAO,CAAC5B,gBAAgB,CAAC+B,aAAa,CAAC,GAAGA,aAAa;;IAEvD;IACAH,OAAO,CAACE,WAAW,GAAGA,WAAW,CAAC2D,MAAM;IACxC7D,OAAO,CAACG,aAAa,GAAGA,aAAa,CAAC0D,MAAM;IAE5C,IAAI,IAAI,CAACtE,OAAO,CAAC,KAAK,SAAS,EAAE;MAC/B,OAAO,IAAId,qBAAqB,CAAC,IAAI,EAAEuB,OAAO,CAAC;IACjD,CAAC,MAAM,IAAI,IAAI,CAACT,OAAO,CAAC,KAAK,MAAM,EAAE;MACnC,MAAM,IAAIpB,WAAW,CAAC,sBAAsB,EAAE;QAC5CwE,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;IAEA,OAAO,IAAI,CAACiE,OAAO,CAAC5G,OAAO,CAAC;EAC9B;EAEA4G,OAAOA,CAAE5G,OAAO,EAAE;IAChB,OAAO,IAAI1B,oBAAoB,CAAC,IAAI,EAAE0B,OAAO,CAAC;EAChD;EAEAyD,KAAKA,CAAEoD,EAAE,EAAE;IACT,IAAI,OAAOA,EAAE,KAAK,UAAU,EAAE;MAC5B,MAAM,IAAI5G,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAI,CAACd,WAAW,CAAC,CAAC2H,IAAI,CAACD,EAAE,CAAC;EAC5B;EAEA,CAACzH,QAAQ,IAAK;IACZ,IAAI,IAAI,CAACD,WAAW,CAAC,CAACuF,MAAM,KAAK,CAAC,EAAE;MAClC;IACF;IAEA,MAAMY,UAAU,GAAG,IAAI,CAACnG,WAAW,CAAC;IACpC,IAAI,CAACA,WAAW,CAAC,GAAG,EAAE;IAEtB,KAAK,MAAMyG,EAAE,IAAIN,UAAU,EAAE;MAC3BM,EAAE,CAAC,CAAC;IACN;EACF;;EAEA;EACAmB,cAAcA,CAAExD,QAAQ,EAAE;IACxB,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,IAAI,IACnD,OAAOA,QAAQ,CAACR,KAAK,KAAK,UAAU,EAAE;MACtC,MAAM,IAAI9C,SAAS,CAAC,8CAA8C,CAAC;IACrE;IAEA,IAAI,CAAChB,UAAU,CAAC,CAAC+H,GAAG,CAACzD,QAAQ,CAAC;EAChC;;EAEA;EACA0D,cAAcA,CAAE1D,QAAQ,EAAE;IACxB,IAAI,CAACtE,UAAU,CAAC,CAACiI,MAAM,CAAC3D,QAAQ,CAAC;EACnC;EAEAiC,aAAaA,CAAA,EAAI;IACf,OAAO,IAAI9G,mBAAmB,CAAC,IAAI,CAAC;EACtC;EAEAiF,SAASA,CAAExB,GAAG,EAAE;IACd,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK4C,SAAS,EAAE;MACrC,OAAO,IAAI5G,WAAW,CAAC,iCAAiC,EAAE;QACxDwE,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;EAEAsC,WAAWA,CAAEf,KAAK,EAAE;IAClB,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE;MACzC,OAAO,IAAI5G,WAAW,CAAC,mCAAmC,EAAE;QAC1DwE,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;AACF;;AAEA;AACA;AACA9C,aAAa,CAACsH,SAAS,CAAC/E,QAAQ,GAAGtE,OAAO,CAAC,iBAAiB,CAAC;AAE7D,MAAM;EAAEsI;AAAiB,CAAC,GAAGtI,OAAO,CAAC,yBAAyB,CAAC,CAAC;EAAE+B;AAAc,CAAC,CAAC;AAElFuH,OAAO,CAACvH,aAAa,GAAGA,aAAa;AACrCuH,OAAO,CAAChB,gBAAgB,GAAGA,gBAAgB;AAE3C,MAAM1C,UAAU,GAAG,SAAAA,CAAUoC,EAAE,EAAEzD,QAAQ,EAAE;EACzC,IAAIyD,EAAE,CAACvG,OAAO,CAAC,KAAK,MAAM,EAAE;IAC1BuG,EAAE,CAAC1D,QAAQ,CAACC,QAAQ,EAAE,IAAIlE,WAAW,CAAC,sBAAsB,EAAE;MAC5DwE,IAAI,EAAE;IACR,CAAC,CAAC,CAAC;IACH,OAAO,IAAI;EACb;EAEA,OAAO,KAAK;AACd,CAAC;AAED,MAAMd,OAAO,GAAG,SAAAA,CAAUiE,EAAE,EAAE;EAC5B,OAAO1E,MAAM,CAACmD,IAAI,CAACuB,EAAE,CAAC/H,QAAQ,CAACmD,SAAS,CAAC,CACtCmG,MAAM,CAACC,CAAC,IAAI,CAAC,CAACxB,EAAE,CAAC/H,QAAQ,CAACmD,SAAS,CAACoG,CAAC,CAAC,CAAC;AAC5C,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}