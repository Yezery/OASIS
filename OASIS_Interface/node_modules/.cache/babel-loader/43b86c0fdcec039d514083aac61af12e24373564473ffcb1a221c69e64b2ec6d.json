{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { notFoundError } from 'datastore-core/errors';\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';\nimport { CID } from 'multiformats/cid';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nconst ERR_NOT_FOUND = notFoundError().code;\nexport const Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nexport function createRefs({\n  repo,\n  codecs,\n  resolve,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  async function* refs(ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return;\n    }\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n    options.format = options.edges ? Format.edges : options.format;\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout);\n      const signals = [controller.signal];\n      if (options.signal) {\n        signals.push(options.signal);\n      }\n      options.signal = anySignal(signals);\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch ( /** @type {any} */err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n  return refs;\n}\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath);\n  if (options.preload !== false) {\n    preload(cid);\n  }\n  return `/ipfs/${cid}${path || ''}`;\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options);\n  const {\n    cid\n  } = toCidAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false;\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue;\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1;\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return;\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch ( /** @type {any} */err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n      throw err;\n    }\n  }\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPB.code;\n  /** @type {Array<string|number>} */\n  const base = [];\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n      if (match) {\n        const index = Number(match[1]);\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n    yield {\n      name,\n      cid\n    };\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n  if (source instanceof Uint8Array) {\n    return;\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element);\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return [];\n};","map":{"version":3,"names":["dagPB","notFoundError","toCidAndPath","CID","TimeoutController","anySignal","ERR_NOT_FOUND","code","Format","default","edges","createRefs","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","signals","signal","push","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","err","ref","message","cid","resPath","unique","obj","objectStream","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","block","blocks","get","codec","getCodec","value","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/refs/index.js"],"sourcesContent":["import * as dagPB from '@ipld/dag-pb'\nimport { notFoundError } from 'datastore-core/errors'\nimport { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path'\nimport { CID } from 'multiformats/cid'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\n\nconst ERR_NOT_FOUND = notFoundError().code\n\nexport const Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nexport function createRefs ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API<{}>[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n      const signals = [controller.signal]\n\n      if (options.signal) {\n        signals.push(options.signal)\n      }\n\n      options.signal = anySignal(signals)\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (/** @type {any} */ err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API<{}>[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCidAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPB.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}