{"ast":null,"code":"import NanoDate from 'timestamp-nano';\nimport { Key } from 'interface-datastore/key';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errCode from 'err-code';\nimport { base32upper } from 'multiformats/bases/base32';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { logger } from '@libp2p/logger';\nimport { createCborData, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { IpnsEntry } from './pb/ipns.js';\nconst log = logger('ipns');\nconst ID_MULTIHASH_CODE = identity.code;\nexport const namespace = '/ipns/';\nexport const namespaceLength = namespace.length;\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PeerId} peerId - peer id containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nexport const create = async (peerId, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime));\n  const validityType = IpnsEntry.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns ?? '0');\n  return await _create(peerId, value, seq, validityType, expirationDate, lifetimeNs);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PeerId} peerId - PeerId containing private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nexport const createWithExpiration = async (peerId, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration);\n  const validityType = IpnsEntry.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());\n  return await _create(peerId, value, seq, validityType, expirationDate, ttlNs);\n};\nconst _create = async (peerId, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq);\n  const isoValidity = uint8ArrayFromString(expirationDate.toString());\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Missing private key'), ERRORS.ERR_MISSING_PRIVATE_KEY);\n  }\n  const privateKey = await unmarshalPrivateKey(peerId.privateKey);\n  const signatureV1 = await signLegacyV1(privateKey, value, validityType, isoValidity);\n  const data = createCborData(value, isoValidity, validityType, seq, ttl);\n  const sigData = ipnsEntryDataForV2Sig(data);\n  const signatureV2 = await privateKey.sign(sigData);\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  };\n  // if we cannot derive the public key from the PeerId (e.g. RSA PeerIDs),\n  // we have to embed it in the IPNS record\n  if (peerId.publicKey != null) {\n    const digest = Digest.decode(peerId.toBytes());\n    if (digest.code !== ID_MULTIHASH_CODE || !uint8ArrayEquals(peerId.publicKey, digest.digest)) {\n      entry.pubKey = peerId.publicKey;\n    }\n  }\n  log('ipns entry for %b created', value);\n  return entry;\n};\n/**\n * rawStdEncoding with RFC4648\n */\nconst rawStdEncoding = key => base32upper.encode(key).slice(1);\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nexport const getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\nexport { unmarshal } from './utils.js';\nexport { marshal } from './utils.js';\nexport { peerIdToRoutingKey } from './utils.js';\nexport { peerIdFromRoutingKey } from './utils.js';\n/**\n * Sign ipns record data using the legacy V1 signature scheme\n */\nconst signLegacyV1 = async (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return await privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed', error);\n    throw errCode(new Error('record signature creation failed'), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n};","map":{"version":3,"names":["NanoDate","Key","unmarshalPrivateKey","errCode","base32upper","fromString","uint8ArrayFromString","logger","createCborData","ipnsEntryDataForV1Sig","ipnsEntryDataForV2Sig","ERRORS","equals","uint8ArrayEquals","Digest","identity","IpnsEntry","log","ID_MULTIHASH_CODE","code","namespace","namespaceLength","length","create","peerId","value","seq","lifetime","expirationDate","Date","now","Number","validityType","ValidityType","EOL","ms","ns","toString","split","lifetimeNs","BigInt","_create","createWithExpiration","expiration","ttlMs","toDate","getTime","ttlNs","getNano","ttl","isoValidity","privateKey","Error","ERR_MISSING_PRIVATE_KEY","signatureV1","signLegacyV1","data","sigData","signatureV2","sign","entry","signature","validity","sequence","publicKey","digest","decode","toBytes","pubKey","rawStdEncoding","key","encode","slice","getLocalKey","unmarshal","marshal","peerIdToRoutingKey","peerIdFromRoutingKey","dataForSignature","error","ERR_SIGNATURE_CREATION"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}