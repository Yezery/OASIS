{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport debug from 'debug';\nimport { notFoundError } from 'datastore-core/errors';\nimport parallelBatch from 'it-parallel-batch';\nimport { pipe } from 'it-pipe';\nimport merge from 'it-merge';\nimport map from 'it-map';\nimport filter from 'it-filter';\nimport { Key } from 'interface-datastore/key';\nimport { base32 } from 'multiformats/bases/base32';\nimport { walkDag } from './utils/walk-dag.js';\nconst log = debug('ipfs:repo:gc');\nconst ERR_NOT_FOUND = notFoundError().code;\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nexport function gc({\n  gcLock,\n  pins,\n  blockstore,\n  root,\n  loadCodec\n}) {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      });\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({});\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield* deleteUnmarkedBlocks({\n        blockstore\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  }\n  return gc;\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet({\n  pins,\n  blockstore,\n  loadCodec,\n  root\n}) {\n  const mfsSource = async function* () {\n    let mh;\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch ( /** @type {any} */err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n      throw err;\n    }\n    const rootCid = CID.decode(mh);\n    yield rootCid;\n    yield* walkDag(rootCid, blockstore, loadCodec);\n  }();\n  const pinsSource = merge(map(pins.recursiveKeys(), ({\n    cid\n  }) => cid), pins.indirectKeys(), map(pins.directKeys(), ({\n    cid\n  }) => cid), mfsSource);\n  const output = new Set();\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes));\n  }\n  return output;\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function* deleteUnmarkedBlocks({\n  blockstore\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n      try {\n        const b32 = base32.encode(cid.multihash.bytes);\n        if (markedSet.has(b32)) {\n          return null;\n        }\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch ( /** @type {any} */err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          };\n        }\n        return {\n          cid\n        };\n      } catch ( /** @type {any} */err) {\n        const msg = `Could delete block with CID ${cid}`;\n        log(msg, err);\n        return {\n          err: new Error(msg + `: ${err.message}`)\n        };\n      }\n    };\n  };\n  yield* pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n  // filter nulls (blocks that were retained)\n  source => filter(source, Boolean));\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"names":["CID","debug","notFoundError","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","log","ERR_NOT_FOUND","code","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","gc","gcLock","pins","blockstore","root","loadCodec","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","remove","b32","has","delete","Error","message","msg","source","Boolean","size"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/gc.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport debug from 'debug'\nimport { notFoundError } from 'datastore-core/errors'\nimport parallelBatch from 'it-parallel-batch'\nimport { pipe } from 'it-pipe'\nimport merge from 'it-merge'\nimport map from 'it-map'\nimport filter from 'it-filter'\nimport { Key } from 'interface-datastore/key'\nimport { base32 } from 'multiformats/bases/base32'\nimport { walkDag } from './utils/walk-dag.js'\n\nconst log = debug('ipfs:repo:gc')\nconst ERR_NOT_FOUND = notFoundError().code\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./types').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nexport function gc ({ gcLock, pins, blockstore, root, loadCodec }) {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pin-manager').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (/** @type {any} */ err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (/** @type {any} */ err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (/** @type {any} */ err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}