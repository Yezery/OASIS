{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nimport rabin from '../chunker/rabin.js';\nimport fixedSize from '../chunker/fixed-size.js';\nimport validateChunks from './validate-chunks.js';\n\n/**\n * @typedef {import('../types').File} File\n * @typedef {import('../types').Directory} Directory\n * @typedef {import('../types').DAGBuilder} DAGBuilder\n * @typedef {import('../types').Chunker} Chunker\n * @typedef {import('../types').ChunkValidator} ChunkValidator\n */\n\n/**\n * @param {any} thing\n * @returns {thing is Iterable<any>}\n */\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterable<any>}\n */\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n\n/**\n * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content\n * @returns {AsyncIterable<Uint8Array>}\n */\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n\n/**\n * @type {DAGBuilder}\n */\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n    if (entry.content) {\n      /**\n       * @type {Chunker}\n       */\n      let chunker;\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin;\n      } else {\n        chunker = fixedSize;\n      }\n\n      /**\n       * @type {ChunkValidator}\n       */\n      let chunkValidator;\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = validateChunks;\n      }\n\n      /** @type {File} */\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      /** @type {Directory} */\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\nexport default dagBuilder;","map":{"version":3,"names":["dirBuilder","fileBuilder","errCode","rabin","fixedSize","validateChunks","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","contentAsAsyncIterable","content","Uint8Array","Error","dagBuilder","source","blockstore","options","entry","path","substring","wrapWithDirectory","split","filter","join","chunker","chunkValidator","file","mtime","mode","dir"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-importer@12.0.1/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js"],"sourcesContent":["import dirBuilder from './dir.js'\nimport fileBuilder from './file/index.js'\nimport errCode from 'err-code'\nimport rabin from '../chunker/rabin.js'\nimport fixedSize from '../chunker/fixed-size.js'\nimport validateChunks from './validate-chunks.js'\n\n/**\n * @typedef {import('../types').File} File\n * @typedef {import('../types').Directory} Directory\n * @typedef {import('../types').DAGBuilder} DAGBuilder\n * @typedef {import('../types').Chunker} Chunker\n * @typedef {import('../types').ChunkValidator} ChunkValidator\n */\n\n/**\n * @param {any} thing\n * @returns {thing is Iterable<any>}\n */\nfunction isIterable (thing) {\n  return Symbol.iterator in thing\n}\n\n/**\n * @param {any} thing\n * @returns {thing is AsyncIterable<any>}\n */\nfunction isAsyncIterable (thing) {\n  return Symbol.asyncIterator in thing\n}\n\n/**\n * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content\n * @returns {AsyncIterable<Uint8Array>}\n */\nfunction contentAsAsyncIterable (content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return (async function * () {\n        yield content\n      }())\n    } else if (isIterable(content)) {\n      return (async function * () {\n        yield * content\n      }())\n    } else if (isAsyncIterable(content)) {\n      return content\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT')\n  }\n\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT')\n}\n\n/**\n * @type {DAGBuilder}\n */\nasync function * dagBuilder (source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true\n      }\n\n      entry.path = entry.path\n        .split('/')\n        .filter(path => path && path !== '.')\n        .join('/')\n    }\n\n    if (entry.content) {\n      /**\n       * @type {Chunker}\n       */\n      let chunker\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin\n      } else {\n        chunker = fixedSize\n      }\n\n      /**\n       * @type {ChunkValidator}\n       */\n      let chunkValidator\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator\n      } else {\n        chunkValidator = validateChunks\n      }\n\n      /** @type {File} */\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      }\n\n      yield () => fileBuilder(file, blockstore, options)\n    } else if (entry.path) {\n      /** @type {Directory} */\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      }\n\n      yield () => dirBuilder(dir, blockstore, options)\n    } else {\n      throw new Error('Import candidate must have content or path or both')\n    }\n  }\n}\n\nexport default dagBuilder\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}