{"ast":null,"code":"import parseDuration from 'parse-duration';\nimport errCode from 'err-code';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\n\n/**\n * @typedef {import('ipfs-core-types/src/stats').BWOptions} BWOptions\n * @typedef {import('ipfs-core-types/src/stats').BWResult} BandwidthInfo\n * @typedef {import('libp2p').Libp2p} libp2p\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {libp2p} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\nfunction getBandwidthStats(libp2p, opts) {\n  /*\n    let stats\n  \n    if (!libp2p.metrics) {\n      stats = undefined\n    } else if (opts.peer) {\n      stats = libp2p.metrics.forPeer(opts.peer)\n    } else if (opts.proto) {\n      stats = libp2p.metrics.forProtocol(opts.proto)\n    } else {\n      stats = libp2p.metrics.getGlobal()\n    }\n  */\n  //  if (!stats) {\n  return {\n    totalIn: BigInt(0),\n    totalOut: BigInt(0),\n    rateIn: 0.0,\n    rateOut: 0.0\n  };\n  //  }\n  /*\n    const movingAverages = stats.getMovingAverages()\n    const snapshot = stats.getSnapshot()\n  \n    return {\n      totalIn: snapshot.dataReceived,\n      totalOut: snapshot.dataSent,\n      rateIn: movingAverages.dataReceived[60000].movingAverage / 60,\n      rateOut: movingAverages.dataSent[60000].movingAverage / 60\n    }\n  */\n}\n\n/**\n * @param {object} config\n * @param {import('../../types').NetworkService} config.network\n */\nexport function createBw({\n  network\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/stats').API<{}>[\"bw\"]}\n   */\n  const bw = async function* (options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options);\n      return;\n    }\n    const interval = options.interval || 1000;\n    let ms = -1;\n    try {\n      ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval;\n      if (!ms || ms < 0) throw new Error('invalid duration');\n    } catch ( /** @type {any} */err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL');\n    }\n    let timeoutId;\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options);\n        // eslint-disable-next-line no-loop-func\n        await new Promise(resolve => {\n          timeoutId = setTimeout(resolve, ms);\n        });\n      }\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  };\n  return withTimeoutOption(bw);\n}","map":{"version":3,"names":["parseDuration","errCode","withTimeoutOption","getBandwidthStats","libp2p","opts","totalIn","BigInt","totalOut","rateIn","rateOut","createBw","network","bw","options","use","poll","interval","ms","Error","err","timeoutId","Promise","resolve","setTimeout","clearTimeout"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/stats/bw.js"],"sourcesContent":["import parseDuration from 'parse-duration'\nimport errCode from 'err-code'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\n/**\n * @typedef {import('ipfs-core-types/src/stats').BWOptions} BWOptions\n * @typedef {import('ipfs-core-types/src/stats').BWResult} BandwidthInfo\n * @typedef {import('libp2p').Libp2p} libp2p\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {libp2p} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\nfunction getBandwidthStats (libp2p, opts) {\n/*\n  let stats\n\n  if (!libp2p.metrics) {\n    stats = undefined\n  } else if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer)\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto)\n  } else {\n    stats = libp2p.metrics.getGlobal()\n  }\n*/\n  //  if (!stats) {\n  return {\n    totalIn: BigInt(0),\n    totalOut: BigInt(0),\n    rateIn: 0.0,\n    rateOut: 0.0\n  }\n  //  }\n/*\n  const movingAverages = stats.getMovingAverages()\n  const snapshot = stats.getSnapshot()\n\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: movingAverages.dataReceived[60000].movingAverage / 60,\n    rateOut: movingAverages.dataSent[60000].movingAverage / 60\n  }\n*/\n}\n\n/**\n * @param {object} config\n * @param {import('../../types').NetworkService} config.network\n */\nexport function createBw ({ network }) {\n  /**\n   * @type {import('ipfs-core-types/src/stats').API<{}>[\"bw\"]}\n   */\n  const bw = async function * (options = {}) {\n    const { libp2p } = await network.use(options)\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options)\n      return\n    }\n\n    const interval = options.interval || 1000\n    let ms = -1\n    try {\n      ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval\n      if (!ms || ms < 0) throw new Error('invalid duration')\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL')\n    }\n\n    let timeoutId\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options)\n        // eslint-disable-next-line no-loop-func\n        await new Promise(resolve => { timeoutId = setTimeout(resolve, ms) })\n      }\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  return withTimeoutOption(bw)\n}\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,gBAAgB;AAC1C,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,iBAAiB,QAAQ,qCAAqC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAAEC,MAAM,EAAEC,IAAI,EAAE;EAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;EACA,OAAO;IACLC,OAAO,EAAEC,MAAM,CAAC,CAAC,CAAC;IAClBC,QAAQ,EAAED,MAAM,CAAC,CAAC,CAAC;IACnBE,MAAM,EAAE,GAAG;IACXC,OAAO,EAAE;EACX,CAAC;EACD;EACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAAE;EAAEC;AAAQ,CAAC,EAAE;EACrC;AACF;AACA;EACE,MAAMC,EAAE,GAAG,gBAAAA,CAAkBC,OAAO,GAAG,CAAC,CAAC,EAAE;IACzC,MAAM;MAAEV;IAAO,CAAC,GAAG,MAAMQ,OAAO,CAACG,GAAG,CAACD,OAAO,CAAC;IAE7C,IAAI,CAACA,OAAO,CAACE,IAAI,EAAE;MACjB,MAAMb,iBAAiB,CAACC,MAAM,EAAEU,OAAO,CAAC;MACxC;IACF;IAEA,MAAMG,QAAQ,GAAGH,OAAO,CAACG,QAAQ,IAAI,IAAI;IACzC,IAAIC,EAAE,GAAG,CAAC,CAAC;IACX,IAAI;MACFA,EAAE,GAAG,OAAOD,QAAQ,KAAK,QAAQ,GAAGjB,aAAa,CAACiB,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAGA,QAAQ;MAC5E,IAAI,CAACC,EAAE,IAAIA,EAAE,GAAG,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,kBAAkB,CAAC;IACxD,CAAC,CAAC,QAAO,kBAAmBC,GAAG,EAAE;MAC/B,MAAMnB,OAAO,CAACmB,GAAG,EAAE,2BAA2B,CAAC;IACjD;IAEA,IAAIC,SAAS;IACb,IAAI;MACF,OAAO,IAAI,EAAE;QACX,MAAMlB,iBAAiB,CAACC,MAAM,EAAEU,OAAO,CAAC;QACxC;QACA,MAAM,IAAIQ,OAAO,CAACC,OAAO,IAAI;UAAEF,SAAS,GAAGG,UAAU,CAACD,OAAO,EAAEL,EAAE,CAAC;QAAC,CAAC,CAAC;MACvE;IACF,CAAC,SAAS;MACRO,YAAY,CAACJ,SAAS,CAAC;IACzB;EACF,CAAC;EAED,OAAOnB,iBAAiB,CAACW,EAAE,CAAC;AAC9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}