{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* globals BigInt */\n\nimport { Token, Type } from './token.js';\nimport { decodeErrPrefix, assertEnoughData } from './common.js';\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')];\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 /* 2 ** 24 */ + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64(data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 /* 2 ** 24 */ + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 /* 2 ** 24 */ + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, nuint >>> 24 & 0xff, nuint >>> 16 & 0xff, nuint >>> 8 & 0xff, nuint & 0xff]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff));\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff));\n      set[8] = lo & 0xff;\n      lo = lo >> 8;\n      set[7] = lo & 0xff;\n      lo = lo >> 8;\n      set[6] = lo & 0xff;\n      lo = lo >> 8;\n      set[5] = lo & 0xff;\n      set[4] = hi & 0xff;\n      hi = hi >> 8;\n      set[3] = hi & 0xff;\n      hi = hi >> 8;\n      set[2] = hi & 0xff;\n      hi = hi >> 8;\n      set[1] = hi & 0xff;\n      buf.push(set);\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */0;\n};","map":{"version":3,"names":["Token","Type","decodeErrPrefix","assertEnoughData","uintBoundaries","BigInt","readUint8","data","offset","options","value","strict","Error","readUint16","readUint32","readUint64","hi","lo","Number","MAX_SAFE_INTEGER","allowBigInt","decodeUint8","pos","_minor","uint","decodeUint16","decodeUint32","decodeUint64","encodeUint","buf","token","encodeUintValue","major","nuint","push","buint","set","encodedSize","compareTokens","tok1","tok2"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/0uint.js"],"sourcesContent":["/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}