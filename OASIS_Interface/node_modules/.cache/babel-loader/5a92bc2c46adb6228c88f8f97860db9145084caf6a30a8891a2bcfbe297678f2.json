{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as ipns from 'ipns';\nimport { importKey } from '@libp2p/crypto/keys';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nconst log = logger('ipfs:ipns:republisher');\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\nexport class IpnsRepublisher {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(publisher, datastore, peerId, keychain, options = {\n    pass: ''\n  }) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n  async start() {\n    // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n          try {\n            // @ts-expect-error - _task could be null\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask;\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch ( /** @type {any} */err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId);\n        }\n        republishHandle._task = null;\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask;\n      }\n    };\n    const {\n      pass\n    } = this._options;\n    let firstRun = true;\n    republishHandle._task = async () => {\n      const timeoutController = new TimeoutController(30000);\n      try {\n        await this._republishEntries(this._peerId, pass, {\n          signal: timeoutController.signal\n        });\n      } finally {\n        timeoutController.clear();\n      }\n    };\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return this._options.initialBroadcastInterval || minute;\n      }\n      return this._options.broadcastInterval || defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n  async stop() {\n    const republishHandle = this._republishHandle;\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string} pass\n   * @param {AbortOptions} options\n   */\n  async _republishEntries(peerId, pass, options) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(peerId, options);\n    } catch ( /** @type {any} */err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue;\n          }\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await importKey(pem, pass);\n          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes);\n          await this._republishEntry(peerIdKey, options);\n        }\n      } catch ( /** @type {any} */err) {\n        log.error(err);\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {AbortOptions} options\n   */\n  async _republishEntry(peerId, options) {\n    try {\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n    } catch ( /** @type {any} */err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getPreviousValue(peerId) {\n    if (!isPeerId(peerId)) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()));\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal);\n        return record.value;\n      } catch ( /** @type {any} */err) {\n        log.error(err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch ( /** @type {any} */err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.toString()}`), 'ERR_NO_ENTRY_FOUND');\n      }\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["ipns","importKey","isPeerId","errcode","logger","peerIdFromKeys","TimeoutController","log","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","constructor","publisher","datastore","peerId","keychain","options","pass","_publisher","_datastore","_peerId","_keychain","_options","_republishHandle","start","Error","republishHandle","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","err","error","cancel","clearTimeout","firstRun","timeoutController","_republishEntries","signal","clear","initialBroadcastInterval","broadcastInterval","stop","_republishEntry","errMsg","keys","listKeys","key","name","pem","exportKey","privKey","peerIdKey","public","bytes","value","_getPreviousValue","publishWithEOL","code","dsVal","get","getLocalKey","toBytes","Uint8Array","record","unmarshal","notFound","toString"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/republisher.js"],"sourcesContent":["import * as ipns from 'ipns'\nimport { importKey } from '@libp2p/crypto/keys'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { TimeoutController } from 'timeout-abort-controller'\n\nconst log = logger('ipfs:ipns:republisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nexport class IpnsRepublisher {\n  /**\n   * @param {import('./publisher').IpnsPublisher} publisher\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (publisher, datastore, peerId, keychain, options = { pass: '' }) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerId = peerId\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  async start () { // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      /** @type {null|(() => Promise<void>)} */\n      _task: null,\n      /** @type {null|Promise<void>} */\n      _inflightTask: null,\n      /** @type {null|NodeJS.Timeout} */\n      _timeoutId: null,\n      /**\n       * @param {function(): number} period\n       */\n      runPeriodically: (period) => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null\n\n          try {\n            // @ts-expect-error - _task could be null\n            republishHandle._inflightTask = republishHandle._task()\n            await republishHandle._inflightTask\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period)\n            }\n          } catch (/** @type {any} */ err) {\n            log.error(err)\n          }\n        }, period())\n      },\n      cancel: async () => {\n        // do not run again\n        if (republishHandle._timeoutId != null) {\n          clearTimeout(republishHandle._timeoutId)\n        }\n        republishHandle._task = null\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask\n      }\n    }\n\n    const { pass } = this._options\n    let firstRun = true\n\n    republishHandle._task = async () => {\n      const timeoutController = new TimeoutController(30000)\n\n      try {\n        await this._republishEntries(this._peerId, pass, {\n          signal: timeoutController.signal\n        })\n      } finally {\n        timeoutController.clear()\n      }\n    }\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false\n        return this._options.initialBroadcastInterval || minute\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval\n    })\n\n    this._republishHandle = republishHandle\n  }\n\n  async stop () {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING')\n    }\n\n    this._republishHandle = null\n\n    await republishHandle.cancel()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string} pass\n   * @param {AbortOptions} options\n   */\n  async _republishEntries (peerId, pass, options) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(peerId, options)\n    } catch (/** @type {any} */ err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key'\n\n      log.error(errMsg)\n      return\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys()\n\n        for (const key of keys) {\n          if (key.name === 'self') {\n            continue\n          }\n\n          const pem = await this._keychain.exportKey(key.name, pass)\n          const privKey = await importKey(pem, pass)\n          const peerIdKey = await peerIdFromKeys(privKey.public.bytes, privKey.bytes)\n\n          await this._republishEntry(peerIdKey, options)\n        }\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {AbortOptions} options\n   */\n  async _republishEntry (peerId, options) {\n    try {\n      const value = await this._getPreviousValue(peerId)\n      await this._publisher.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _getPreviousValue (peerId) {\n    if (!(isPeerId(peerId))) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID')\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      if (!(dsVal instanceof Uint8Array)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD')\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal)\n\n        return record.value\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD')\n      }\n    } catch (/** @type {any} */ err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.toString()}`), 'ERR_NO_ENTRY_FOUND')\n      }\n\n      throw err\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}