{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Concat, util } from '@tensorflow/tfjs-core';\nimport { complex } from './Complex';\nimport { concatImpl } from './Concat_impl';\nimport { identity } from './Identity';\nimport { imag } from './Imag';\nimport { real } from './Real';\nimport { reshape } from './Reshape';\nexport function concat(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    axis\n  } = attrs;\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({\n      inputs: {\n        x: $inputs[0]\n      },\n      backend\n    });\n  }\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n  if ($inputs[0].dtype === 'complex64') {\n    const reals = $inputs.map(t => real({\n      inputs: {\n        input: t\n      },\n      backend\n    }));\n    const imags = $inputs.map(t => imag({\n      inputs: {\n        input: t\n      },\n      backend\n    }));\n    const realConcated = concat({\n      inputs: reals,\n      backend,\n      attrs: {\n        axis: $axis\n      }\n    });\n    const imagConcated = concat({\n      inputs: imags,\n      backend,\n      attrs: {\n        axis: $axis\n      }\n    });\n    const result = complex({\n      inputs: {\n        real: realConcated,\n        imag: imagConcated\n      },\n      backend\n    });\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n    return result;\n  }\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const inputs2D = $inputs.map(t => {\n    const innerSize = util.sizeFromShape(t.shape.slice($axis));\n    const shape = [-1, innerSize];\n    return reshape({\n      inputs: {\n        x: t\n      },\n      backend,\n      attrs: {\n        shape\n      }\n    });\n  });\n  const inputsValShapes = inputs2D.map(t => {\n    return {\n      vals: backend.data.get(t.dataId).values,\n      shape: t.shape\n    };\n  });\n  // Concats 2d tensors along axis=1.\n  outShape = backend_util.computeOutShape(inputs2D.map(t => t.shape), 1 /* axis */);\n  const simplyConcat = inputs2D[0].shape[0] === 1;\n  const outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n  const finalOutShape = backend_util.computeOutShape($inputs.map(t => t.shape), $axis);\n  const outInfo = backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);\n  inputs2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return outInfo;\n}\nexport const concatConfig = {\n  kernelName: Concat,\n  backendName: 'cpu',\n  kernelFunc: concat\n};","map":{"version":3,"names":["backend_util","Concat","util","complex","concatImpl","identity","imag","real","reshape","concat","args","inputs","backend","attrs","axis","$axis","parseAxisParam","shape","outShape","computeOutShape","map","t","sizeFromShape","makeTensorInfo","dtype","$inputs","filter","length","x","shapes","assertParamsConsistent","reals","input","imags","realConcated","imagConcated","result","forEach","r","disposeIntermediateTensorInfo","i","inputs2D","innerSize","slice","inputsValShapes","vals","data","get","dataId","values","simplyConcat","outVals","finalOutShape","outInfo","concatConfig","kernelName","backendName","kernelFunc"],"sources":["../../../../../../tfjs-backend-cpu/src/kernels/Concat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nimport {complex} from './Complex';\nimport {concatImpl} from './Concat_impl';\nimport {identity} from './Identity';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concat(\n    args: {inputs: ConcatInputs, backend: MathBackendCPU, attrs: ConcatAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  if ($inputs[0].dtype === 'complex64') {\n    const reals = $inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = $inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concat({inputs: reals, backend, attrs: {axis: $axis}});\n    const imagConcated = concat({inputs: imags, backend, attrs: {axis: $axis}});\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n\n    return result;\n  }\n\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const inputs2D = $inputs.map(t => {\n    const innerSize = util.sizeFromShape(t.shape.slice($axis));\n    const shape = [-1, innerSize];\n    return reshape({inputs: {x: t}, backend, attrs: {shape}});\n  });\n\n  const inputsValShapes = inputs2D.map(t => {\n    return {vals: backend.data.get(t.dataId).values, shape: t.shape};\n  });\n\n  // Concats 2d tensors along axis=1.\n  outShape =\n      backend_util.computeOutShape(inputs2D.map(t => t.shape), 1 /* axis */);\n  const simplyConcat = inputs2D[0].shape[0] === 1;\n  const outVals =\n      concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n\n  const finalOutShape =\n      backend_util.computeOutShape($inputs.map(t => t.shape), $axis);\n\n  const outInfo =\n      backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);\n\n  inputs2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return outInfo;\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'cpu',\n  kernelFunc: concat as {} as KernelFunc\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}