{"ast":null,"code":"import { Key } from 'interface-datastore';\nimport { readShardFun, SHARDING_FN, README_FN, readme } from './shard.js';\nimport { BaseDatastore } from './base.js';\nimport { KeyTransformDatastore } from './keytransform.js';\nimport * as Errors from './errors.js';\nconst shardKey = new Key(SHARDING_FN);\nconst shardReadmeKey = new Key(README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nexport class ShardingDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _convertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _invertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    return Key.withNamespaces(key.list().slice(1));\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch ( /** @type {any} */err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n    return ShardingDatastore.open(store);\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n  static async open(store) {\n    const shard = await readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async create(store, shard) {\n    const hasShard = await store.has(shardKey);\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(readme))]);\n      return shard;\n    }\n\n    // test shards\n    const diskShard = await readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n    }\n    return diskShard;\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async *putMany(source, options = {}) {\n    yield* this.child.putMany(source, options);\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n  async *getMany(source, options = {}) {\n    yield* this.child.getMany(source, options);\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async *deleteMany(source, options = {}) {\n    yield* this.child.deleteMany(source, options);\n  }\n  batch() {\n    return this.child.batch();\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query(q, options) {\n    /** @type {Query} */\n    const tq = {\n      ...q,\n      filters: [/** @type {QueryFilter} */\n      ({\n        key\n      }) => key.toString() !== shardKey.toString(), /** @type {QueryFilter} */\n      ({\n        key\n      }) => key.toString() !== shardReadmeKey.toString()].concat(q.filters || [])\n    };\n    return this.child.query(tq, options);\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys(q, options) {\n    /** @type {KeyQuery} */\n    const tq = {\n      ...q,\n      filters: [/** @type {KeyQueryFilter} */\n      key => key.toString() !== shardKey.toString(), /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardReadmeKey.toString()].concat(q.filters || [])\n    };\n    return this.child.queryKeys(tq, options);\n  }\n  close() {\n    return this.child.close();\n  }\n}","map":{"version":3,"names":["Key","readShardFun","SHARDING_FN","README_FN","readme","BaseDatastore","KeyTransformDatastore","Errors","shardKey","shardReadmeKey","ShardingDatastore","constructor","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","create","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","err","message","hasShard","has","dbOpenFailedError","Error","put","putRaw","Promise","all","TextEncoder","encode","diskShard","a","b","val","options","get","delete","putMany","source","getMany","deleteMany","batch","query","q","tq","filters","concat","queryKeys","close"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/datastore-core@8.0.4/node_modules/datastore-core/src/sharding.js"],"sourcesContent":["import { Key } from 'interface-datastore'\nimport {\n  readShardFun,\n  SHARDING_FN,\n  README_FN,\n  readme\n} from './shard.js'\nimport { BaseDatastore } from './base.js'\nimport { KeyTransformDatastore } from './keytransform.js'\nimport * as Errors from './errors.js'\n\nconst shardKey = new Key(SHARDING_FN)\nconst shardReadmeKey = new Key(README_FN)\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nexport class ShardingDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  async open () {\n    await this.child.open()\n\n    this.shard = await ShardingDatastore.create(this.child, this.shard)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (/** @type {any} */ err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n  static async open (store) {\n    const shard = await readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async create (store, shard) {\n    const hasShard = await store.has(shardKey)\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'))\n    }\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(readme))\n      ])\n\n      return shard\n    }\n\n    // test shards\n    const diskShard = await readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    }\n    return diskShard\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    yield * this.child.putMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n  async * getMany (source, options = {}) {\n    yield * this.child.getMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    yield * this.child.deleteMany(source, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    /** @type {Query} */\n    const tq = {\n      ...q,\n      filters: [\n        /** @type {QueryFilter} */\n        ({ key }) => key.toString() !== shardKey.toString(),\n        /** @type {QueryFilter} */\n        ({ key }) => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    /** @type {KeyQuery} */\n    const tq = {\n      ...q,\n      filters: [\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardKey.toString(),\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    }\n\n    return this.child.queryKeys(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}