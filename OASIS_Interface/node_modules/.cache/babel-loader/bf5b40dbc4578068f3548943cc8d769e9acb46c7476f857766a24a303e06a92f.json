{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport errCode from 'err-code';\nimport { NotEnabledError } from '../errors.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { CID } from 'multiformats/cid';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { base36 } from 'multiformats/bases/base36';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\n\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst IPNS_PREFIX = '/ipns/';\n\n/**\n * @param {string} str\n */\nfunction toDHTKey(str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length);\n  }\n\n  /** @type {Uint8Array|undefined} */\n  let buf;\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = `z${str}`;\n  }\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str);\n  }\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str);\n  }\n  if (!buf) {\n    throw new Error('Could not parse string');\n  }\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([[0x01, 0x72], buf]);\n  }\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length);\n  }\n  return uint8ArrayConcat([uint8ArrayFromString(IPNS_PREFIX), buf.subarray(2)]);\n}\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\nexport function createDht({\n  network,\n  repo,\n  peerId\n}) {\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n     */\n    async *get(key, options = {}) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.get(dhtKey, options);\n    },\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n     */\n    async *put(key, value, options) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.put(dhtKey, value, options);\n    },\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n     */\n    async *findProvs(cid, options = {}) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.findProviders(cid, {\n        signal: options.signal\n      });\n    },\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n     */\n    async *findPeer(peerIdToFind, options = {}) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.findPeer(peerIdToFind, {\n        signal: options.signal\n      });\n    },\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n     */\n    async *provide(cid, options = {\n      recursive: false\n    }) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n\n      // ensure blocks are actually local\n      const hasBlock = await repo.blocks.has(cid);\n      if (!hasBlock) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.provide(cid);\n    },\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n     */\n    async *query(peerIdToQuery, options = {}) {\n      const {\n        libp2p\n      } = await use(network, peerId, options);\n      let bytes;\n      const asCid = CID.asCID(peerIdToQuery);\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes;\n      } else {\n        bytes = peerIdFromString(peerIdToQuery.toString()).toBytes();\n      }\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n      }\n      yield* libp2p.dht.getClosestPeers(bytes, options);\n    }\n  };\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options);\n  if (net.libp2p.dht != null) {\n    return net;\n  } else {\n    const fn = async function* () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new NotEnabledError('dht not enabled')\n      };\n    };\n    return {\n      libp2p: {\n        dht: {\n          // @ts-expect-error incomplete implementation\n          get: fn,\n          // @ts-expect-error incomplete implementation\n          put: fn,\n          // @ts-expect-error incomplete implementation\n          findProviders: fn,\n          // @ts-expect-error incomplete implementation\n          findPeer: fn,\n          // @ts-expect-error incomplete implementation\n          provide: fn,\n          // @ts-expect-error incomplete implementation\n          getClosestPeers: fn\n        }\n      }\n    };\n  }\n};","map":{"version":3,"names":["errCode","NotEnabledError","withTimeoutOption","CID","base58btc","base36","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","peerIdFromString","IPNS_PREFIX","toDHTKey","str","startsWith","substring","length","buf","decode","Error","subarray","createDht","network","repo","peerId","get","put","findProvs","findPeer","provide","query","key","options","libp2p","use","dhtKey","Uint8Array","dht","value","cid","findProviders","signal","peerIdToFind","recursive","hasBlock","blocks","has","peerIdToQuery","bytes","asCid","asCID","multihash","toString","toBytes","getClosestPeers","net","fn","from","name","type","error"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/dht.js"],"sourcesContent":["import errCode from 'err-code'\nimport { NotEnabledError } from '../errors.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { CID } from 'multiformats/cid'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base36 } from 'multiformats/bases/base36'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-dht').QueryEvent} QueryEvent\n * @typedef {import('./network').Network} Network\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nconst IPNS_PREFIX = '/ipns/'\n\n/**\n * @param {string} str\n */\nfunction toDHTKey (str) {\n  if (str.startsWith(IPNS_PREFIX)) {\n    str = str.substring(IPNS_PREFIX.length)\n  }\n\n  /** @type {Uint8Array|undefined} */\n  let buf\n\n  if (str[0] === '1' || str[0] === 'Q') {\n    // ed25519 key or hash of rsa key\n    str = `z${str}`\n  }\n\n  if (str[0] === 'z') {\n    buf = base58btc.decode(str)\n  }\n\n  if (str[0] === 'k') {\n    // base36 encoded string\n    buf = base36.decode(str)\n  }\n\n  if (!buf) {\n    throw new Error('Could not parse string')\n  }\n\n  if (buf[0] !== 0x01 && buf[1] !== 0x72) {\n    // prefix key with CIDv1 and libp2p-key codec\n    buf = uint8ArrayConcat([\n      [0x01, 0x72],\n      buf\n    ])\n  }\n\n  if (buf.length !== 40) {\n    throw new Error('Incorrect length ' + buf.length)\n  }\n\n  return uint8ArrayConcat([\n    uint8ArrayFromString(IPNS_PREFIX),\n    buf.subarray(2)\n  ])\n}\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {PeerId} config.peerId\n */\nexport function createDht ({ network, repo, peerId }) {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"get\"]}\n     */\n    async * get (key, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.get(dhtKey, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, peerId, options)\n\n      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.put(dhtKey, value, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findProviders(cid, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"findPeer\"]}\n     */\n    async * findPeer (peerIdToFind, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.findPeer(peerIdToFind, {\n        signal: options.signal\n      })\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"provide\"]}\n     */\n    async * provide (cid, options = { recursive: false }) {\n      const { libp2p } = await use(network, peerId, options)\n\n      // ensure blocks are actually local\n      const hasBlock = await repo.blocks.has(cid)\n\n      if (!hasBlock) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.provide(cid)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API<{}>[\"query\"]}\n     */\n    async * query (peerIdToQuery, options = {}) {\n      const { libp2p } = await use(network, peerId, options)\n      let bytes\n      const asCid = CID.asCID(peerIdToQuery)\n\n      if (asCid != null) {\n        bytes = asCid.multihash.bytes\n      } else {\n        bytes = peerIdFromString(peerIdToQuery.toString()).toBytes()\n      }\n\n      if (libp2p.dht == null) {\n        throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n      }\n\n      yield * libp2p.dht.getClosestPeers(bytes, options)\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {PeerId} peerId\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n * @returns {Promise<Network>}\n */\nconst use = async (network, peerId, options) => {\n  const net = await network.use(options)\n  if (net.libp2p.dht != null) {\n    return net\n  } else {\n    const fn = async function * () {\n      yield {\n        from: peerId,\n        name: 'QUERY_ERROR',\n        type: 3,\n        error: new NotEnabledError('dht not enabled')\n      }\n    }\n\n    return {\n      libp2p: {\n        dht: {\n          // @ts-expect-error incomplete implementation\n          get: fn,\n          // @ts-expect-error incomplete implementation\n          put: fn,\n          // @ts-expect-error incomplete implementation\n          findProviders: fn,\n          // @ts-expect-error incomplete implementation\n          findPeer: fn,\n          // @ts-expect-error incomplete implementation\n          provide: fn,\n          // @ts-expect-error incomplete implementation\n          getClosestPeers: fn\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}