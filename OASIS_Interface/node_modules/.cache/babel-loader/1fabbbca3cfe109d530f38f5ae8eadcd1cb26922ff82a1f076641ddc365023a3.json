{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport parseDuration from 'parse-duration';\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport errcode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { resolvePath } from './utils.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nconst log = logger('ipfs:name:publish');\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\nexport function createPublish({\n  ipns,\n  repo,\n  codecs,\n  peerId,\n  isOnline,\n  keychain\n}) {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    /** @type {import('@libp2p/interface-keys').PrivateKey} */\n    let privateKey;\n    if (keyName === 'self' && peerId.privateKey != null) {\n      privateKey = await unmarshalPrivateKey(peerId.privateKey);\n    } else {\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = await keychain.exportKey(keyName, 'temp');\n        privateKey = await importKey(pem, 'temp');\n      } catch ( /** @type {any} */err) {\n        log.error(err);\n        throw errcode(err, 'ERR_CANNOT_GET_KEY');\n      }\n    }\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes);\n  };\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n  async function publish(value, options = {}) {\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n    let pubLifetime = 0;\n    try {\n      pubLifetime = parseDuration(lifetime) || 0;\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n    // verify if the path exists, if not, an error will stop the execution\n    lookupKey(key),\n    // if resolving, do a get so we make sure we have the blocks\n    resolve ? resolvePath({\n      ipns,\n      repo,\n      codecs\n    }, value) : Promise.resolve()]);\n    const bytes = uint8ArrayFromString(value);\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime, options);\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    };\n  }\n  return withTimeoutOption(publish);\n}","map":{"version":3,"names":["logger","parseDuration","importKey","unmarshalPrivateKey","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","peerIdFromKeys","log","createPublish","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privateKey","pem","exportKey","err","error","public","bytes","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","results","Promise","all","result","name"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/name/publish.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport parseDuration from 'parse-duration'\nimport { importKey, unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport errcode from 'err-code'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR, normalizePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { resolvePath } from './utils.js'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\n\nconst log = logger('ipfs:name:publish')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n */\nexport function createPublish ({ ipns, repo, codecs, peerId, isOnline, keychain }) {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    /** @type {import('@libp2p/interface-keys').PrivateKey} */\n    let privateKey\n\n    if (keyName === 'self' && peerId.privateKey != null) {\n      privateKey = await unmarshalPrivateKey(peerId.privateKey)\n    } else {\n      try {\n        // We're exporting and immediately importing the key, so we can just use a throw away password\n        const pem = await keychain.exportKey(keyName, 'temp')\n        privateKey = await importKey(pem, 'temp')\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n        throw errcode(err, 'ERR_CANNOT_GET_KEY')\n      }\n    }\n\n    return peerIdFromKeys(privateKey.public.bytes, privateKey.bytes)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime, options)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}