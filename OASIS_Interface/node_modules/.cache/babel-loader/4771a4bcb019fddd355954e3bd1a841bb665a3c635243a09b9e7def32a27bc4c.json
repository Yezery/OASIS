{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\";\nimport * as varint from './varint.js';\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const {\n    bytes,\n    version\n  } = link;\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link), /** @type {API.MultibaseEncoder<\"z\">} */base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, baseCache(link), /** @type {API.MultibaseEncoder<Prefix>} */base || base32.encoder);\n  }\n};\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = link => ({\n  '/': format(link)\n});\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = json => CID.parse(json['/']);\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap();\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid);\n  if (baseCache == null) {\n    const baseCache = new Map();\n    cache.set(cid, baseCache);\n    return baseCache;\n  }\n  return baseCache;\n};\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor(version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code;\n    /** @readonly */\n    this.version = version;\n    /** @readonly */\n    this.multihash = multihash;\n    /** @readonly */\n    this.bytes = bytes;\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes;\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID() {\n    return this;\n  }\n\n  // ArrayBufferView\n  get byteOffset() {\n    return this.bytes.byteOffset;\n  }\n\n  // ArrayBufferView\n  get byteLength() {\n    return this.bytes.byteLength;\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */this\n          );\n        }\n      case 1:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n\n          // sha2-256\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n          return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */\n            CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */multihash)\n          );\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return (/** @type {CID<Data, Format, Alg, 1>} */\n            CID.createV1(this.code, multihash)\n          );\n        }\n      case 1:\n        {\n          return (/** @type {CID<Data, Format, Alg, 1>} */this\n          );\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n        }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals(other) {\n    return CID.equals(this, other);\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals(self, other) {\n    const unknown = /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */\n    other;\n    return unknown && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString(base) {\n    return format(this, base);\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON() {\n    return {\n      '/': format(this)\n    };\n  }\n  link() {\n    return this;\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `CID(${this.toString()})`;\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID(input) {\n    if (input == null) {\n      return null;\n    }\n    const value = /** @type {any} */input;\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value;\n    } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, /** @type {API.MultihashDigest<Alg>} */multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest = /** @type {API.MultihashDigest<Alg>} */\n      Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null;\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest');\n    }\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */digest) : CID.createV1(specs.codec, digest);\n    return [/** @type {CID<T, C, A, V>} */cid, bytes.subarray(specs.size)];\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = /** @type {V} */next();\n    let codec = /** @type {C} */DAG_PB_CODE;\n    if ( /** @type {number} */version === 18) {\n      // CIDv0\n      version = /** @type {V} */0;\n      offset = 0;\n    } else {\n      codec = /** @type {C} */next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n    const prefixSize = offset;\n    const multihashCode = /** @type {A} */next(); // multihash code\n    const digestSize = next(); // multihash length\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix');\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source);\n    return cid;\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        const decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];\n      }\n    case base58btc.prefix:\n      {\n        const decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        const decoder = base || base32;\n        return [/** @type {Prefix} */base32.prefix, decoder.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [/** @type {Prefix} */source[0], base.decode(source)];\n      }\n  }\n};\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"names":["base32","base58btc","coerce","Digest","API","varint","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","toJSON","fromJSON","json","CID","parse","cache","WeakMap","cid","get","Map","set","constructor","code","multihash","asCID","byteOffset","byteLength","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","equals","other","self","unknown","toString","Symbol","toStringTag","for","input","value","encodeCID","cidSymbol","decode","Uint8Array","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","i","RangeError","source","prefix","parseCIDtoBytes","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"sources":["/Users/yezery/Documents/大学素材/毕业设计/OASIS/OASIS_Interface/node_modules/.store/multiformats@12.1.2/node_modules/multiformats/src/cid.js"],"sourcesContent":["import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}