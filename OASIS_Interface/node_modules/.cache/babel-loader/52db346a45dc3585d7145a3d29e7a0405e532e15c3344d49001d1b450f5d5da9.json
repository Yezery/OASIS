{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Key } from 'interface-datastore';\nimport { BaseDatastore } from 'datastore-core';\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nconst log = logger('datastore-pubsub:publisher');\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nexport class PubSubDatastore extends BaseDatastore {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    super();\n    if (!validator) {\n      throw new CodeError('missing validator', 'ERR_INVALID_PARAMETERS');\n    }\n    if (typeof validator !== 'function') {\n      throw new CodeError('missing validate function', 'ERR_INVALID_PARAMETERS');\n    }\n    if (typeof selector !== 'function') {\n      throw new CodeError('missing select function', 'ERR_INVALID_PARAMETERS');\n    }\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw new CodeError('invalid subscriptionKeyFn received', 'ERR_INVALID_PARAMETERS');\n    }\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._selector = selector;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn;\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this);\n    this._pubsub.addEventListener('message', this._onMessage);\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put(key, val, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY');\n    }\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_VALUE_RECEIVED');\n    }\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`);\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val);\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get(key, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY');\n    }\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics();\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key, options);\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic);\n    } catch ( /** @type {any} */err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_SUBSCRIBING_TOPIC');\n    }\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   * @param {AbortOptions} [options]\n   */\n  async _getLocal(key, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n    try {\n      dsVal = await this._datastore.get(routingKey, options);\n    } catch ( /** @type {any} */err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw new CodeError(errMsg, 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_NOT_FOUND');\n    }\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_INVALID_RECORD_RECEIVED');\n    }\n    return dsVal;\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {CustomEvent<PubSubMessage>} evt\n   */\n  async _onMessage(evt) {\n    const msg = evt.detail;\n    if (msg.type !== 'signed') {\n      log.error('unsigned message received, this module can only work with signed messages');\n      return;\n    }\n    const {\n      data,\n      from,\n      topic\n    } = msg;\n    let key;\n    try {\n      key = topicToKey(topic);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      return;\n    }\n    log(`message received for topic ${topic}`);\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (this._peerId.equals(from)) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch ( /** @type {any} */err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n      key = res;\n    }\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeIfSubscriptionIsBetter(key, data, options) {\n    let isBetter = false;\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch ( /** @type {any} */err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n    if (isBetter) {\n      await this._storeRecord(key, data, options);\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   */\n  async _validateRecord(key, value) {\n    // eslint-disable-line require-await\n    return this._validator(key, value);\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord(key, records) {\n    const res = await this._selector(key, records);\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0;\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter(key, val) {\n    try {\n      await this._validateRecord(key, val);\n    } catch ( /** @type {any} */err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw new CodeError(errMsg, 'ERR_NOT_VALID_RECORD');\n    }\n\n    // Get Local record\n    const dsKey = new Key(key);\n    let currentRecord;\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array());\n    } catch ( /** @type {any} */err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false;\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val]);\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeRecord(key, data, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data, options);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n}","map":{"version":3,"names":["Key","BaseDatastore","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","CodeError","logger","log","PubSubDatastore","constructor","pubsub","datastore","peerId","validator","selector","subscriptionKeyFn","_pubsub","_datastore","_peerId","_validator","_selector","_handleSubscriptionKeyFn","_onMessage","bind","addEventListener","put","key","val","options","Uint8Array","errMsg","error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","subscribe","err","unsubscribe","routingKey","dsVal","code","toString","evt","msg","detail","type","data","from","topic","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","records","dsKey","currentRecord","uint8Array"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/datastore-pubsub@7.0.0/node_modules/datastore-pubsub/src/index.js"],"sourcesContent":["import { Key } from 'interface-datastore'\nimport { BaseDatastore } from 'datastore-core'\nimport { encodeBase32, keyToTopic, topicToKey } from './utils.js'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('datastore-pubsub:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('@libp2p/interface-pubsub').Message} PubSubMessage\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nexport class PubSubDatastore extends BaseDatastore {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {import('@libp2p/interface-dht').ValidateFn} validator - validator function\n   * @param {import('@libp2p/interface-dht').SelectFn} selector - selector function\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, selector, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw new CodeError('missing validator', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator !== 'function') {\n      throw new CodeError('missing validate function', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof selector !== 'function') {\n      throw new CodeError('missing select function', 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw new CodeError('invalid subscriptionKeyFn received', 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._selector = selector\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n    this._pubsub.addEventListener('message', this._onMessage)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @param {AbortOptions} [options]\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key, options) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key, options)\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   * @param {AbortOptions} [options]\n   */\n  async _getLocal (key, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw new CodeError(errMsg, 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {CustomEvent<PubSubMessage>} evt\n   */\n  async _onMessage (evt) {\n    const msg = evt.detail\n\n    if (msg.type !== 'signed') {\n      log.error('unsigned message received, this module can only work with signed messages')\n      return\n    }\n\n    const { data, from, topic } = msg\n    let key\n    try {\n      key = topicToKey(topic)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topic}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (this._peerId.equals(from)) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (/** @type {any} */ err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeIfSubscriptionIsBetter (key, data, options) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data, options)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   */\n  async _validateRecord (key, value) { // eslint-disable-line require-await\n    return this._validator(key, value)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._selector(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(key, val)\n    } catch (/** @type {any} */ err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw new CodeError(errMsg, 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (/** @type {any} */ err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   * @param {AbortOptions} [options]\n   */\n  async _storeRecord (key, data, options) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data, options)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,qBAAqB;AACzC,SAASC,aAAa,QAAQ,gBAAgB;AAC9C,SAASC,YAAY,EAAEC,UAAU,EAAEC,UAAU,QAAQ,YAAY;AACjE,SAASC,MAAM,IAAIC,gBAAgB,QAAQ,oBAAoB;AAC/D,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,MAAM,QAAQ,gBAAgB;AAEvC,MAAMC,GAAG,GAAGD,MAAM,CAAC,4BAA4B,CAAC;;AAEhD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,MAAME,eAAe,SAAST,aAAa,CAAC;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEU,WAAWA,CAAEC,MAAM,EAAEC,SAAS,EAAEC,MAAM,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,iBAAiB,EAAE;IAC9E,KAAK,CAAC,CAAC;IAEP,IAAI,CAACF,SAAS,EAAE;MACd,MAAM,IAAIR,SAAS,CAAC,mBAAmB,EAAE,wBAAwB,CAAC;IACpE;IAEA,IAAI,OAAOQ,SAAS,KAAK,UAAU,EAAE;MACnC,MAAM,IAAIR,SAAS,CAAC,2BAA2B,EAAE,wBAAwB,CAAC;IAC5E;IAEA,IAAI,OAAOS,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAIT,SAAS,CAAC,yBAAyB,EAAE,wBAAwB,CAAC;IAC1E;IAEA,IAAIU,iBAAiB,IAAI,OAAOA,iBAAiB,KAAK,UAAU,EAAE;MAChE,MAAM,IAAIV,SAAS,CAAC,oCAAoC,EAAE,wBAAwB,CAAC;IACrF;IAEA,IAAI,CAACW,OAAO,GAAGN,MAAM;IACrB,IAAI,CAACO,UAAU,GAAGN,SAAS;IAC3B,IAAI,CAACO,OAAO,GAAGN,MAAM;IACrB,IAAI,CAACO,UAAU,GAAGN,SAAS;IAC3B,IAAI,CAACO,SAAS,GAAGN,QAAQ;IACzB,IAAI,CAACO,wBAAwB,GAAGN,iBAAiB;;IAEjD;IACA,IAAI,CAACO,UAAU,GAAG,IAAI,CAACA,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACP,OAAO,CAACQ,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACF,UAAU,CAAC;EAC3D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE;EACA,MAAMG,GAAGA,CAAEC,GAAG,EAAEC,GAAG,EAAEC,OAAO,EAAE;IAC5B,IAAI,EAAEF,GAAG,YAAYG,UAAU,CAAC,EAAE;MAChC,MAAMC,MAAM,GAAG,4CAA4C;MAE3DvB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,2BAA2B,CAAC;IAC1D;IAEA,IAAI,EAAEH,GAAG,YAAYE,UAAU,CAAC,EAAE;MAChC,MAAMC,MAAM,GAAG,oCAAoC;MAEnDvB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,4BAA4B,CAAC;IAC3D;IAEA,MAAME,gBAAgB,GAAG/B,UAAU,CAACyB,GAAG,CAAC;IAExCnB,GAAG,CAAE,2BAA0ByB,gBAAiB,EAAC,CAAC;;IAElD;IACA,MAAM,IAAI,CAAChB,OAAO,CAACiB,OAAO,CAACD,gBAAgB,EAAEL,GAAG,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE;EACA,MAAMO,GAAGA,CAAER,GAAG,EAAEE,OAAO,EAAE;IACvB,IAAI,EAAEF,GAAG,YAAYG,UAAU,CAAC,EAAE;MAChC,MAAMC,MAAM,GAAG,4CAA4C;MAE3DvB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,2BAA2B,CAAC;IAC1D;IAEA,MAAME,gBAAgB,GAAG/B,UAAU,CAACyB,GAAG,CAAC;IACxC,MAAMS,aAAa,GAAG,MAAM,IAAI,CAACnB,OAAO,CAACoB,SAAS,CAAC,CAAC;;IAEpD;IACA,IAAID,aAAa,IAAIE,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,IAAIA,aAAa,CAACI,OAAO,CAACP,gBAAgB,CAAC,GAAG,CAAC,CAAC,EAAE;MACjG,OAAO,IAAI,CAACQ,SAAS,CAACd,GAAG,EAAEE,OAAO,CAAC;IACrC;;IAEA;IACA,IAAI;MACF,MAAM,IAAI,CAACZ,OAAO,CAACyB,SAAS,CAACT,gBAAgB,CAAC;IAChD,CAAC,CAAC,QAAO,kBAAmBU,GAAG,EAAE;MAC/B,MAAMZ,MAAM,GAAI,0BAAyBE,gBAAiB,EAAC;MAE3DzB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,uBAAuB,CAAC;IACtD;IACAvB,GAAG,CAAE,6BAA4ByB,gBAAiB,EAAC,CAAC;IAEpD,OAAO,IAAI,CAACQ,SAAS,CAACd,GAAG,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEiB,WAAWA,CAAEjB,GAAG,EAAE;IAChB,MAAMM,gBAAgB,GAAG/B,UAAU,CAACyB,GAAG,CAAC;IAExC,OAAO,IAAI,CAACV,OAAO,CAAC2B,WAAW,CAACX,gBAAgB,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMQ,SAASA,CAAEd,GAAG,EAAEE,OAAO,EAAE;IAC7B;IACA,MAAMgB,UAAU,GAAG,IAAI9C,GAAG,CAAC,GAAG,GAAGE,YAAY,CAAC0B,GAAG,CAAC,EAAE,KAAK,CAAC;IAC1D,IAAImB,KAAK;IAET,IAAI;MACFA,KAAK,GAAG,MAAM,IAAI,CAAC5B,UAAU,CAACiB,GAAG,CAACU,UAAU,EAAEhB,OAAO,CAAC;IACxD,CAAC,CAAC,QAAO,kBAAmBc,GAAG,EAAE;MAC/B,IAAIA,GAAG,CAACI,IAAI,KAAK,eAAe,EAAE;QAChC,MAAMhB,MAAM,GAAI,gDAA+Cc,UAAU,CAACG,QAAQ,CAAC,CAAE,EAAC;QAEtFxC,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;QACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,qCAAqC,CAAC;MACpE;MACA,MAAMA,MAAM,GAAI,4CAA2Cc,UAAU,CAACG,QAAQ,CAAC,CAAE,EAAC;MAElFxC,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,eAAe,CAAC;IAC9C;IAEA,IAAI,EAAEe,KAAK,YAAYhB,UAAU,CAAC,EAAE;MAClC,MAAMC,MAAM,GAAG,mDAAmD;MAElEvB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,6BAA6B,CAAC;IAC5D;IAEA,OAAOe,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMvB,UAAUA,CAAE0B,GAAG,EAAE;IACrB,MAAMC,GAAG,GAAGD,GAAG,CAACE,MAAM;IAEtB,IAAID,GAAG,CAACE,IAAI,KAAK,QAAQ,EAAE;MACzB5C,GAAG,CAACwB,KAAK,CAAC,2EAA2E,CAAC;MACtF;IACF;IAEA,MAAM;MAAEqB,IAAI;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAGL,GAAG;IACjC,IAAIvB,GAAG;IACP,IAAI;MACFA,GAAG,GAAGxB,UAAU,CAACoD,KAAK,CAAC;IACzB,CAAC,CAAC,QAAO,kBAAmBZ,GAAG,EAAE;MAC/BnC,GAAG,CAACwB,KAAK,CAACW,GAAG,CAAC;MACd;IACF;IAEAnC,GAAG,CAAE,8BAA6B+C,KAAM,EAAC,CAAC;;IAE1C;IACA,IAAI,IAAI,CAACpC,OAAO,CAACf,MAAM,CAACkD,IAAI,CAAC,EAAE;MAC7B9C,GAAG,CAAC,+CAA+C,CAAC;MACpD;IACF;IAEA,IAAI,IAAI,CAACc,wBAAwB,EAAE;MACjC,IAAIkC,GAAG;MAEP,IAAI;QACFA,GAAG,GAAG,MAAM,IAAI,CAAClC,wBAAwB,CAACK,GAAG,CAAC;MAChD,CAAC,CAAC,QAAO,kBAAmBgB,GAAG,EAAE;QAC/BnC,GAAG,CAACwB,KAAK,CAAC,4CAA4C,CAAC;QACvD;MACF;MAEAL,GAAG,GAAG6B,GAAG;IACX;IAEA,IAAI;MACF,MAAM,IAAI,CAACC,4BAA4B,CAAC9B,GAAG,EAAE0B,IAAI,CAAC;IACpD,CAAC,CAAC,QAAO,kBAAmBV,GAAG,EAAE;MAC/BnC,GAAG,CAACwB,KAAK,CAACW,GAAG,CAAC;IAChB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMc,4BAA4BA,CAAE9B,GAAG,EAAE0B,IAAI,EAAExB,OAAO,EAAE;IACtD,IAAI6B,QAAQ,GAAG,KAAK;IAEpB,IAAI;MACFA,QAAQ,GAAG,MAAM,IAAI,CAACC,SAAS,CAAChC,GAAG,EAAE0B,IAAI,CAAC;IAC5C,CAAC,CAAC,QAAO,kBAAmBV,GAAG,EAAE;MAC/B,IAAIA,GAAG,CAACI,IAAI,KAAK,sBAAsB,EAAE;QACvC,MAAMJ,GAAG;MACX;IACF;IAEA,IAAIe,QAAQ,EAAE;MACZ,MAAM,IAAI,CAACE,YAAY,CAACjC,GAAG,EAAE0B,IAAI,EAAExB,OAAO,CAAC;IAC7C;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMgC,eAAeA,CAAElC,GAAG,EAAEmC,KAAK,EAAE;IAAE;IACnC,OAAO,IAAI,CAAC1C,UAAU,CAACO,GAAG,EAAEmC,KAAK,CAAC;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMC,aAAaA,CAAEpC,GAAG,EAAEqC,OAAO,EAAE;IACjC,MAAMR,GAAG,GAAG,MAAM,IAAI,CAACnC,SAAS,CAACM,GAAG,EAAEqC,OAAO,CAAC;;IAE9C;IACA,OAAOR,GAAG,KAAK,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,SAASA,CAAEhC,GAAG,EAAEC,GAAG,EAAE;IACzB,IAAI;MACF,MAAM,IAAI,CAACiC,eAAe,CAAClC,GAAG,EAAEC,GAAG,CAAC;IACtC,CAAC,CAAC,QAAO,kBAAmBe,GAAG,EAAE;MAC/B;MACA,MAAMZ,MAAM,GAAG,6CAA6C;MAE5DvB,GAAG,CAACwB,KAAK,CAACD,MAAM,CAAC;MACjB,MAAM,IAAIzB,SAAS,CAACyB,MAAM,EAAE,sBAAsB,CAAC;IACrD;;IAEA;IACA,MAAMkC,KAAK,GAAG,IAAIlE,GAAG,CAAC4B,GAAG,CAAC;IAC1B,IAAIuC,aAAa;IAEjB,IAAI;MACFA,aAAa,GAAG,MAAM,IAAI,CAACzB,SAAS,CAACwB,KAAK,CAACE,UAAU,CAAC,CAAC,CAAC;IAC1D,CAAC,CAAC,QAAO,kBAAmBxB,GAAG,EAAE;MAC/B;MACA,OAAO,IAAI;IACb;;IAEA;IACA,IAAItC,gBAAgB,CAAC6D,aAAa,EAAEtC,GAAG,CAAC,EAAE;MACxC,OAAO,KAAK;IACd;;IAEA;IACA,OAAO,IAAI,CAACmC,aAAa,CAACpC,GAAG,EAAE,CAACuC,aAAa,EAAEtC,GAAG,CAAC,CAAC;EACtD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMgC,YAAYA,CAAEjC,GAAG,EAAE0B,IAAI,EAAExB,OAAO,EAAE;IACtC;IACA,MAAMgB,UAAU,GAAG,IAAI9C,GAAG,CAAC,GAAG,GAAGE,YAAY,CAAC0B,GAAG,CAAC,EAAE,KAAK,CAAC;IAE1D,MAAM,IAAI,CAACT,UAAU,CAACQ,GAAG,CAACmB,UAAU,EAAEQ,IAAI,EAAExB,OAAO,CAAC;IACpDrB,GAAG,CAAE,cAAaN,UAAU,CAACyB,GAAG,CAAE,8BAA6B,CAAC;EAClE;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}