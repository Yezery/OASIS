{"ast":null,"code":"import _get from 'just-safe-get';\nimport debug from 'debug';\nimport errCode from 'err-code';\nimport * as migrator from 'ipfs-repo-migrations';\nimport bytes from 'bytes';\nimport merge from 'merge-options';\nimport * as CONSTANTS from './constants.js';\nimport { version } from './version.js';\nimport { config } from './config.js';\nimport { spec } from './spec.js';\nimport { apiAddr } from './api-addr.js';\nimport { createIdStore } from './idstore.js';\nimport defaultOptions from './default-options.js';\nimport defaultDatastore from './default-datastore.js';\nimport * as ERRORS from './errors.js';\nimport { PinManager } from './pin-manager.js';\nimport { createPinnedBlockstore } from './pinned-blockstore.js';\n// @ts-ignore - no types\nimport mortice from 'mortice';\nimport { gc } from './gc.js';\nconst log = debug('ipfs:repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\n\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor(path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path');\n    }\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader');\n    }\n\n    /** @type {Options} */\n    this.options = merge(defaultOptions, options);\n    this.closed = true;\n    this.path = path;\n    this.root = backends.root;\n    this.datastore = backends.datastore;\n    this.keys = backends.keys;\n    const blockstore = backends.blocks;\n    const pinstore = backends.pins;\n    this.pins = new PinManager({\n      pinstore,\n      blockstore,\n      loadCodec\n    });\n\n    // this blockstore will not delete blocks that have been pinned\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);\n\n    // this blockstore will extract blocks from multihashes with the identity codec\n    this.blocks = createIdStore(pinnedBlockstore);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n\n    /** @type {GCLock} */\n    this.gcLock = mortice({\n      name: path,\n      singleProcess: this.options.repoOwner !== false\n    });\n    this.gc = gc({\n      gcLock: this.gcLock,\n      pins: this.pins,\n      blockstore: this.blocks,\n      root: this.root,\n      loadCodec\n    });\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init(config) {\n    log('initializing at: %s', this.path);\n    await this._openRoot();\n    await this.config.replace(buildConfig(config));\n    await this.spec.set(buildDatastoreSpec(config));\n    await this.version.set(CONSTANTS.repoVersion);\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async isInitialized() {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true;\n    }\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot();\n      await this._checkInitialized();\n      await this.root.close();\n      return true;\n    } catch ( /** @type {any} */err) {\n      // FIXME: do not use exceptions for flow control\n      return false;\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open() {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n    }\n    log('opening at: %s', this.path);\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot();\n      await this._checkInitialized();\n      this._lockfile = await this._openLock();\n      log('acquired repo.lock');\n      const isCompatible = await this.version.check(CONSTANTS.repoVersion);\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(CONSTANTS.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          });\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n        }\n      }\n      log('creating datastore');\n      await this.datastore.open();\n      log('creating blocks');\n      await this.blocks.open();\n      log('creating keystore');\n      await this.keys.open();\n      log('creating pins');\n      await this.pins.pinstore.open();\n      this.closed = false;\n      log('all opened');\n    } catch ( /** @type {any} */err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock();\n          this._lockfile = null;\n        } catch ( /** @type {any} */err2) {\n          log('error removing lock', err2);\n        }\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n  async _openRoot() {\n    try {\n      await this.root.open();\n    } catch ( /** @type {any} */err) {\n      if (err.message !== 'Already open') {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n  async _openLock() {\n    const lockfile = await this.options.repoLock.lock(this.path);\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n    }\n    return lockfile;\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n  _closeLock() {\n    return this._lockfile && this._lockfile.close();\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n  async _checkInitialized() {\n    log('init check');\n    let config;\n    try {\n      [config] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n    } catch ( /** @type {any} */err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        });\n      }\n      throw err;\n    }\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      });\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close() {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n    }\n    log('closing at: %s', this.path);\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete();\n    } catch ( /** @type {any} */err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err;\n      }\n    }\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins.pinstore].map(store => store && store.close()));\n    log('unlocking');\n    this.closed = true;\n    await this._closeLock();\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n  exists() {\n    return this.version.exists();\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n  async stat() {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n      const size = blocks.size + datastore + keys;\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      };\n    }\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    });\n  }\n\n  /**\n   * @private\n   */\n  async _isAutoMigrationEnabled() {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate;\n    }\n\n    // TODO we need to figure out the priority here, between repo options and config.\n    let autoMigrateConfig;\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n    } catch ( /** @type {any} */e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true; // Config's default value is True\n      } else {\n        throw e;\n      }\n    }\n    return autoMigrateConfig;\n  }\n\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n  async _migrate(toVersion, backends) {\n    const currentRepoVersion = await this.version.get();\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`);\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      });\n    } else {\n      log(`migrating to version ${toVersion}`);\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _storageMaxStat() {\n    try {\n      const max = /** @type {number} */await this.config.get('Datastore.StorageMax');\n      return BigInt(bytes(max));\n    } catch ( /** @type {any} */err) {\n      return BigInt(noLimit);\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _blockStat() {\n    let count = BigInt(0);\n    let size = BigInt(0);\n    if (this.blocks) {\n      for await (const {\n        key,\n        value\n      } of this.blocks.query({})) {\n        count += BigInt(1);\n        size += BigInt(value.byteLength);\n        size += BigInt(key.bytes.byteLength);\n      }\n    }\n    return {\n      count,\n      size\n    };\n  }\n}\n\n/**\n * @param {Datastore} datastore\n */\nasync function getSize(datastore) {\n  let sum = BigInt(0);\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength);\n    sum += BigInt(block.key.uint8Array().byteLength);\n  }\n  return sum;\n}\n\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\nexport function createRepo(path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options);\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildConfig(_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'));\n  return _config;\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildDatastoreSpec(_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = {\n    ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  };\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":{"version":3,"names":["_get","debug","errCode","migrator","bytes","merge","CONSTANTS","version","config","spec","apiAddr","createIdStore","defaultOptions","defaultDatastore","ERRORS","PinManager","createPinnedBlockstore","mortice","gc","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","Repo","constructor","path","loadCodec","backends","options","Error","closed","root","datastore","keys","blockstore","blocks","pinstore","pins","pinnedBlockstore","gcLock","name","singleProcess","repoOwner","init","_openRoot","replace","buildConfig","set","buildDatastoreSpec","repoVersion","isInitialized","_checkInitialized","close","err","open","ERR_REPO_ALREADY_OPEN","_lockfile","_openLock","isCompatible","check","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","_closeLock","err2","message","lockfile","repoLock","lock","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","stat","storageMax","_storageMaxStat","_blockStat","get","getSize","size","repoPath","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","e","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","onProgress","onMigrationProgress","migrate","max","BigInt","key","value","query","byteLength","sum","block","uint8Array","createRepo","_config","Datastore","Object","assign","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/index.js"],"sourcesContent":["import _get from 'just-safe-get'\nimport debug from 'debug'\nimport errCode from 'err-code'\nimport * as migrator from 'ipfs-repo-migrations'\nimport bytes from 'bytes'\nimport merge from 'merge-options'\nimport * as CONSTANTS from './constants.js'\nimport { version } from './version.js'\nimport { config } from './config.js'\nimport { spec } from './spec.js'\nimport { apiAddr } from './api-addr.js'\nimport { createIdStore } from './idstore.js'\nimport defaultOptions from './default-options.js'\nimport defaultDatastore from './default-datastore.js'\nimport * as ERRORS from './errors.js'\nimport { PinManager } from './pin-manager.js'\nimport { createPinnedBlockstore } from './pinned-blockstore.js'\n// @ts-ignore - no types\nimport mortice from 'mortice'\nimport { gc } from './gc.js'\n\nconst log = debug('ipfs:repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor (path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path')\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader')\n    }\n\n    /** @type {Options} */\n    this.options = merge(defaultOptions, options)\n    this.closed = true\n    this.path = path\n    this.root = backends.root\n    this.datastore = backends.datastore\n    this.keys = backends.keys\n\n    const blockstore = backends.blocks\n    const pinstore = backends.pins\n\n    this.pins = new PinManager({ pinstore, blockstore, loadCodec })\n\n    // this blockstore will not delete blocks that have been pinned\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore)\n\n    // this blockstore will extract blocks from multihashes with the identity codec\n    this.blocks = createIdStore(pinnedBlockstore)\n\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n\n    /** @type {GCLock} */\n    this.gcLock = mortice({\n      name: path,\n      singleProcess: this.options.repoOwner !== false\n    })\n\n    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec })\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.replace(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(CONSTANTS.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (/** @type {any} */ err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n\n      this._lockfile = await this._openLock()\n      log('acquired repo.lock')\n\n      const isCompatible = await this.version.check(CONSTANTS.repoVersion)\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(CONSTANTS.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          })\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      log('creating datastore')\n      await this.datastore.open()\n\n      log('creating blocks')\n      await this.blocks.open()\n\n      log('creating keystore')\n      await this.keys.open()\n\n      log('creating pins')\n      await this.pins.pinstore.open()\n\n      this.closed = false\n      log('all opened')\n    } catch (/** @type {any} */ err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock()\n          this._lockfile = null\n        } catch (/** @type {any} */ err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (/** @type {any} */ err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n  async _openLock () {\n    const lockfile = await this.options.repoLock.lock(this.path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n  _closeLock () {\n    return this._lockfile && this._lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (/** @type {any} */ err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore,\n      this.pins.pinstore\n    ].map((store) => store && store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n  exists () {\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n  async stat () {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n        this._storageMaxStat(),\n        this._blockStat(),\n        this.version.get(),\n        getSize(this.datastore),\n        getSize(this.keys)\n      ])\n      const size = blocks.size + datastore + keys\n\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      }\n    }\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    })\n  }\n\n  /**\n   * @private\n   */\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    // TODO we need to figure out the priority here, between repo options and config.\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (/** @type {any} */ e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n  async _migrate (toVersion, backends) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`)\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    } else {\n      log(`migrating to version ${toVersion}`)\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _storageMaxStat () {\n    try {\n      const max = /** @type {number} */(await this.config.get('Datastore.StorageMax'))\n      return BigInt(bytes(max))\n    } catch (/** @type {any} */ err) {\n      return BigInt(noLimit)\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _blockStat () {\n    let count = BigInt(0)\n    let size = BigInt(0)\n\n    if (this.blocks) {\n      for await (const { key, value } of this.blocks.query({})) {\n        count += BigInt(1)\n        size += BigInt(value.byteLength)\n        size += BigInt(key.bytes.byteLength)\n      }\n    }\n\n    return { count, size }\n  }\n}\n\n/**\n * @param {Datastore} datastore\n */\nasync function getSize (datastore) {\n  let sum = BigInt(0)\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength)\n    sum += BigInt(block.key.uint8Array().byteLength)\n  }\n  return sum\n}\n\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\nexport function createRepo (path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options)\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildConfig (_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'))\n\n  return _config\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildDatastoreSpec (_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = {\n    ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  }\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}