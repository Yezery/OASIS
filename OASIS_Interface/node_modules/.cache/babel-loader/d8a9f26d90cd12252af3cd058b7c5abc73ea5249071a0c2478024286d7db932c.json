{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n// @ts-ignore\n!globalThis.process.browser &&\n// @ts-ignore\nglobalThis.Buffer &&\n// @ts-ignore\ntypeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer(buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A(buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} bytes\n * @param {number} start\n * @param {number} end\n */\n(bytes, start, end) => {\n  return end - start > 64 ?\n  // eslint-disable-line operator-linebreak\n  // @ts-ignore\n  globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n}\n/* c8 ignore next 11 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} bytes\n * @param {number} start\n * @param {number} end\n */\n(bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {string} string\n */\nstring => {\n  return string.length > 64 ?\n  // eslint-disable-line operator-linebreak\n  // @ts-ignore\n  globalThis.Buffer.from(string) : utf8ToBytes(string);\n}\n/* c8 ignore next 7 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {string} string\n */\nstring => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} bytes\n * @param {number} start\n * @param {number} end\n */\n(bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n}\n/* c8 ignore next 9 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} bytes\n * @param {number} start\n * @param {number} end\n */\n(bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\n(chunks, length) => {\n  // might get a stray plain Array here\n  /* c8 ignore next 1 */\n  chunks = chunks.map(c => c instanceof Uint8Array ? c\n  // this case is occasionally missed during test runs so becomes coverage-flaky\n  /* c8 ignore next 4 */ :\n  // eslint-disable-line operator-linebreak\n  // @ts-ignore\n  globalThis.Buffer.from(c));\n  // @ts-ignore\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n}\n/* c8 ignore next 19 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\n(chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      // final chunk that's bigger than we need\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {number} size\n * @returns {Uint8Array}\n */\nsize => {\n  // we always write over the contents we expose so this should be safe\n  // @ts-ignore\n  return globalThis.Buffer.allocUnsafe(size);\n}\n/* c8 ignore next 8 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {number} size\n * @returns {Uint8Array}\n */\nsize => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} d\n * @returns {string}\n */\nd => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  // @ts-ignore\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n}\n/* c8 ignore next 12 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {Uint8Array} d\n * @returns {string}\n */\nd => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  // @ts-ignore not smart enough to figure this out\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '');\n};\nexport const fromHex = useBuffer ?\n// eslint-disable-line operator-linebreak\n/**\n * @param {string|Uint8Array} hex\n * @returns {Uint8Array}\n */\nhex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  // @ts-ignore\n  return globalThis.Buffer.from(hex, 'hex');\n}\n/* c8 ignore next 17 */ :\n// eslint-disable-line operator-linebreak\n/**\n * @param {string|Uint8Array} hex\n * @returns {Uint8Array}\n */\nhex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map(( /** @type {string} */c, /** @type {number} */i, /** @type {string[]} */d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '').filter(Boolean).map(( /** @type {string} */e) => parseInt(e, 16)));\n};\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type');\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare(b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  } /* c8 ignore next 3 */\n  return 0;\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes(str) {\n  const out = [];\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if ((c & 0xFC00) === 0xD800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n  return out;\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[offset + 1];\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | secondByte & 0x3f;\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | thirdByte & 0x3f;\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n          fourthByte = buf[offset + 3];\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | fourthByte & 0x3f;\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800);\n      codePoint = 0xdc00 | codePoint & 0x3ff;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}","map":{"version":3,"names":["useBuffer","globalThis","process","browser","Buffer","isBuffer","textDecoder","TextDecoder","textEncoder","TextEncoder","buf","asU8A","Uint8Array","from","buffer","byteOffset","byteLength","toString","bytes","start","end","subarray","utf8Slice","decode","fromString","string","length","utf8ToBytes","encode","fromArray","arr","slice","concat","chunks","map","c","out","off","b","set","alloc","size","allocUnsafe","toHex","d","toBytes","Array","prototype","reduce","call","p","padStart","fromHex","hex","split","i","filter","Boolean","e","parseInt","obj","constructor","name","ArrayBuffer","isView","Error","compare","b1","b2","str","charCodeAt","offset","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","len","String","fromCharCode","apply"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/byte-utils.js"],"sourcesContent":["// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}