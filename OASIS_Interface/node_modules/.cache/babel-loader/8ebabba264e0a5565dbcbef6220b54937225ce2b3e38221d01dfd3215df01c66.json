{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { validateAddrs } from './utils.js';\nimport { StreamHandler } from './stream-handler.js';\nimport { CircuitRelay as CircuitPB } from '../pb/index.js';\nimport { pipe } from 'it-pipe';\nimport { codes as Errors } from '../../errors.js';\nimport { stop } from './stop.js';\nimport { RELAY_CODEC } from '../multicodec.js';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nconst log = logger('libp2p:circuit:hop');\nexport async function handleHop(hopRequest) {\n  const {\n    connection,\n    request,\n    streamHandler,\n    circuit,\n    connectionManager\n  } = hopRequest;\n  // Ensure hop is enabled\n  if (!circuit.hopEnabled()) {\n    log('HOP request received but we are not acting as a relay');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    });\n  }\n  // Validate the HOP request has the required input\n  try {\n    validateAddrs(request, streamHandler);\n  } catch (err) {\n    log.error('invalid hop request via peer %p %o', connection.remotePeer, err);\n    return;\n  }\n  if (request.dstPeer == null) {\n    log('HOP request received but we do not receive a dstPeer');\n    return;\n  }\n  // Get the connection to the destination (stop) peer\n  const destinationPeer = peerIdFromBytes(request.dstPeer.id);\n  const destinationConnections = connectionManager.getConnections(destinationPeer);\n  if (destinationConnections.length === 0 && !circuit.hopActive()) {\n    log('HOP request received but we are not connected to the destination peer');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    });\n  }\n  // TODO: Handle being an active relay\n  if (destinationConnections.length === 0) {\n    log('did not have connection to remote peer');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    });\n  }\n  // Handle the incoming HOP request by performing a STOP request\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  };\n  let destinationStream;\n  try {\n    log('performing STOP request');\n    const result = await stop({\n      connection: destinationConnections[0],\n      request: stopRequest\n    });\n    if (result == null) {\n      throw new Error('Could not stop');\n    }\n    destinationStream = result;\n  } catch (err) {\n    log.error(err);\n    return;\n  }\n  log('hop request from %p is valid', connection.remotePeer);\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  });\n  const sourceStream = streamHandler.rest();\n  log('creating related connections');\n  // Short circuit the two streams to create the relayed connection\n  return await pipe(sourceStream, destinationStream, sourceStream);\n}\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n */\nexport async function hop(options) {\n  const {\n    connection,\n    request,\n    signal\n  } = options;\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  });\n  // Send the HOP request\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write(request);\n  const response = await streamHandler.read();\n  if (response == null) {\n    throw errCode(new Error('HOP request had no response'), Errors.ERR_HOP_REQUEST_FAILED);\n  }\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful');\n    return streamHandler.rest();\n  }\n  log('hop request failed with code %d, closing stream', response.code);\n  streamHandler.close();\n  throw errCode(new Error(`HOP request failed with code \"${response.code ?? 'unknown'}\"`), Errors.ERR_HOP_REQUEST_FAILED);\n}\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities\n */\nexport async function canHop(options) {\n  const {\n    connection,\n    signal\n  } = options;\n  // Create a new stream to the relay\n  const stream = await connection.newStream(RELAY_CODEC, {\n    signal\n  });\n  // Send the HOP request\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write({\n    type: CircuitPB.Type.CAN_HOP\n  });\n  const response = await streamHandler.read();\n  await streamHandler.close();\n  if (response == null || response.code !== CircuitPB.Status.SUCCESS) {\n    return false;\n  }\n  return true;\n}\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n */\nexport function handleCanHop(options) {\n  const {\n    connection,\n    streamHandler,\n    circuit\n  } = options;\n  const canHop = circuit.hopEnabled();\n  log('can hop (%s) request from %p', canHop, connection.remotePeer);\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n}","map":{"version":3,"names":["logger","errCode","validateAddrs","StreamHandler","CircuitRelay","CircuitPB","pipe","codes","Errors","stop","RELAY_CODEC","peerIdFromBytes","log","handleHop","hopRequest","connection","request","streamHandler","circuit","connectionManager","hopEnabled","end","type","Type","STATUS","code","Status","HOP_CANT_SPEAK_RELAY","err","error","remotePeer","dstPeer","destinationPeer","id","destinationConnections","getConnections","length","hopActive","HOP_NO_CONN_TO_DST","stopRequest","STOP","srcPeer","destinationStream","result","Error","write","SUCCESS","sourceStream","rest","hop","options","signal","stream","newStream","response","read","ERR_HOP_REQUEST_FAILED","close","canHop","CAN_HOP","handleCanHop"],"sources":["../../../../src/circuit/circuit/hop.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}