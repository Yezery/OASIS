{"ast":null,"code":"/**\n * @template Key, Value\n * SortedMap is a Map whose iterator order can be defined by the user\n * @extends {Map<Key, Value>}\n */\nexport class SortedMap extends Map {\n  /**\n   * @param {Array<[Key, Value]>} [entries]\n   * @param {(a:[Key, Value], b:[Key, Value]) => number} [cmp] - compares [k1, v1] to [k2, v2]\n   */\n  constructor(entries, cmp) {\n    super();\n    this._cmp = cmp || this._defaultSort;\n    /** @type {Key[]} */\n    this._keys = [];\n    for (const [k, v] of entries || []) {\n      this.set(k, v);\n    }\n  }\n\n  /**\n   * Call update to update the position of the key when it should change.\n   * For example if the compare function sorts by the priority field, and the\n   * priority changes, call update.\n   * Call indexOf() to get the index _before_ the change happens.\n   *\n   * @param {number} i - the index of entry whose position should be updated.\n   */\n  update(i) {\n    if (i < 0 || i >= this._keys.length) {\n      return;\n    }\n    const k = this._keys[i];\n    this._keys.splice(i, 1);\n    const newIdx = this._find(k);\n    this._keys.splice(newIdx, 0, k);\n  }\n\n  /**\n   * @param {Key} k\n   * @param {Value} v\n   */\n  set(k, v) {\n    // If the key is already in the map, remove it from the ordering and\n    // re-insert it below\n    if (this.has(k)) {\n      const i = this.indexOf(k);\n      this._keys.splice(i, 1);\n    }\n\n    // Update / insert the k/v into the map\n    super.set(k, v);\n\n    // Find the correct position of the newly inserted k/v in the order\n    const i = this._find(k);\n    this._keys.splice(i, 0, k);\n    return this;\n  }\n  clear() {\n    super.clear();\n    this._keys = [];\n  }\n\n  /**\n   * @param {Key} k\n   */\n  delete(k) {\n    if (!this.has(k)) {\n      return false;\n    }\n    const i = this.indexOf(k);\n    this._keys.splice(i, 1);\n    return super.delete(k);\n  }\n\n  /**\n   * @param {Key} k\n   */\n  indexOf(k) {\n    if (!this.has(k)) {\n      return -1;\n    }\n    const i = this._find(k);\n    if (this._keys[i] === k) {\n      return i;\n    }\n\n    // There may be more than one key with the same ordering\n    // eg { k1: <priority 5>, k2: <priority 5> }\n    // so scan outwards until the key matches\n    for (let j = 1; j < this._keys.length; j++) {\n      if (this._keys[i + j] === k) return i + j;\n      if (this._keys[i - j] === k) return i - j;\n    }\n    return -1; // should never happen for existing key\n  }\n\n  /**\n   * @private\n   * @param {Key} k\n   * @returns {number}\n   */\n\n  _find(k) {\n    let lower = 0;\n    let upper = this._keys.length;\n    while (lower < upper) {\n      const pivot = lower + upper >>> 1; // lower + (upper - lower) / 2\n      const cmp = this._kCmp(this._keys[pivot], k);\n      // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n      if (cmp < 0) {\n        // pivot < k\n        lower = pivot + 1;\n      } else if (cmp > 0) {\n        // pivot > k\n        upper = pivot;\n      } else {\n        // pivot == k\n        return pivot;\n      }\n    }\n    return lower;\n  }\n  *keys() {\n    for (const k of this._keys) {\n      yield k;\n    }\n    return undefined;\n  }\n\n  /**\n   * @returns {IterableIterator<Value>}\n   */\n  *values() {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield this.get(k);\n    }\n    return undefined;\n  }\n\n  /**\n   * @returns {IterableIterator<[Key, Value]>}\n   */\n  *entries() {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield [k, this.get(k)];\n    }\n    return undefined;\n  }\n  *[Symbol.iterator]() {\n    yield* this.entries();\n  }\n\n  /**\n   * @template This\n   * @param {(entry:[Key, Value]) => void} cb\n   * @param {This} [thisArg]\n   */\n  // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n  forEach(cb, thisArg) {\n    if (!cb) {\n      return;\n    }\n    for (const k of this._keys) {\n      cb.apply(thisArg, [[k, /** @type {Value} */this.get(k)]]);\n    }\n  }\n\n  /**\n   * @private\n   * @param {[Key, Value]} a\n   * @param {[Key, Value]} b\n   * @returns {0|1|-1}\n   */\n  _defaultSort(a, b) {\n    if (a[0] < b[0]) return -1;\n    if (b[0] < a[0]) return 1;\n    return 0;\n  }\n\n  /**\n   * @private\n   * @param {Key} a\n   * @param {Key} b\n   */\n  _kCmp(a, b) {\n    return this._cmp(\n    // @ts-ignore - get may return undefined\n    [a, this.get(a)],\n    // @ts-ignore - get may return undefined\n    [b, this.get(b)]);\n  }\n}","map":{"version":3,"names":["SortedMap","Map","constructor","entries","cmp","_cmp","_defaultSort","_keys","k","v","set","update","i","length","splice","newIdx","_find","has","indexOf","clear","delete","j","lower","upper","pivot","_kCmp","keys","undefined","values","get","Symbol","iterator","forEach","cb","thisArg","apply","a","b"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/utils/sorted-map.js"],"sourcesContent":["/**\n * @template Key, Value\n * SortedMap is a Map whose iterator order can be defined by the user\n * @extends {Map<Key, Value>}\n */\nexport class SortedMap extends Map {\n  /**\n   * @param {Array<[Key, Value]>} [entries]\n   * @param {(a:[Key, Value], b:[Key, Value]) => number} [cmp] - compares [k1, v1] to [k2, v2]\n   */\n  constructor (entries, cmp) {\n    super()\n    this._cmp = cmp || this._defaultSort\n    /** @type {Key[]} */\n    this._keys = []\n    for (const [k, v] of entries || []) {\n      this.set(k, v)\n    }\n  }\n\n  /**\n   * Call update to update the position of the key when it should change.\n   * For example if the compare function sorts by the priority field, and the\n   * priority changes, call update.\n   * Call indexOf() to get the index _before_ the change happens.\n   *\n   * @param {number} i - the index of entry whose position should be updated.\n   */\n  update (i) {\n    if (i < 0 || i >= this._keys.length) {\n      return\n    }\n\n    const k = this._keys[i]\n    this._keys.splice(i, 1)\n    const newIdx = this._find(k)\n    this._keys.splice(newIdx, 0, k)\n  }\n\n  /**\n   * @param {Key} k\n   * @param {Value} v\n   */\n  set (k, v) {\n    // If the key is already in the map, remove it from the ordering and\n    // re-insert it below\n    if (this.has(k)) {\n      const i = this.indexOf(k)\n      this._keys.splice(i, 1)\n    }\n\n    // Update / insert the k/v into the map\n    super.set(k, v)\n\n    // Find the correct position of the newly inserted k/v in the order\n    const i = this._find(k)\n    this._keys.splice(i, 0, k)\n\n    return this\n  }\n\n  clear () {\n    super.clear()\n    this._keys = []\n  }\n\n  /**\n   * @param {Key} k\n   */\n  delete (k) {\n    if (!this.has(k)) {\n      return false\n    }\n\n    const i = this.indexOf(k)\n    this._keys.splice(i, 1)\n    return super.delete(k)\n  }\n\n  /**\n   * @param {Key} k\n   */\n  indexOf (k) {\n    if (!this.has(k)) {\n      return -1\n    }\n\n    const i = this._find(k)\n    if (this._keys[i] === k) {\n      return i\n    }\n\n    // There may be more than one key with the same ordering\n    // eg { k1: <priority 5>, k2: <priority 5> }\n    // so scan outwards until the key matches\n    for (let j = 1; j < this._keys.length; j++) {\n      if (this._keys[i + j] === k) return i + j\n      if (this._keys[i - j] === k) return i - j\n    }\n\n    return -1 // should never happen for existing key\n  }\n\n  /**\n   * @private\n   * @param {Key} k\n   * @returns {number}\n   */\n\n  _find (k) {\n    let lower = 0\n    let upper = this._keys.length\n    while (lower < upper) {\n      const pivot = (lower + upper) >>> 1 // lower + (upper - lower) / 2\n      const cmp = this._kCmp(this._keys[pivot], k)\n      // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n      if (cmp < 0) { // pivot < k\n        lower = pivot + 1\n      } else if (cmp > 0) { // pivot > k\n        upper = pivot\n      } else { // pivot == k\n        return pivot\n      }\n    }\n    return lower\n  }\n\n  * keys () {\n    for (const k of this._keys) {\n      yield k\n    }\n\n    return undefined\n  }\n\n  /**\n   * @returns {IterableIterator<Value>}\n   */\n  * values () {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield this.get(k)\n    }\n\n    return undefined\n  }\n\n  /**\n   * @returns {IterableIterator<[Key, Value]>}\n   */\n  * entries () {\n    for (const k of this._keys) {\n      // @ts-ignore - return of `this.get(k)` is `Value|undefined` which is\n      // incompatible with `Value`. Typechecker can't that this contains values\n      // for all the `_keys`. ts(2322)\n      yield [k, this.get(k)]\n    }\n\n    return undefined\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.entries()\n  }\n\n  /**\n   * @template This\n   * @param {(entry:[Key, Value]) => void} cb\n   * @param {This} [thisArg]\n   */\n  // @ts-expect-error - Callback in Map forEach is (V, K, Map<K, V>) => void\n  forEach (cb, thisArg) {\n    if (!cb) {\n      return\n    }\n\n    for (const k of this._keys) {\n      cb.apply(thisArg, [[k, /** @type {Value} */(this.get(k))]])\n    }\n  }\n\n  /**\n   * @private\n   * @param {[Key, Value]} a\n   * @param {[Key, Value]} b\n   * @returns {0|1|-1}\n   */\n  _defaultSort (a, b) {\n    if (a[0] < b[0]) return -1\n    if (b[0] < a[0]) return 1\n    return 0\n  }\n\n  /**\n   * @private\n   * @param {Key} a\n   * @param {Key} b\n   */\n  _kCmp (a, b) {\n    return this._cmp(\n      // @ts-ignore - get may return undefined\n      [a, this.get(a)],\n      // @ts-ignore - get may return undefined\n      [b, this.get(b)]\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}