{"ast":null,"code":"import mergeOpts from 'merge-options';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { toTrail } from './utils/to-trail.js';\nimport { addLink } from './utils/add-link.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { pipe } from 'it-pipe';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { recursive } from 'ipfs-unixfs-exporter';\nimport last from 'it-last';\nimport { createCp } from './cp.js';\nimport { createRm } from './rm.js';\nimport { persist } from './utils/persist.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:mfs:touch');\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n  return modification;\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n  return ugo;\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n  return modification;\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n  let [, references, operator, mode] = match;\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8);\n\n      // or them together\n      originalMode = originalMode | modification;\n    }\n    return originalMode;\n  }\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n  return originalMode;\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n  return mode;\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createChmod(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  async function mfsChmod(path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts);\n    if (cid.code !== dagPB.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of recursive(cid, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPB.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      },\n      // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n      source => importer(source, context.repo.blocks, {\n        ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              /** @type {PBNode} */\n              // @ts-expect-error - cannot derive type\n              const node = entry.content;\n              const buf = dagPB.encode(node);\n              const cid = await persist(buf, block, opts);\n              if (!node.Data) {\n                throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n              }\n              const unixfs = UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes));\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n      }\n\n      // remove old path from mfs\n      await createRm(context)(path, opts);\n\n      // add newly created tree to mfs at path\n      await createCp(context)(`/ipfs/${root.cid}`, path, opts);\n      return;\n    }\n    const block = await context.repo.blocks.get(cid);\n    const node = dagPB.decode(block);\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n    }\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPB.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = CID.create(opts.cidVersion, dagPB.code, hash);\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB.decode(parentBlock);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid;\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts);\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n  return withTimeoutOption(mfsChmod);\n}","map":{"version":3,"names":["mergeOpts","toMfsPath","logger","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPB","CID","pipe","importer","recursive","last","createCp","createRm","persist","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","createChmod","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","root","entry","repo","blocks","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","get","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/chmod.js"],"sourcesContent":["import mergeOpts from 'merge-options'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { toTrail } from './utils/to-trail.js'\nimport { addLink } from './utils/add-link.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { pipe } from 'it-pipe'\nimport { importer } from 'ipfs-unixfs-importer'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport last from 'it-last'\nimport { createCp } from './cp.js'\nimport { createRm } from './rm.js'\nimport { persist } from './utils/persist.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:touch')\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createChmod (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPB.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPB.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-expect-error we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-expect-error - cannot derive type\n                const node = entry.content\n\n                const buf = dagPB.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await createRm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await createCp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPB.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPB.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPB.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}