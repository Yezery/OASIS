{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Bucket, createHAMT } from 'hamt-sharding';\nimport { decode } from '@ipld/dag-pb';\nimport { murmur3128 } from '@multiformats/murmur3';\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('../types').ExporterOptions} ExporterOptions\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\n/**\n * @param {Uint8Array} buf\n */\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf)\n  // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n  // implementation only uses the first 64, so we must do the same\n  // for parity..\n  ).slice(0, 8)\n  // Invert buffer because that's how Go impl does it\n  .reverse();\n};\n\n/**\n * @param {PBLink[]} links\n * @param {Bucket<boolean>} bucket\n * @param {Bucket<boolean>} rootBucket\n */\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      // TODO(@rvagg): what do? this is technically possible\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\n/**\n * @param {number} position\n */\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\n/**\n * @param {import('hamt-sharding').BucketPosition<boolean>} position\n */\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\n\n/**\n * @typedef {import('../types').ShardTraversalContext} ShardTraversalContext\n *\n * @param {PBNode} node\n * @param {string} name\n * @param {Blockstore} blockstore\n * @param {ShardTraversalContext} [context]\n * @param {ExporterOptions} [options]\n * @returns {Promise<CID|null>}\n */\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({\n      hashFn\n    });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false;\n    }\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return false;\n    }\n    return true;\n  });\n  if (!link) {\n    return null;\n  }\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\nexport default findShardCid;","map":{"version":3,"names":["Bucket","createHAMT","decode","murmur3128","hashFn","buf","encode","slice","reverse","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","Error","length","pos","parseInt","_putObjectAt","hash","_options","bits","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","findShardCid","node","name","blockstore","context","options","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","block","get"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-exporter@10.0.1/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js"],"sourcesContent":["\nimport { Bucket, createHAMT } from 'hamt-sharding'\nimport { decode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('../types').ExporterOptions} ExporterOptions\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\n/**\n * @param {Uint8Array} buf\n */\nconst hashFn = async function (buf) {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\n/**\n * @param {PBLink[]} links\n * @param {Bucket<boolean>} bucket\n * @param {Bucket<boolean>} rootBucket\n */\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(\n    links.map(link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        return bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n      }\n\n      return rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\n/**\n * @param {number} position\n */\nconst toPrefix = (position) => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\n/**\n * @param {import('hamt-sharding').BucketPosition<boolean>} position\n */\nconst toBucketPath = (position) => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\n/**\n * @typedef {import('../types').ShardTraversalContext} ShardTraversalContext\n *\n * @param {PBNode} node\n * @param {string} name\n * @param {Blockstore} blockstore\n * @param {ShardTraversalContext} [context]\n * @param {ExporterOptions} [options]\n * @returns {Promise<CID|null>}\n */\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = createHAMT({\n      hashFn\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (!link) {\n    return null\n  }\n\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}