{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { resolvePath } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input';\nimport { PinTypes } from 'ipfs-repo/pin-types';\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createAddAll({\n  repo,\n  codecs\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  async function* addAll(source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput(source)) {\n        const {\n          cid\n        } = await resolvePath(repo, codecs, path);\n\n        // verify that each hash can be pinned\n        const {\n          reason\n        } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`);\n        }\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await repo.pins.pinDirectly(cid, {\n            metadata\n          });\n        }\n        yield cid;\n      }\n    };\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock);\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n    const release = await repo.gcLock.readLock();\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption(addAll);\n}","map":{"version":3,"names":["resolvePath","withTimeoutOption","normaliseInput","PinTypes","createAddAll","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","pins","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/pin/add-all.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { resolvePath } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { normaliseInput } from 'ipfs-core-utils/pins/normalise-input'\nimport { PinTypes } from 'ipfs-repo/pin-types'\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {object} config\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createAddAll ({ repo, codecs }) {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API<{}>[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"],"mappings":"AAAA;;AAEA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,iBAAiB,QAAQ,qCAAqC;AACvE,SAASC,cAAc,QAAQ,sCAAsC;AACrE,SAASC,QAAQ,QAAQ,qBAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAAE;EAAEC,IAAI;EAAEC;AAAO,CAAC,EAAE;EAC9C;AACF;AACA;EACE,gBAAiBC,MAAMA,CAAEC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC7C;AACJ;AACA;IACI,MAAMC,MAAM,GAAG,gBAAAA,CAAA,EAAoB;MACjC,WAAW,MAAM;QAAEC,IAAI;QAAEC,SAAS;QAAEC;MAAS,CAAC,IAAIX,cAAc,CAACM,MAAM,CAAC,EAAE;QACxE,MAAM;UAAEM;QAAI,CAAC,GAAG,MAAMd,WAAW,CAACK,IAAI,EAAEC,MAAM,EAAEK,IAAI,CAAC;;QAErD;QACA,MAAM;UAAEI;QAAO,CAAC,GAAG,MAAMV,IAAI,CAACW,IAAI,CAACC,gBAAgB,CAACH,GAAG,EAAE,CAACX,QAAQ,CAACS,SAAS,EAAET,QAAQ,CAACe,MAAM,CAAC,CAAC;QAE/F,IAAIH,MAAM,KAAK,WAAW,IAAI,CAACH,SAAS,EAAE;UACxC;UACA,MAAM,IAAIO,KAAK,CAAE,GAAEL,GAAI,6BAA4B,CAAC;QACtD;QAEA,IAAIF,SAAS,EAAE;UACb,MAAMP,IAAI,CAACW,IAAI,CAACI,cAAc,CAACN,GAAG,EAAE;YAAED;UAAS,CAAC,CAAC;QACnD,CAAC,MAAM;UACL,MAAMR,IAAI,CAACW,IAAI,CAACK,WAAW,CAACP,GAAG,EAAE;YAAED;UAAS,CAAC,CAAC;QAChD;QAEA,MAAMC,GAAG;MACX;IACF,CAAC;;IAED;IACA;IACA,MAAMQ,IAAI,GAAGC,OAAO,CAACd,OAAO,CAACa,IAAI,CAAC;IAElC,IAAI,CAACA,IAAI,EAAE;MACT,OAAQZ,MAAM,CAAC,CAAC;MAChB;IACF;IAEA,MAAMc,OAAO,GAAG,MAAMnB,IAAI,CAACoB,MAAM,CAACC,QAAQ,CAAC,CAAC;IAE5C,IAAI;MACF,OAAQhB,MAAM,CAAC,CAAC;IAClB,CAAC,SAAS;MACRc,OAAO,CAAC,CAAC;IACX;EACF;EAEA,OAAOvB,iBAAiB,CAACM,MAAM,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}