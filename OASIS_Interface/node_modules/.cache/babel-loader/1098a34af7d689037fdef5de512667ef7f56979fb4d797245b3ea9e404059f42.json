{"ast":null,"code":"/* eslint max-depth: [\"error\", 6] */\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { unsigned } from 'uint8-varint';\nimport errCode from 'err-code';\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n  ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n  ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = buf => {\n  const length = unsigned.decode(buf);\n  defaultDecoder.bytes = unsigned.encodingLength(length);\n  return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(options) {\n  const decoder = async function* (source) {\n    const buffer = new Uint8ArrayList();\n    let mode = ReadMode.LENGTH;\n    let dataLength = -1;\n    const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n    const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n    const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n    for await (const buf of source) {\n      buffer.append(buf);\n      while (buffer.byteLength > 0) {\n        if (mode === ReadMode.LENGTH) {\n          // read length, ignore errors for short reads\n          try {\n            dataLength = lengthDecoder(buffer);\n            if (dataLength < 0) {\n              throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n            }\n            if (dataLength > maxDataLength) {\n              throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n            }\n            const dataLengthLength = lengthDecoder.bytes;\n            buffer.consume(dataLengthLength);\n            if (options?.onLength != null) {\n              options.onLength(dataLength);\n            }\n            mode = ReadMode.DATA;\n          } catch (err) {\n            if (err instanceof RangeError) {\n              if (buffer.byteLength > maxLengthLength) {\n                throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n              }\n              break;\n            }\n            throw err;\n          }\n        }\n        if (mode === ReadMode.DATA) {\n          if (buffer.byteLength < dataLength) {\n            // not enough data, wait for more\n            break;\n          }\n          const data = buffer.sublist(0, dataLength);\n          buffer.consume(dataLength);\n          if (options?.onData != null) {\n            options.onData(data);\n          }\n          yield data;\n          mode = ReadMode.LENGTH;\n        }\n      }\n    }\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n    }\n  };\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n  const varByteSource = async function* () {\n    while (true) {\n      try {\n        const {\n          done,\n          value\n        } = await reader.next(byteLength);\n        if (done === true) {\n          return;\n        }\n        if (value != null) {\n          yield value;\n        }\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  }();\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = l => {\n    byteLength = l;\n  };\n  return decode({\n    ...(options ?? {}),\n    onLength\n  })(varByteSource);\n};","map":{"version":3,"names":["Uint8ArrayList","unsigned","errCode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","buf","length","decode","bytes","encodingLength","options","decoder","source","buffer","mode","LENGTH","dataLength","lengthDecoder","maxLengthLength","maxDataLength","append","byteLength","Error","dataLengthLength","consume","onLength","DATA","err","RangeError","data","sublist","onData","fromReader","reader","varByteSource","done","value","next","code","l"],"sources":["../../src/decode.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}