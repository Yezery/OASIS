{"ast":null,"code":"import process from 'node:process';\nimport { signalsByName } from 'human-signals';\nconst getErrorPrefix = ({\n  timedOut,\n  timeout,\n  errorCode,\n  signal,\n  signalDescription,\n  exitCode,\n  isCanceled\n}) => {\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n  if (isCanceled) {\n    return 'was canceled';\n  }\n  if (errorCode !== undefined) {\n    return `failed with ${errorCode}`;\n  }\n  if (signal !== undefined) {\n    return `was killed with ${signal} (${signalDescription})`;\n  }\n  if (exitCode !== undefined) {\n    return `failed with exit code ${exitCode}`;\n  }\n  return 'failed';\n};\nexport const makeError = ({\n  stdout,\n  stderr,\n  all,\n  error,\n  signal,\n  exitCode,\n  command,\n  escapedCommand,\n  timedOut,\n  isCanceled,\n  killed,\n  parsed: {\n    options: {\n      timeout,\n      cwd = process.cwd()\n    }\n  }\n}) => {\n  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n  // We normalize them to `undefined`\n  exitCode = exitCode === null ? undefined : exitCode;\n  signal = signal === null ? undefined : signal;\n  const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n  const errorCode = error && error.code;\n  const prefix = getErrorPrefix({\n    timedOut,\n    timeout,\n    errorCode,\n    signal,\n    signalDescription,\n    exitCode,\n    isCanceled\n  });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const isError = Object.prototype.toString.call(error) === '[object Error]';\n  const shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n  if (isError) {\n    error.originalMessage = error.message;\n    error.message = message;\n  } else {\n    error = new Error(message);\n  }\n  error.shortMessage = shortMessage;\n  error.command = command;\n  error.escapedCommand = escapedCommand;\n  error.exitCode = exitCode;\n  error.signal = signal;\n  error.signalDescription = signalDescription;\n  error.stdout = stdout;\n  error.stderr = stderr;\n  error.cwd = cwd;\n  if (all !== undefined) {\n    error.all = all;\n  }\n  if ('bufferedData' in error) {\n    delete error.bufferedData;\n  }\n  error.failed = true;\n  error.timedOut = Boolean(timedOut);\n  error.isCanceled = isCanceled;\n  error.killed = killed && !timedOut;\n  return error;\n};","map":{"version":3,"names":["process","signalsByName","getErrorPrefix","timedOut","timeout","errorCode","signal","signalDescription","exitCode","isCanceled","undefined","makeError","stdout","stderr","all","error","command","escapedCommand","killed","parsed","options","cwd","description","code","prefix","execaMessage","isError","Object","prototype","toString","call","shortMessage","message","filter","Boolean","join","originalMessage","Error","bufferedData","failed"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/execa@7.2.0/node_modules/execa/lib/error.js"],"sourcesContent":["import process from 'node:process';\nimport {signalsByName} from 'human-signals';\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nexport const makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout, cwd = process.cwd()}},\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\terror.cwd = cwd;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}