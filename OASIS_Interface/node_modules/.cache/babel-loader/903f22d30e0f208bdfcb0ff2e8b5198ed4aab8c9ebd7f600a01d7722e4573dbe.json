{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { Key } from 'interface-datastore/key';\nimport debug from 'debug';\nimport length from 'it-length';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as mhd from 'multiformats/hashes/digest';\nconst log = debug('ipfs:repo:migrator:migration-8');\n\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap(blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child);\n  }\n  return blockstore;\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes;\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();\n    return new Key(`/${multihashStr}`, false);\n  } catch ( /** @type {any} */err) {\n    return key;\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);\n    const digest = mhd.decode(buf);\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1);\n    return new Key(`/${multihash.toUpperCase()}`, false);\n  } catch {\n    return key;\n  }\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process(backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks;\n  await blockstore.open();\n  const unwrapped = unwrap(blockstore);\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [key => {\n      const newKey = keyFunction(key);\n      return newKey.toString() !== key.toString();\n    }]\n  }));\n  try {\n    let counter = 0;\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key);\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1;\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));\n        await unwrapped.delete(block.key);\n        await unwrapped.put(newKey, block.value);\n        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);\n      }\n    }\n  } finally {\n    await blockstore.close();\n  }\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid);\n  }\n};","map":{"version":3,"names":["CID","Key","debug","length","base32","raw","mhd","log","unwrap","blockstore","child","keyToMultihash","key","buf","decode","toString","toLowerCase","slice","multihash","bytes","multihashStr","encode","toUpperCase","err","keyToCid","digest","createV1","code","process","backends","onProgress","keyFunction","blocks","open","unwrapped","blockCount","queryKeys","filters","newKey","counter","block","query","has","delete","put","value","close","migration","version","description","migrate","revert"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/migrations/migration-8/index.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport { Key } from 'interface-datastore/key'\nimport debug from 'debug'\nimport length from 'it-length'\nimport { base32 } from 'multiformats/bases/base32'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as mhd from 'multiformats/hashes/digest'\n\nconst log = debug('ipfs:repo:migrator:migration-8')\n\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap (blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child)\n  }\n\n  return blockstore\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase()\n\n    return new Key(`/${multihashStr}`, false)\n  } catch (/** @type {any} */ err) {\n    return key\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n    const digest = mhd.decode(buf)\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1)\n\n    return new Key(`/${multihash.toUpperCase()}`, false)\n  } catch {\n    return key\n  }\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process (backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks\n  await blockstore.open()\n\n  const unwrapped = unwrap(blockstore)\n\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [(key) => {\n      const newKey = keyFunction(key)\n\n      return newKey.toString() !== key.toString()\n    }]\n  }))\n\n  try {\n    let counter = 0\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key))\n\n        await unwrapped.delete(block.key)\n        await unwrapped.put(newKey, block.value)\n\n        onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid)\n  }\n}\n"],"mappings":"AACA,SAASA,GAAG,QAAQ,kBAAkB;AACtC,SAASC,GAAG,QAAQ,yBAAyB;AAC7C,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,WAAW;AAC9B,SAASC,MAAM,QAAQ,2BAA2B;AAClD,OAAO,KAAKC,GAAG,MAAM,yBAAyB;AAC9C,OAAO,KAAKC,GAAG,MAAM,4BAA4B;AAEjD,MAAMC,GAAG,GAAGL,KAAK,CAAC,gCAAgC,CAAC;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAASM,MAAMA,CAAEC,UAAU,EAAE;EAC3B,IAAIA,UAAU,CAACC,KAAK,EAAE;IACpB,OAAOF,MAAM,CAACC,UAAU,CAACC,KAAK,CAAC;EACjC;EAEA,OAAOD,UAAU;AACnB;;AAEA;AACA;AACA;AACA,SAASE,cAAcA,CAAEC,GAAG,EAAE;EAC5B,IAAI;IACF,MAAMC,GAAG,GAAGT,MAAM,CAACU,MAAM,CAAE,IAAGF,GAAG,CAACG,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAE,EAAC,CAAC;;IAEtE;IACA,MAAMC,SAAS,GAAGlB,GAAG,CAACc,MAAM,CAACD,GAAG,CAAC,CAACK,SAAS,CAACC,KAAK;;IAEjD;IACA;IACA,MAAMC,YAAY,GAAGhB,MAAM,CAACiB,MAAM,CAACH,SAAS,CAAC,CAACD,KAAK,CAAC,CAAC,CAAC,CAACK,WAAW,CAAC,CAAC;IAEpE,OAAO,IAAIrB,GAAG,CAAE,IAAGmB,YAAa,EAAC,EAAE,KAAK,CAAC;EAC3C,CAAC,CAAC,QAAO,kBAAmBG,GAAG,EAAE;IAC/B,OAAOX,GAAG;EACZ;AACF;;AAEA;AACA;AACA;AACA,SAASY,QAAQA,CAAEZ,GAAG,EAAE;EACtB,IAAI;IACF,MAAMC,GAAG,GAAGT,MAAM,CAACU,MAAM,CAAE,IAAGF,GAAG,CAACG,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAE,EAAC,CAAC;IACtE,MAAMQ,MAAM,GAAGnB,GAAG,CAACQ,MAAM,CAACD,GAAG,CAAC;;IAE9B;IACA,MAAMK,SAAS,GAAGd,MAAM,CAACiB,MAAM,CAACrB,GAAG,CAAC0B,QAAQ,CAACrB,GAAG,CAACsB,IAAI,EAAEF,MAAM,CAAC,CAACN,KAAK,CAAC,CAACF,KAAK,CAAC,CAAC,CAAC;IAE9E,OAAO,IAAIhB,GAAG,CAAE,IAAGiB,SAAS,CAACI,WAAW,CAAC,CAAE,EAAC,EAAE,KAAK,CAAC;EACtD,CAAC,CAAC,MAAM;IACN,OAAOV,GAAG;EACZ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAegB,OAAOA,CAAEC,QAAQ,EAAEC,UAAU,EAAEC,WAAW,EAAE;EACzD,MAAMtB,UAAU,GAAGoB,QAAQ,CAACG,MAAM;EAClC,MAAMvB,UAAU,CAACwB,IAAI,CAAC,CAAC;EAEvB,MAAMC,SAAS,GAAG1B,MAAM,CAACC,UAAU,CAAC;EAEpC,MAAM0B,UAAU,GAAG,MAAMhC,MAAM,CAAC+B,SAAS,CAACE,SAAS,CAAC;IAClDC,OAAO,EAAE,CAAEzB,GAAG,IAAK;MACjB,MAAM0B,MAAM,GAAGP,WAAW,CAACnB,GAAG,CAAC;MAE/B,OAAO0B,MAAM,CAACvB,QAAQ,CAAC,CAAC,KAAKH,GAAG,CAACG,QAAQ,CAAC,CAAC;IAC7C,CAAC;EACH,CAAC,CAAC,CAAC;EAEH,IAAI;IACF,IAAIwB,OAAO,GAAG,CAAC;IAEf,WAAW,MAAMC,KAAK,IAAIN,SAAS,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MAC7C,MAAMH,MAAM,GAAGP,WAAW,CAACS,KAAK,CAAC5B,GAAG,CAAC;;MAErC;MACA,IAAI0B,MAAM,CAACvB,QAAQ,CAAC,CAAC,KAAKyB,KAAK,CAAC5B,GAAG,CAACG,QAAQ,CAAC,CAAC,EAAE;QAC9CwB,OAAO,IAAI,CAAC;QACZhC,GAAG,CAAE,wBAAuBiC,KAAK,CAAC5B,GAAI,OAAM0B,MAAO,EAAC,EAAE,MAAMJ,SAAS,CAACQ,GAAG,CAACF,KAAK,CAAC5B,GAAG,CAAC,CAAC;QAErF,MAAMsB,SAAS,CAACS,MAAM,CAACH,KAAK,CAAC5B,GAAG,CAAC;QACjC,MAAMsB,SAAS,CAACU,GAAG,CAACN,MAAM,EAAEE,KAAK,CAACK,KAAK,CAAC;QAExCf,UAAU,CAAES,OAAO,GAAGJ,UAAU,GAAI,GAAG,EAAG,uBAAsBK,KAAK,CAAC5B,GAAI,OAAM0B,MAAO,EAAC,CAAC;MAC3F;IACF;EACF,CAAC,SAAS;IACR,MAAM7B,UAAU,CAACqC,KAAK,CAAC,CAAC;EAC1B;AACF;;AAEA;AACA,OAAO,MAAMC,SAAS,GAAG;EACvBC,OAAO,EAAE,CAAC;EACVC,WAAW,EAAE,8GAA8G;EAC3HC,OAAO,EAAEA,CAACrB,QAAQ,EAAEC,UAAU,GAAGA,CAAA,KAAM,CAAC,CAAC,KAAK;IAC5C,OAAOF,OAAO,CAACC,QAAQ,EAAEC,UAAU,EAAEnB,cAAc,CAAC;EACtD,CAAC;EACDwC,MAAM,EAAEA,CAACtB,QAAQ,EAAEC,UAAU,GAAGA,CAAA,KAAM,CAAC,CAAC,KAAK;IAC3C,OAAOF,OAAO,CAACC,QAAQ,EAAEC,UAAU,EAAEN,QAAQ,CAAC;EAChD;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}