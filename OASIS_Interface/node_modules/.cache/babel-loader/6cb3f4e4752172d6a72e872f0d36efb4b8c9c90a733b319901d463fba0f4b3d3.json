{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Key } from 'interface-datastore';\nimport { BaseDatastore, Errors } from 'datastore-core';\nimport filter from 'it-filter';\nimport map from 'it-map';\nimport take from 'it-take';\nimport sort from 'it-sort';\nimport { Level } from 'level';\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n * @typedef {import('abstract-level').AbstractLevel<any, string, Uint8Array>} LevelDb\n */\n\n/**\n * A datastore backed by leveldb\n */\nexport class LevelDatastore extends BaseDatastore {\n  /**\n   * @param {string | LevelDb} path\n   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]\n   */\n  constructor(path, opts = {}) {\n    super();\n\n    /** @type {LevelDb} */\n    this.db = typeof path === 'string' ? new Level(path, {\n      ...opts,\n      keyEncoding: 'utf8',\n      valueEncoding: 'view'\n    }) : path;\n\n    /** @type {import('level').OpenOptions} */\n    this.opts = {\n      createIfMissing: true,\n      compression: false,\n      // same default as go\n      ...opts\n    };\n  }\n  async open() {\n    try {\n      await this.db.open(this.opts);\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n  async put(key, value) {\n    try {\n      await this.db.put(key.toString(), value);\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async get(key) {\n    let data;\n    try {\n      data = await this.db.get(key.toString());\n    } catch ( /** @type {any} */err) {\n      if (err.notFound) throw Errors.notFoundError(err);\n      throw Errors.dbWriteFailedError(err);\n    }\n    return data;\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n  async has(key) {\n    try {\n      await this.db.get(key.toString());\n    } catch ( /** @type {any} */err) {\n      if (err.notFound) return false;\n      throw err;\n    }\n    return true;\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n  async delete(key) {\n    try {\n      await this.db.del(key.toString());\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n  close() {\n    return this.db && this.db.close();\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch() {\n    /** @type {Array<{ type: 'put', key: string, value: Uint8Array; } | { type: 'del', key: string }>} */\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n\n  /**\n   * @param {Query} q\n   */\n  query(q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    });\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it);\n    }\n    const {\n      offset,\n      limit\n    } = q;\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n    if (limit) {\n      it = take(it, limit);\n    }\n    return it;\n  }\n\n  /**\n   * @param {KeyQuery} q\n   */\n  queryKeys(q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({\n      key\n    }) => key);\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it);\n    }\n    const {\n      offset,\n      limit\n    } = q;\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n    if (limit) {\n      it = take(it, limit);\n    }\n    return it;\n  }\n\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n  _query(opts) {\n    /** @type {import('level').IteratorOptions<string, Uint8Array>} */\n    const iteratorOpts = {\n      keys: true,\n      keyEncoding: 'buffer',\n      values: opts.values\n    };\n\n    // Let the db do the prefix matching\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString();\n      // Match keys greater than or equal to `prefix` and\n      iteratorOpts.gte = prefix;\n      // less than `prefix` + \\xFF (hex escape sequence)\n      iteratorOpts.lt = prefix + '\\xFF';\n    }\n    const iterator = this.db.iterator(iteratorOpts);\n    if (iterator[Symbol.asyncIterator]) {\n      return levelIteratorToIterator(iterator);\n    }\n\n    // @ts-expect-error support older level\n    if (iterator.next != null && iterator.end != null) {\n      // @ts-expect-error support older level\n      return oldLevelIteratorToIterator(iterator);\n    }\n    throw new Error('Level returned incompatible iterator');\n  }\n}\n\n/**\n * @param {import('level').Iterator<LevelDb, string, Uint8Array>} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nasync function* levelIteratorToIterator(li) {\n  for await (const [key, value] of li) {\n    yield {\n      key: new Key(key, false),\n      value\n    };\n  }\n  await li.close();\n}\n\n/**\n * @typedef {object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nfunction oldLevelIteratorToIterator(li) {\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err);\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err);\n                resolve({\n                  done: true,\n                  value: undefined\n                });\n              });\n            }\n            resolve({\n              done: false,\n              value: {\n                key: new Key(key, false),\n                value\n              }\n            });\n          });\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true,\n              value: undefined\n            });\n          });\n        })\n      };\n    }\n  };\n}","map":{"version":3,"names":["Key","BaseDatastore","Errors","filter","map","take","sort","Level","LevelDatastore","constructor","path","opts","db","keyEncoding","valueEncoding","createIfMissing","compression","open","err","dbOpenFailedError","put","key","value","toString","dbWriteFailedError","get","data","notFound","notFoundError","has","delete","del","dbDeleteFailedError","close","batch","ops","push","type","commit","query","q","it","_query","values","prefix","Array","isArray","filters","reduce","f","orders","offset","limit","i","queryKeys","iteratorOpts","keys","gte","lt","iterator","Symbol","asyncIterator","levelIteratorToIterator","next","end","oldLevelIteratorToIterator","Error","li","Promise","resolve","reject","done","undefined","return"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/datastore-level@9.0.4/node_modules/datastore-level/src/index.js"],"sourcesContent":["import { Key } from 'interface-datastore'\nimport { BaseDatastore, Errors } from 'datastore-core'\nimport filter from 'it-filter'\nimport map from 'it-map'\nimport take from 'it-take'\nimport sort from 'it-sort'\nimport { Level } from 'level'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} QueryOptions\n * @typedef {import('abstract-level').AbstractLevel<any, string, Uint8Array>} LevelDb\n */\n\n/**\n * A datastore backed by leveldb\n */\nexport class LevelDatastore extends BaseDatastore {\n  /**\n   * @param {string | LevelDb} path\n   * @param {import('level').DatabaseOptions<string, Uint8Array> & import('level').OpenOptions} [opts]\n   */\n  constructor (path, opts = {}) {\n    super()\n\n    /** @type {LevelDb} */\n    this.db = typeof path === 'string'\n      ? new Level(path, {\n        ...opts,\n        keyEncoding: 'utf8',\n        valueEncoding: 'view'\n      })\n      : path\n\n    /** @type {import('level').OpenOptions} */\n    this.opts = {\n      createIfMissing: true,\n      compression: false, // same default as go\n      ...opts\n    }\n  }\n\n  async open () {\n    try {\n      await this.db.open(this.opts)\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n  async put (key, value) {\n    try {\n      await this.db.put(key.toString(), value)\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async get (key) {\n    let data\n    try {\n      data = await this.db.get(key.toString())\n    } catch (/** @type {any} */ err) {\n      if (err.notFound) throw Errors.notFoundError(err)\n      throw Errors.dbWriteFailedError(err)\n    }\n    return data\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    try {\n      await this.db.get(key.toString())\n    } catch (/** @type {any} */ err) {\n      if (err.notFound) return false\n      throw err\n    }\n    return true\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n  async delete (key) {\n    try {\n      await this.db.del(key.toString())\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  close () {\n    return this.db && this.db.close()\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Array<{ type: 'put', key: string, value: Uint8Array; } | { type: 'del', key: string }>} */\n    const ops = []\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key) => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: () => {\n        return this.db.batch(ops)\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   */\n  query (q) {\n    let it = this._query({\n      values: true,\n      prefix: q.prefix\n    })\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   */\n  queryKeys (q) {\n    let it = map(this._query({\n      values: false,\n      prefix: q.prefix\n    }), ({ key }) => key)\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    const { offset, limit } = q\n    if (offset) {\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (limit) {\n      it = take(it, limit)\n    }\n\n    return it\n  }\n\n  /**\n   * @param {object} opts\n   * @param {boolean} opts.values\n   * @param {string} [opts.prefix]\n   * @returns {AsyncIterable<Pair>}\n   */\n  _query (opts) {\n    /** @type {import('level').IteratorOptions<string, Uint8Array>} */\n    const iteratorOpts = {\n      keys: true,\n      keyEncoding: 'buffer',\n      values: opts.values\n    }\n\n    // Let the db do the prefix matching\n    if (opts.prefix != null) {\n      const prefix = opts.prefix.toString()\n      // Match keys greater than or equal to `prefix` and\n      iteratorOpts.gte = prefix\n      // less than `prefix` + \\xFF (hex escape sequence)\n      iteratorOpts.lt = prefix + '\\xFF'\n    }\n\n    const iterator = this.db.iterator(iteratorOpts)\n\n    if (iterator[Symbol.asyncIterator]) {\n      return levelIteratorToIterator(iterator)\n    }\n\n    // @ts-expect-error support older level\n    if (iterator.next != null && iterator.end != null) {\n      // @ts-expect-error support older level\n      return oldLevelIteratorToIterator(iterator)\n    }\n\n    throw new Error('Level returned incompatible iterator')\n  }\n}\n\n/**\n * @param {import('level').Iterator<LevelDb, string, Uint8Array>} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nasync function * levelIteratorToIterator (li) {\n  for await (const [key, value] of li) {\n    yield { key: new Key(key, false), value }\n  }\n\n  await li.close()\n}\n\n/**\n * @typedef {object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\nfunction oldLevelIteratorToIterator (li) {\n  return {\n    [Symbol.asyncIterator] () {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err)\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err)\n                resolve({ done: true, value: undefined })\n              })\n            }\n            resolve({ done: false, value: { key: new Key(key, false), value } })\n          })\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err)\n            resolve({ done: true, value: undefined })\n          })\n        })\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}