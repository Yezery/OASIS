{"ast":null,"code":"import { IPNS } from '../ipns/index.js';\nimport { createRouting } from '../ipns/routing/config.js';\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js';\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:ipns');\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport class IPNSAPI {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor(options = {\n    pass: ''\n  }) {\n    this.options = options;\n\n    /** @type {IPNS | null} */\n    this.offline = null;\n\n    /** @type {IPNS | null} */\n    this.online = null;\n  }\n  getIPNS() {\n    const ipns = this.online || this.offline;\n    if (ipns) {\n      return ipns;\n    } else {\n      throw new NotInitializedError();\n    }\n  }\n  get routing() {\n    return this.getIPNS().routing;\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  startOffline({\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError();\n    }\n    log('initializing IPNS keyspace (offline)');\n    const routing = new OfflineDatastore(repo.datastore);\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    this.offline = ipns;\n  }\n\n  /**\n   * @param {object} config\n   * @param {import('libp2p').Libp2p} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  async startOnline({\n    libp2p,\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError();\n    }\n    const routing = createRouting({\n      libp2p,\n      repo,\n      peerId,\n      options: this.options\n    });\n\n    // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    await ipns.republisher.start();\n    this.online = ipns;\n  }\n  async stop() {\n    const ipns = this.online;\n    if (ipns) {\n      await ipns.republisher.stop();\n      this.online = null;\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  publish(peerId, value, lifetime, options) {\n    return this.getIPNS().publish(peerId, value, lifetime, options);\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  resolve(name, options) {\n    return this.getIPNS().resolve(name, options);\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  initializeKeyspace(peerId, value, options) {\n    return this.getIPNS().initializeKeyspace(peerId, value, options);\n  }\n}","map":{"version":3,"names":["IPNS","createRouting","OfflineDatastore","NotInitializedError","AlreadyInitializedError","logger","log","IPNSAPI","constructor","options","pass","offline","online","getIPNS","ipns","routing","startOffline","repo","peerId","keychain","datastore","startOnline","libp2p","republisher","start","stop","publish","value","lifetime","resolve","name","initializeKeyspace"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/ipns.js"],"sourcesContent":["import { IPNS } from '../ipns/index.js'\nimport { createRouting } from '../ipns/routing/config.js'\nimport { OfflineDatastore } from '../ipns/routing/offline-datastore.js'\nimport { NotInitializedError, AlreadyInitializedError } from '../errors.js'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:ipns')\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n *\n * @typedef {object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nexport class IPNSAPI {\n  /**\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor (options = { pass: '' }) {\n    this.options = options\n\n    /** @type {IPNS | null} */\n    this.offline = null\n\n    /** @type {IPNS | null} */\n    this.online = null\n  }\n\n  getIPNS () {\n    const ipns = this.online || this.offline\n    if (ipns) {\n      return ipns\n    } else {\n      throw new NotInitializedError()\n    }\n  }\n\n  get routing () {\n    return this.getIPNS().routing\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  startOffline ({ repo, peerId, keychain }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError()\n    }\n\n    log('initializing IPNS keyspace (offline)')\n\n    const routing = new OfflineDatastore(repo.datastore)\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n\n    this.offline = ipns\n  }\n\n  /**\n   * @param {object} config\n   * @param {import('libp2p').Libp2p} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} config.keychain\n   */\n  async startOnline ({ libp2p, repo, peerId, keychain }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError()\n    }\n    const routing = createRouting({ libp2p, repo, peerId, options: this.options })\n\n    // @ts-expect-error routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n    await ipns.republisher.start()\n    this.online = ipns\n  }\n\n  async stop () {\n    const ipns = this.online\n    if (ipns) {\n      await ipns.republisher.stop()\n      this.online = null\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  publish (peerId, value, lifetime, options) {\n    return this.getIPNS().publish(peerId, value, lifetime, options)\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  resolve (name, options) {\n    return this.getIPNS().resolve(name, options)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  initializeKeyspace (peerId, value, options) {\n    return this.getIPNS().initializeKeyspace(peerId, value, options)\n  }\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,kBAAkB;AACvC,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,gBAAgB,QAAQ,sCAAsC;AACvE,SAASC,mBAAmB,EAAEC,uBAAuB,QAAQ,cAAc;AAC3E,SAASC,MAAM,QAAQ,gBAAgB;AAEvC,MAAMC,GAAG,GAAGD,MAAM,CAAC,sBAAsB,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAME,OAAO,CAAC;EACnB;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAAEC,OAAO,GAAG;IAAEC,IAAI,EAAE;EAAG,CAAC,EAAE;IACnC,IAAI,CAACD,OAAO,GAAGA,OAAO;;IAEtB;IACA,IAAI,CAACE,OAAO,GAAG,IAAI;;IAEnB;IACA,IAAI,CAACC,MAAM,GAAG,IAAI;EACpB;EAEAC,OAAOA,CAAA,EAAI;IACT,MAAMC,IAAI,GAAG,IAAI,CAACF,MAAM,IAAI,IAAI,CAACD,OAAO;IACxC,IAAIG,IAAI,EAAE;MACR,OAAOA,IAAI;IACb,CAAC,MAAM;MACL,MAAM,IAAIX,mBAAmB,CAAC,CAAC;IACjC;EACF;EAEA,IAAIY,OAAOA,CAAA,EAAI;IACb,OAAO,IAAI,CAACF,OAAO,CAAC,CAAC,CAACE,OAAO;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,YAAYA,CAAE;IAAEC,IAAI;IAAEC,MAAM;IAAEC;EAAS,CAAC,EAAE;IACxC,IAAI,IAAI,CAACR,OAAO,IAAI,IAAI,EAAE;MACxB,MAAM,IAAIP,uBAAuB,CAAC,CAAC;IACrC;IAEAE,GAAG,CAAC,sCAAsC,CAAC;IAE3C,MAAMS,OAAO,GAAG,IAAIb,gBAAgB,CAACe,IAAI,CAACG,SAAS,CAAC;IACpD,MAAMN,IAAI,GAAG,IAAId,IAAI,CAACe,OAAO,EAAEE,IAAI,CAACG,SAAS,EAAEF,MAAM,EAAEC,QAAQ,EAAE,IAAI,CAACV,OAAO,CAAC;IAE9E,IAAI,CAACE,OAAO,GAAGG,IAAI;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMO,WAAWA,CAAE;IAAEC,MAAM;IAAEL,IAAI;IAAEC,MAAM;IAAEC;EAAS,CAAC,EAAE;IACrD,IAAI,IAAI,CAACP,MAAM,IAAI,IAAI,EAAE;MACvB,MAAM,IAAIR,uBAAuB,CAAC,CAAC;IACrC;IACA,MAAMW,OAAO,GAAGd,aAAa,CAAC;MAAEqB,MAAM;MAAEL,IAAI;MAAEC,MAAM;MAAET,OAAO,EAAE,IAAI,CAACA;IAAQ,CAAC,CAAC;;IAE9E;IACA,MAAMK,IAAI,GAAG,IAAId,IAAI,CAACe,OAAO,EAAEE,IAAI,CAACG,SAAS,EAAEF,MAAM,EAAEC,QAAQ,EAAE,IAAI,CAACV,OAAO,CAAC;IAC9E,MAAMK,IAAI,CAACS,WAAW,CAACC,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACZ,MAAM,GAAGE,IAAI;EACpB;EAEA,MAAMW,IAAIA,CAAA,EAAI;IACZ,MAAMX,IAAI,GAAG,IAAI,CAACF,MAAM;IACxB,IAAIE,IAAI,EAAE;MACR,MAAMA,IAAI,CAACS,WAAW,CAACE,IAAI,CAAC,CAAC;MAC7B,IAAI,CAACb,MAAM,GAAG,IAAI;IACpB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEc,OAAOA,CAAER,MAAM,EAAES,KAAK,EAAEC,QAAQ,EAAEnB,OAAO,EAAE;IACzC,OAAO,IAAI,CAACI,OAAO,CAAC,CAAC,CAACa,OAAO,CAACR,MAAM,EAAES,KAAK,EAAEC,QAAQ,EAAEnB,OAAO,CAAC;EACjE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEoB,OAAOA,CAAEC,IAAI,EAAErB,OAAO,EAAE;IACtB,OAAO,IAAI,CAACI,OAAO,CAAC,CAAC,CAACgB,OAAO,CAACC,IAAI,EAAErB,OAAO,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;EACEsB,kBAAkBA,CAAEb,MAAM,EAAES,KAAK,EAAElB,OAAO,EAAE;IAC1C,OAAO,IAAI,CAACI,OAAO,CAAC,CAAC,CAACkB,kBAAkB,CAACb,MAAM,EAAES,KAAK,EAAElB,OAAO,CAAC;EAClE;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}