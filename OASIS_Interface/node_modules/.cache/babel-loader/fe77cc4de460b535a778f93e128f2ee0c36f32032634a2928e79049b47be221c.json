{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js';\nimport { CarHeader as headerValidator } from './header-validator.js';\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader(reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length, true);\n  const block = decodeDagCbor(header);\n  if (!headerValidator(block)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);\n  }\n  // we've made 'roots' optional in the schema so we can do the version check\n  // before rejecting the block as invalid if there is no version\n  const hasRoots = Array.isArray(block.roots);\n  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version === 1) {\n    return block;\n  }\n  // version 2\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));\n  reader.seek(v2Header.dataOffset - reader.pos);\n  const v1Header = await readHeader(reader, 1);\n  return Object.assign(v1Header, v2Header);\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid(reader) {\n  const first = await reader.exactly(2, false);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = decodeVarint(await reader.upTo(8), reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader);\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead(reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos;\n  let length = decodeVarint(await reader.upTo(8), reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - Number(reader.pos - start); // subtract CID length\n\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength, true);\n  return {\n    bytes,\n    cid\n  };\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder(reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader);\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset;\n      reader = limitReader(reader, header.dataSize - v1length);\n    }\n    return header;\n  })();\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader(bytes) {\n  let pos = 0;\n\n  /** @type {BytesReader} */\n  return {\n    async upTo(length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n      return out;\n    },\n    async exactly(length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      const out = bytes.subarray(pos, pos + length);\n      if (seek) {\n        pos += length;\n      }\n      return out;\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader(readChunk /*, closer */) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async ( /** @type {number} */length) => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) {\n        // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        } // else discard\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n\n  /** @type {BytesReader} */\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      const out = currentChunk.subarray(offset, offset + length);\n      if (seek) {\n        pos += length;\n        offset += length;\n      }\n      return out;\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader(reader, byteLimit) {\n  let bytesRead = 0;\n\n  /** @type {BytesReader} */\n  return {\n    async upTo(length) {\n      let bytes = await reader.upTo(length);\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead);\n      }\n      return bytes;\n    },\n    async exactly(length, seek = false) {\n      const bytes = await reader.exactly(length, seek);\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data');\n      }\n      if (seek) {\n        bytesRead += length;\n      }\n      return bytes;\n    },\n    seek(length) {\n      bytesRead += length;\n      reader.seek(length);\n    },\n    get pos() {\n      return reader.pos;\n    }\n  };\n}","map":{"version":3,"names":["decode","decodeDagCbor","CID","Digest","CIDV0_BYTES","decodeV2Header","decodeVarint","getMultihashLength","V2_HEADER_LENGTH","CarHeader","headerValidator","readHeader","reader","strictVersion","length","upTo","Error","header","exactly","block","version","undefined","hasRoots","Array","isArray","roots","v2Header","seek","dataOffset","pos","v1Header","Object","assign","readCid","first","SHA2_256","LENGTH","bytes","multihash","create","DAG_PB","codec","readBlockHead","start","cid","blockLength","Number","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","v1length","limitReader","dataSize","blocks","blocksIndex","bytesReader","out","subarray","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","p","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value","byteLimit","bytesRead"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/@ipld+car@5.2.3/node_modules/@ipld/car/src/decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarHeader as headerValidator } from './header-validator.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (!headerValidator(block)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  // we've made 'roots' optional in the schema so we can do the version check\n  // before rejecting the block as invalid if there is no version\n  const hasRoots = Array.isArray(block.roots)\n  if ((block.version === 1 && !hasRoots) || (block.version === 2 && hasRoots)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if (block.version === 1) {\n    return block\n  }\n  // version 2\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = [currentChunk.subarray(offset)]\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}