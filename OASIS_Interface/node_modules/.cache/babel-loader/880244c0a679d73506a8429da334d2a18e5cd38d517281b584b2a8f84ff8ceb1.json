{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { ipfsCore as pkgversion } from '../version.js';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { NotStartedError } from '../errors.js';\nimport errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:id');\n\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nexport function createId({\n  peerId,\n  network\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  async function id(options = {}) {\n    // eslint-disable-line require-await\n    const net = network.try();\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError();\n      }\n      if (peerId.publicKey == null) {\n        throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY');\n      }\n      return {\n        id: peerId,\n        publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      };\n    }\n    const {\n      libp2p\n    } = net;\n    const peerIdToId = options.peerId ? options.peerId : peerId;\n    const peer = await findPeer(peerIdToId, libp2p, options);\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array());\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array());\n    const idStr = peer.id.toString();\n    const publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : '';\n    return {\n      id: peerIdToId,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || []).map(ma => {\n        const str = ma.toString();\n\n        // some relay-style transports add our peer id to the ma for us\n        // so don't double-add\n        if (str.endsWith(`/p2p/${idStr}`)) {\n          return str;\n        }\n        return `${str}/p2p/${idStr}`;\n      }).sort().map(ma => multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    };\n  }\n  return withTimeoutOption(id);\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeer(peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId);\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options);\n  }\n  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId);\n  if (publicKey == null) {\n    try {\n      publicKey = await libp2p.getPublicKey(peerId, options);\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toString(), err);\n    }\n  }\n  return {\n    ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  };\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeerOnDht(peerId, libp2p, options) {\n  if (libp2p.dht == null) {\n    throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED');\n  }\n  for await (const event of libp2p.dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break;\n    }\n  }\n  const peer = await libp2p.peerStore.get(peerId);\n  if (!peer) {\n    throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND');\n  }\n  return peer;\n}","map":{"version":3,"names":["ipfsCore","pkgversion","multiaddr","withTimeoutOption","toString","uint8ArrayToString","NotStartedError","errCode","logger","log","createId","peerId","network","id","options","net","try","publicKey","Error","addresses","agentVersion","protocolVersion","protocols","libp2p","peerIdToId","peer","findPeer","metadata","get","Uint8Array","idStr","publicKeyStr","map","ma","str","endsWith","sort","peerStore","findPeerOnDht","keyBook","getPublicKey","err","error","Map","addr","dht","event","name"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/id.js"],"sourcesContent":["import { ipfsCore as pkgversion } from '../version.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NotStartedError } from '../errors.js'\nimport errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:components:id')\n\n/**\n * @typedef {import('libp2p').Libp2p} Libp2p\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @param {object} config\n * @param {import('@libp2p/interface-peer-id').PeerId} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nexport function createId ({ peerId, network }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"id\"]}\n   */\n  async function id (options = {}) { // eslint-disable-line require-await\n    const net = network.try()\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError()\n      }\n\n      if (peerId.publicKey == null) {\n        throw errCode(new Error('Public key missing'), 'ERR_MISSING_PUBLIC_KEY')\n      }\n\n      return {\n        id: peerId,\n        publicKey: uint8ArrayToString(peerId.publicKey, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      }\n    }\n\n    const { libp2p } = net\n    const peerIdToId = options.peerId ? options.peerId : peerId\n    const peer = await findPeer(peerIdToId, libp2p, options)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') || new Uint8Array())\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') || new Uint8Array())\n    const idStr = peer.id.toString()\n    const publicKeyStr = peer.publicKey ? uint8ArrayToString(peer.publicKey, 'base64pad') : ''\n\n    return {\n      id: peerIdToId,\n      publicKey: publicKeyStr,\n      addresses: (peer.addresses || [])\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${idStr}`\n        })\n        .sort()\n        .map(ma => multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (peer.protocols || []).sort()\n    }\n  }\n\n  return withTimeoutOption(id)\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeer (peerId, libp2p, options) {\n  let peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    peer = await findPeerOnDht(peerId, libp2p, options)\n  }\n\n  let publicKey = peerId.publicKey ? peerId.publicKey : await libp2p.peerStore.keyBook.get(peerId)\n\n  if (publicKey == null) {\n    try {\n      publicKey = await libp2p.getPublicKey(peerId, options)\n    } catch (err) {\n      log.error('Could not load public key for', peerId.toString(), err)\n    }\n  }\n\n  return {\n    ...peer,\n    publicKey,\n    metadata: peer.metadata || new Map(),\n    addresses: peer.addresses.map(addr => addr.multiaddr)\n  }\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Libp2p} libp2p\n * @param {AbortOptions} options\n */\nasync function findPeerOnDht (peerId, libp2p, options) {\n  if (libp2p.dht == null) {\n    throw errCode(new Error('dht not configured'), 'ERR_DHT_NOT_CONFIGURED')\n  }\n\n  for await (const event of libp2p.dht.findPeer(peerId, options)) {\n    if (event.name === 'FINAL_PEER') {\n      break\n    }\n  }\n\n  const peer = await libp2p.peerStore.get(peerId)\n\n  if (!peer) {\n    throw errCode(new Error('Could not find peer'), 'ERR_NOT_FOUND')\n  }\n\n  return peer\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}