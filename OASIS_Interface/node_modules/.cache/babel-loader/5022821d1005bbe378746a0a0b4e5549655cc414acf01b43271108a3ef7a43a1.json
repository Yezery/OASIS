{"ast":null,"code":"import mortice from 'mortice';\n\n/**\n * @typedef {object} Lock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} readLock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} writeLock\n */\n\n/** @type {Lock} */\nlet lock;\n\n/**\n * @param {boolean} [repoOwner]\n */\nexport function createLock(repoOwner = false) {\n  if (lock) {\n    return lock;\n  }\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  });\n  lock = {\n    readLock: func => {\n      return async (...args) => {\n        const releaseLock = await mutex.readLock();\n        try {\n          return await func.apply(null, args);\n        } finally {\n          releaseLock();\n        }\n      };\n    },\n    writeLock: func => {\n      return async (...args) => {\n        const releaseLock = await mutex.writeLock();\n        try {\n          return await func.apply(null, args);\n        } finally {\n          releaseLock();\n        }\n      };\n    }\n  };\n  return lock;\n}","map":{"version":3,"names":["mortice","lock","createLock","repoOwner","mutex","singleProcess","readLock","func","args","releaseLock","apply","writeLock"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/utils/create-lock.js"],"sourcesContent":["import mortice from 'mortice'\n\n/**\n * @typedef {object} Lock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} readLock\n * @property {(fn: (...args: any) => any) => (...args: any) => any} writeLock\n */\n\n/** @type {Lock} */\nlet lock\n\n/**\n * @param {boolean} [repoOwner]\n */\nexport function createLock (repoOwner = false) {\n  if (lock) {\n    return lock\n  }\n\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  })\n\n  lock = {\n    readLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.readLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    },\n\n    writeLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.writeLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    }\n  }\n\n  return lock\n}\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,SAAS;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAIC,IAAI;;AAER;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAAEC,SAAS,GAAG,KAAK,EAAE;EAC7C,IAAIF,IAAI,EAAE;IACR,OAAOA,IAAI;EACb;EAEA,MAAMG,KAAK,GAAGJ,OAAO,CAAC;IACpB;IACA;IACA;IACAK,aAAa,EAAEF;EACjB,CAAC,CAAC;EAEFF,IAAI,GAAG;IACLK,QAAQ,EAAGC,IAAI,IAAK;MAClB,OAAO,OAAO,GAAGC,IAAI,KAAK;QACxB,MAAMC,WAAW,GAAG,MAAML,KAAK,CAACE,QAAQ,CAAC,CAAC;QAE1C,IAAI;UACF,OAAO,MAAMC,IAAI,CAACG,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;QACrC,CAAC,SAAS;UACRC,WAAW,CAAC,CAAC;QACf;MACF,CAAC;IACH,CAAC;IAEDE,SAAS,EAAGJ,IAAI,IAAK;MACnB,OAAO,OAAO,GAAGC,IAAI,KAAK;QACxB,MAAMC,WAAW,GAAG,MAAML,KAAK,CAACO,SAAS,CAAC,CAAC;QAE3C,IAAI;UACF,OAAO,MAAMJ,IAAI,CAACG,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;QACrC,CAAC,SAAS;UACRC,WAAW,CAAC,CAAC;QACf;MACF,CAAC;IACH;EACF,CAAC;EAED,OAAOR,IAAI;AACb"},"metadata":{},"sourceType":"module","externalDependencies":[]}