{"ast":null,"code":"/* eslint complexity: [\"error\", 28] */\n\nimport defaultMigrations from './migrations/index.js';\nimport * as repoVersion from './repo/version.js';\nimport * as Errors from './errors.js';\nimport { wrapBackends } from './utils.js';\nimport debug from 'debug';\nconst log = debug('ipfs:repo:migrator');\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nexport function getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n  return migrations[migrations.length - 1].version;\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nexport async function migrate(path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false;\n  const onProgress = options.onProgress;\n  const isDryRun = options.isDryRun ?? false;\n  const migrations = options.migrations ?? defaultMigrations;\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends);\n  const currentVersion = await repoVersion.getVersion(backends);\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);\n  }\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n      log(`Migrating version ${migration.version}`);\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {};\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n          await migration.migrate(backends, progressCallback);\n        }\n      } catch ( /** @type {any} */e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);\n      }\n      log(`Migrating to version ${migration.version} finished`);\n    }\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n    }\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nexport async function revert(path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false;\n  const onProgress = options.onProgress;\n  const isDryRun = options.isDryRun ?? false;\n  const migrations = options.migrations ?? defaultMigrations;\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends);\n  const currentVersion = await repoVersion.getVersion(backends);\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);\n  }\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path);\n  }\n  log(`Reverting from version ${currentVersion} to ${toVersion}`);\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n      if (migration.version > currentVersion) {\n        continue;\n      }\n      log(`Reverting migration version ${migration.version}`);\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {};\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n          await migration.revert(backends, progressCallback);\n        }\n      } catch ( /** @type {any} */e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;\n        throw e;\n      }\n      log(`Reverting to version ${migration.version} finished`);\n    }\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends);\n    }\n    log(`All migrations successfully reverted to version ${toVersion}!`);\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close();\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);\n      }\n      migrationCounter++;\n    }\n  }\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);\n  }\n}\nexport const getCurrentRepoVersion = repoVersion.getVersion;\nexport const errors = Errors;\nexport const migrations = defaultMigrations;","map":{"version":3,"names":["defaultMigrations","repoVersion","Errors","wrapBackends","debug","log","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","backends","repoOptions","toVersion","options","ignoreLock","onProgress","isDryRun","errors","RequiredParameterError","Number","isInteger","InvalidValueError","currentVersion","getVersion","verifyAvailableMigrations","lock","repoLock","migration","undefined","progressCallback","percent","message","toFixed","e","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError","getCurrentRepoVersion"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/index.js"],"sourcesContent":["/* eslint complexity: [\"error\", 28] */\n\nimport defaultMigrations from './migrations/index.js'\nimport * as repoVersion from './repo/version.js'\nimport * as Errors from './errors.js'\nimport { wrapBackends } from './utils.js'\nimport debug from 'debug'\n\nconst log = debug('ipfs:repo:migrator')\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nexport function getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nexport async function migrate (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends)\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nexport async function revert (path, backends, repoOptions, toVersion, options = {}) {\n  const ignoreLock = options.ignoreLock ?? false\n  const onProgress = options.onProgress\n  const isDryRun = options.isDryRun ?? false\n  const migrations = options.migrations ?? defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(backends, progressCallback)\n        }\n      } catch (/** @type {any} */ e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n\nexport const getCurrentRepoVersion = repoVersion.getVersion\nexport const errors = Errors\nexport const migrations = defaultMigrations\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}