{"ast":null,"code":"require(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\n/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = 1 << intbiasshift;\nvar gammashift = 10;\nvar gamma = 1 << gammashift;\nvar betashift = 10;\nvar beta = intbias >> betashift; /* beta = 1/1024 */\nvar betagamma = intbias << gammashift - betashift;\n\n// defs for decreasing radius factor\nvar initrad = netsize >> 3; // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = 1 << radiusbiasshift;\nvar initradius = initrad * radiusbias; //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = 1 << alphabiasshift;\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = 1 << radbiasshift;\nvar alpharadbshift = alphabiasshift + radbiasshift;\nvar alpharadbias = 1 << alpharadbshift;\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = 3 * prime4;\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n  var netindex; // for network lookup - really 256\n\n  // bias and freq arrays for learning\n  var bias;\n  var freq;\n  var radpower;\n\n  /*\n    Private Method: init\n     sets up arrays\n  */\n  function init() {\n    network = [];\n    netindex = new Int32Array(256);\n    bias = new Int32Array(netsize);\n    freq = new Int32Array(netsize);\n    radpower = new Int32Array(netsize >> 3);\n    var i, v;\n    for (i = 0; i < netsize; i++) {\n      v = (i << netbiasshift + 8) / netsize;\n      network[i] = new Float64Array([v, v, v, 0]);\n      //network[i] = [v, v, v, 0]\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n\n  /*\n    Private Method: unbiasnet\n     unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n\n  /*\n    Private Method: altersingle\n     moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= alpha * (network[i][0] - b) / initalpha;\n    network[i][1] -= alpha * (network[i][1] - g) / initalpha;\n    network[i][2] -= alpha * (network[i][2] - r) / initalpha;\n  }\n\n  /*\n    Private Method: alterneigh\n     moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n    var p, a;\n    while (j < hi || k > lo) {\n      a = radpower[m++];\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n    }\n  }\n\n  /*\n    Private Method: contest\n     searches for biased BGR values\n  */\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n    var i, n, dist, biasdist, betafreq;\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n      biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      betafreq = freq[i] >> betashift;\n      freq[i] -= betafreq;\n      bias[i] += betafreq << gammashift;\n    }\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return bestbiaspos;\n  }\n\n  /*\n    Private Method: inxbuild\n     sorts network and builds netindex[0..255]\n  */\n  function inxbuild() {\n    var i,\n      j,\n      p,\n      q,\n      smallpos,\n      smallval,\n      previouscol = 0,\n      startpos = 0;\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n        if (q[1] < smallval) {\n          // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n\n      q = network[smallpos];\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      }\n      // smallval entry is now in position i\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = startpos + i >> 1;\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n    netindex[previouscol] = startpos + maxnetpos >> 1;\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; // really 256\n  }\n\n  /*\n    Private Method: inxsearch\n     searches for BGR values 0..255 and returns a color index\n  */\n  function inxsearch(b, g, r) {\n    var a, p, dist;\n    var bestd = 1000; // biggest possible dist is 256*3\n    var best = -1;\n    var i = netindex[g]; // index on g\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while (i < netsize || j >= 0) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; // inx key\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1]; // inx key - reverse dif\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n    return best;\n  }\n\n  /*\n    Private Method: learn\n     \"Main Learning Loop\"\n  */\n  function learn() {\n    var i;\n    var lengthcount = pixels.length;\n    var alphadec = 30 + (samplefac - 1) / 3;\n    var samplepixels = lengthcount / (3 * samplefac);\n    var delta = ~~(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n    var rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n    for (i = 0; i < rad; i++) radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n    var step;\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if (lengthcount % prime1 !== 0) {\n      step = 3 * prime1;\n    } else if (lengthcount % prime2 !== 0) {\n      step = 3 * prime2;\n    } else if (lengthcount % prime3 !== 0) {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n      i++;\n      if (delta === 0) delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n        for (j = 0; j < rad; j++) radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n      }\n    }\n  }\n\n  /*\n    Method: buildColormap\n     1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n  this.buildColormap = buildColormap;\n\n  /*\n    Method: getColormap\n     builds colormap from the index\n     returns array in the format:\n     >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n  function getColormap() {\n    var map = [];\n    var index = [];\n    for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = network[j][0];\n      map[k++] = network[j][1];\n      map[k++] = network[j][2];\n    }\n    return map;\n  }\n  this.getColormap = getColormap;\n\n  /*\n    Method: lookupRGB\n     looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n  this.lookupRGB = inxsearch;\n}\nmodule.exports = NeuQuant;","map":{"version":3,"names":["ncycles","netsize","maxnetpos","netbiasshift","intbiasshift","intbias","gammashift","gamma","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","alphadec","radbiasshift","radbias","alpharadbshift","alpharadbias","prime1","prime2","prime3","prime4","minpicturebytes","NeuQuant","pixels","samplefac","network","netindex","bias","freq","radpower","init","Int32Array","i","v","Float64Array","unbiasnet","altersingle","alpha","b","g","r","alterneigh","radius","lo","Math","abs","hi","min","j","k","m","p","a","contest","bestd","bestbiasd","bestpos","bestbiaspos","n","dist","biasdist","betafreq","inxbuild","q","smallpos","smallval","previouscol","startpos","inxsearch","best","learn","lengthcount","length","samplepixels","delta","rad","step","pix","buildColormap","getColormap","map","index","l","lookupRGB","module","exports"],"sources":["/Users/yezery/Documents/大学素材/毕业设计/OASIS/OASIS_Interface/node_modules/.store/gif-encoder@0.4.1/node_modules/gif-encoder/lib/TypedNeuQuant.js"],"sourcesContent":["/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = (1 << intbiasshift);\nvar gammashift = 10;\nvar gamma = (1 << gammashift);\nvar betashift = 10;\nvar beta = (intbias >> betashift); /* beta = 1/1024 */\nvar betagamma = (intbias << (gammashift - betashift));\n\n// defs for decreasing radius factor\nvar initrad = (netsize >> 3); // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = (1 << radiusbiasshift);\nvar initradius = (initrad * radiusbias); //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = (1 << alphabiasshift);\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = (1 << radbiasshift);\nvar alpharadbshift = (alphabiasshift + radbiasshift);\nvar alpharadbias = (1 << alpharadbshift);\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = (3 * prime4);\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n  var netindex; // for network lookup - really 256\n\n  // bias and freq arrays for learning\n  var bias;\n  var freq;\n  var radpower;\n\n  /*\n    Private Method: init\n\n    sets up arrays\n  */\n  function init() {\n    network = [];\n    netindex = new Int32Array(256);\n    bias = new Int32Array(netsize);\n    freq = new Int32Array(netsize);\n    radpower = new Int32Array(netsize >> 3);\n\n    var i, v;\n    for (i = 0; i < netsize; i++) {\n      v = (i << (netbiasshift + 8)) / netsize;\n      network[i] = new Float64Array([v, v, v, 0]);\n      //network[i] = [v, v, v, 0]\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n\n  /*\n    Private Method: unbiasnet\n\n    unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n\n  /*\n    Private Method: altersingle\n\n    moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n  }\n\n  /*\n    Private Method: alterneigh\n\n    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n\n    var p, a;\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n    }\n  }\n\n  /*\n    Private Method: contest\n\n    searches for biased BGR values\n  */\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n\n    var i, n, dist, biasdist, betafreq;\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n\n      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n\n    return bestbiaspos;\n  }\n\n  /*\n    Private Method: inxbuild\n\n    sorts network and builds netindex[0..255]\n  */\n  function inxbuild() {\n    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n        if (q[1] < smallval) { // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n      q = network[smallpos];\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];   q[0] = p[0];   p[0] = j;\n        j = q[1];   q[1] = p[1];   p[1] = j;\n        j = q[2];   q[2] = p[2];   p[2] = j;\n        j = q[3];   q[3] = p[3];   p[3] = j;\n      }\n      // smallval entry is now in position i\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = (startpos + i) >> 1;\n        for (j = previouscol + 1; j < smallval; j++)\n          netindex[j] = i;\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++)\n      netindex[j] = maxnetpos; // really 256\n  }\n\n  /*\n    Private Method: inxsearch\n\n    searches for BGR values 0..255 and returns a color index\n  */\n  function inxsearch(b, g, r) {\n    var a, p, dist;\n\n    var bestd = 1000; // biggest possible dist is 256*3\n    var best = -1;\n\n    var i = netindex[g]; // index on g\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while ((i < netsize) || (j >= 0)) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; // inx key\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1]; // inx key - reverse dif\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = p[2] - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /*\n    Private Method: learn\n\n    \"Main Learning Loop\"\n  */\n  function learn() {\n    var i;\n\n    var lengthcount = pixels.length;\n    var alphadec = 30 + ((samplefac - 1) / 3);\n    var samplepixels = lengthcount / (3 * samplefac);\n    var delta = ~~(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n\n    var rad = radius >> radiusbiasshift;\n\n    if (rad <= 1) rad = 0;\n    for (i = 0; i < rad; i++)\n      radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n    var step;\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if ((lengthcount % prime1) !== 0) {\n      step = 3 * prime1;\n    } else if ((lengthcount % prime2) !== 0) {\n      step = 3 * prime2;\n    } else if ((lengthcount % prime3) !== 0)  {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n        for (j = 0; j < rad; j++)\n          radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n      }\n    }\n  }\n\n  /*\n    Method: buildColormap\n\n    1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n  this.buildColormap = buildColormap;\n\n  /*\n    Method: getColormap\n\n    builds colormap from the index\n\n    returns array in the format:\n\n    >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n    return map;\n  }\n  this.getColormap = getColormap;\n\n  /*\n    Method: lookupRGB\n\n    looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}