{"ast":null,"code":"import os from 'node:os';\nimport onExit from 'signal-exit';\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nexport const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n  const killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\nconst setKillTimeout = (kill, signal, options, killResult) => {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n  const timeout = getForceKillAfterTimeout(options);\n  const t = setTimeout(() => {\n    kill('SIGKILL');\n  }, timeout);\n\n  // Guarded because there's no `.unref()` when `execa` is used in the renderer\n  // process in Electron. This cannot be tested since we don't run tests in\n  // Electron.\n  // istanbul ignore else\n  if (t.unref) {\n    t.unref();\n  }\n};\nconst shouldForceKill = (signal, {\n  forceKillAfterTimeout\n}, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\nconst isSigterm = signal => signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\nconst getForceKillAfterTimeout = ({\n  forceKillAfterTimeout = true\n}) => {\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n  }\n  return forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nexport const spawnedCancel = (spawned, context) => {\n  const killResult = spawned.kill();\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\nconst timeoutKill = (spawned, signal, reject) => {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal\n  }));\n};\n\n// `timeout` option handling\nexport const setupTimeout = (spawned, {\n  timeout,\n  killSignal = 'SIGTERM'\n}, spawnedPromise) => {\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\nexport const validateTimeout = ({\n  timeout\n}) => {\n  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n    throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n  }\n};\n\n// `cleanup` option handling\nexport const setExitHandler = async (spawned, {\n  cleanup,\n  detached\n}, timedPromise) => {\n  if (!cleanup || detached) {\n    return timedPromise;\n  }\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n  return timedPromise.finally(() => {\n    removeExitHandler();\n  });\n};","map":{"version":3,"names":["os","onExit","DEFAULT_FORCE_KILL_TIMEOUT","spawnedKill","kill","signal","options","killResult","setKillTimeout","shouldForceKill","timeout","getForceKillAfterTimeout","t","setTimeout","unref","forceKillAfterTimeout","isSigterm","constants","signals","SIGTERM","toUpperCase","Number","isFinite","TypeError","spawnedCancel","spawned","context","isCanceled","timeoutKill","reject","Object","assign","Error","timedOut","setupTimeout","killSignal","spawnedPromise","undefined","timeoutId","timeoutPromise","Promise","resolve","safeSpawnedPromise","finally","clearTimeout","race","validateTimeout","setExitHandler","cleanup","detached","timedPromise","removeExitHandler"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/execa@7.2.0/node_modules/execa/lib/kill.js"],"sourcesContent":["import os from 'node:os';\nimport onExit from 'signal-exit';\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nexport const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n\nconst isSigterm = signal => signal === os.constants.signals.SIGTERM\n\t\t|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nexport const spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nexport const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nexport const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}