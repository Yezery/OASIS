{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/* eslint-env browser */\n\nimport { TLRU } from './utils/tlru.js';\nimport PQueue from 'p-queue';\nimport HTTP from 'ipfs-utils/src/http.js';\n\n// Avoid sending multiple queries for the same hostname by caching results\nconst cache = new TLRU(1000);\n// TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\nconst ttl = 60 * 1000;\n\n// @ts-expect-error PQueue@6 is broken\nconst Queue = PQueue.default ? PQueue.default : PQueue;\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new Queue({\n  concurrency: 4\n});\n\n/**\n * @param {{ Path: string, Message: string }} response\n */\nconst ipfsPath = response => {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\nexport async function resolveDnslink(fqdn, opts) {\n  // eslint-disable-line require-await\n  /**\n   * @param {string} fqdn\n   * @param {object} opts\n   * @param {boolean} [opts.nocache]\n   */\n  const resolve = async (fqdn, opts = {}) => {\n    // @ts-expect-error - URLSearchParams does not take boolean options, only strings\n    const searchParams = new URLSearchParams(opts);\n    searchParams.set('arg', fqdn);\n\n    // try cache first\n    const query = searchParams.toString();\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query);\n      return ipfsPath(response);\n    }\n\n    // fallback to delegated DNS resolver\n    const response = await httpQueue.add(async () => {\n      // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n      // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n      const res = await HTTP.get('https://ipfs.io/api/v0/dns', {\n        searchParams\n      });\n      const query = new URL(res.url).search.slice(1);\n      const json = await res.json();\n      cache.set(query, json, ttl);\n      return json;\n    });\n    return ipfsPath(response);\n  };\n  return resolve(fqdn, opts);\n}","map":{"version":3,"names":["TLRU","PQueue","HTTP","cache","ttl","Queue","default","httpQueue","concurrency","ipfsPath","response","Path","Error","Message","resolveDnslink","fqdn","opts","resolve","searchParams","URLSearchParams","set","query","toString","nocache","has","get","add","res","URL","url","search","slice","json"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core-config@0.7.1/node_modules/ipfs-core-config/src/dns.browser.js"],"sourcesContent":["/* eslint-env browser */\n\nimport { TLRU } from './utils/tlru.js'\nimport PQueue from 'p-queue'\nimport HTTP from 'ipfs-utils/src/http.js'\n\n// Avoid sending multiple queries for the same hostname by caching results\nconst cache = new TLRU(1000)\n// TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\nconst ttl = 60 * 1000\n\n// @ts-expect-error PQueue@6 is broken\nconst Queue = PQueue.default ? PQueue.default : PQueue\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new Queue({ concurrency: 4 })\n\n/**\n * @param {{ Path: string, Message: string }} response\n */\nconst ipfsPath = (response) => {\n  if (response.Path) return response.Path\n  throw new Error(response.Message)\n}\n\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\nexport async function resolveDnslink (fqdn, opts) { // eslint-disable-line require-await\n  /**\n   * @param {string} fqdn\n   * @param {object} opts\n   * @param {boolean} [opts.nocache]\n   */\n  const resolve = async (fqdn, opts = {}) => {\n    // @ts-expect-error - URLSearchParams does not take boolean options, only strings\n    const searchParams = new URLSearchParams(opts)\n    searchParams.set('arg', fqdn)\n\n    // try cache first\n    const query = searchParams.toString()\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query)\n      return ipfsPath(response)\n    }\n\n    // fallback to delegated DNS resolver\n    const response = await httpQueue.add(async () => {\n      // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n      // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n      const res = await HTTP.get('https://ipfs.io/api/v0/dns', { searchParams })\n      const query = new URL(res.url).search.slice(1)\n      const json = await res.json()\n      cache.set(query, json, ttl)\n\n      return json\n    })\n    return ipfsPath(response)\n  }\n\n  return resolve(fqdn, opts)\n}\n"],"mappings":";;;AAAA;;AAEA,SAASA,IAAI,QAAQ,iBAAiB;AACtC,OAAOC,MAAM,MAAM,SAAS;AAC5B,OAAOC,IAAI,MAAM,wBAAwB;;AAEzC;AACA,MAAMC,KAAK,GAAG,IAAIH,IAAI,CAAC,IAAI,CAAC;AAC5B;AACA;AACA;AACA,MAAMI,GAAG,GAAG,EAAE,GAAG,IAAI;;AAErB;AACA,MAAMC,KAAK,GAAGJ,MAAM,CAACK,OAAO,GAAGL,MAAM,CAACK,OAAO,GAAGL,MAAM;;AAEtD;AACA;AACA,MAAMM,SAAS,GAAG,IAAIF,KAAK,CAAC;EAAEG,WAAW,EAAE;AAAE,CAAC,CAAC;;AAE/C;AACA;AACA;AACA,MAAMC,QAAQ,GAAIC,QAAQ,IAAK;EAC7B,IAAIA,QAAQ,CAACC,IAAI,EAAE,OAAOD,QAAQ,CAACC,IAAI;EACvC,MAAM,IAAIC,KAAK,CAACF,QAAQ,CAACG,OAAO,CAAC;AACnC,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,eAAeC,cAAcA,CAAEC,IAAI,EAAEC,IAAI,EAAE;EAAE;EAClD;AACF;AACA;AACA;AACA;EACE,MAAMC,OAAO,GAAG,MAAAA,CAAOF,IAAI,EAAEC,IAAI,GAAG,CAAC,CAAC,KAAK;IACzC;IACA,MAAME,YAAY,GAAG,IAAIC,eAAe,CAACH,IAAI,CAAC;IAC9CE,YAAY,CAACE,GAAG,CAAC,KAAK,EAAEL,IAAI,CAAC;;IAE7B;IACA,MAAMM,KAAK,GAAGH,YAAY,CAACI,QAAQ,CAAC,CAAC;IACrC,IAAI,CAACN,IAAI,CAACO,OAAO,IAAIpB,KAAK,CAACqB,GAAG,CAACH,KAAK,CAAC,EAAE;MACrC,MAAMX,QAAQ,GAAGP,KAAK,CAACsB,GAAG,CAACJ,KAAK,CAAC;MACjC,OAAOZ,QAAQ,CAACC,QAAQ,CAAC;IAC3B;;IAEA;IACA,MAAMA,QAAQ,GAAG,MAAMH,SAAS,CAACmB,GAAG,CAAC,YAAY;MAC/C;MACA;MACA,MAAMC,GAAG,GAAG,MAAMzB,IAAI,CAACuB,GAAG,CAAC,4BAA4B,EAAE;QAAEP;MAAa,CAAC,CAAC;MAC1E,MAAMG,KAAK,GAAG,IAAIO,GAAG,CAACD,GAAG,CAACE,GAAG,CAAC,CAACC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;MAC9C,MAAMC,IAAI,GAAG,MAAML,GAAG,CAACK,IAAI,CAAC,CAAC;MAC7B7B,KAAK,CAACiB,GAAG,CAACC,KAAK,EAAEW,IAAI,EAAE5B,GAAG,CAAC;MAE3B,OAAO4B,IAAI;IACb,CAAC,CAAC;IACF,OAAOvB,QAAQ,CAACC,QAAQ,CAAC;EAC3B,CAAC;EAED,OAAOO,OAAO,CAACF,IAAI,EAAEC,IAAI,CAAC;AAC5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}