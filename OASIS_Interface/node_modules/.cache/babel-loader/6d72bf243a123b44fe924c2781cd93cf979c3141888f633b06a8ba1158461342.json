{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { createTopology } from '@libp2p/topology';\nimport { BitswapMessage as Message } from './message/index.js';\nimport * as CONSTANTS from './constants.js';\nimport { logger } from './utils/index.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableSource } from 'abortable-iterator';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\nconst DEFAULT_MAX_INBOUND_STREAMS = 32;\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 128;\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000;\nexport class Network {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  constructor(libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n      this._protocols.unshift(BITSWAP120);\n    }\n    this._stats = stats;\n    this._running = false;\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashLoader = options.hashLoader;\n    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;\n    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;\n    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT;\n  }\n  async start() {\n    this._running = true;\n    await this._libp2p.handle(this._protocols, this._onConnection, {\n      maxInboundStreams: this._maxInboundStreams,\n      maxOutboundStreams: this._maxOutboundStreams\n    });\n\n    // register protocol with topology\n    const topology = createTopology({\n      onConnect: this._onPeerConnect,\n      onDisconnect: this._onPeerDisconnect\n    });\n\n    /** @type {string[]} */\n    this._registrarIds = [];\n    for (const protocol of this._protocols) {\n      this._registrarIds.push(await this._libp2p.register(protocol, topology));\n    }\n\n    // All existing connections are like new ones for us\n    this._libp2p.getConnections().forEach(conn => {\n      this._onPeerConnect(conn.remotePeer);\n    });\n  }\n  async stop() {\n    this._running = false;\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    await this._libp2p.unhandle(this._protocols);\n\n    // unregister protocol and handlers\n    if (this._registrarIds != null) {\n      for (const id of this._registrarIds) {\n        this._libp2p.unregister(id);\n      }\n      this._registrarIds = [];\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {Stream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  _onConnection({\n    stream,\n    connection\n  }) {\n    if (!this._running) {\n      return;\n    }\n    const controller = new TimeoutController(this._incomingStreamTimeout);\n    Promise.resolve().then(async () => {\n      this._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer);\n      await pipe(abortableSource(stream.source, controller.signal), lp.decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await Message.deserialize(data.subarray(), this._hashLoader);\n            await this._bitswap._receiveMessage(connection.remotePeer, message);\n          } catch ( /** @type {any} */err) {\n            this._bitswap._receiveError(err);\n            break;\n          }\n\n          // we have received some data so reset the timeout controller\n          controller.reset();\n        }\n      });\n    }).catch(err => {\n      this._log(err);\n      stream.abort(err);\n    }).finally(() => {\n      controller.clear();\n      stream.close();\n    });\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders(cid, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, options);\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n    let found = 0;\n    for await (const provider of this.findProviders(cid, options)) {\n      this._log(`connecting to provider ${provider.id}`);\n      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {\n        // Prevent unhandled promise rejection\n        this._log.error(err);\n      }));\n      found++;\n      if (found === CONSTANTS.maxProvidersPerRequest) {\n        break;\n      }\n    }\n    await Promise.all(connectAttempts);\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide(cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options);\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toString();\n    this._log('sendMessage to %s', stringId, msg);\n    const connection = await this._libp2p.dial(peer);\n    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n    await writeMessage(stream, msg, this._log);\n    this._updateSentStats(peer, msg.blocks);\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo(peer, options) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n    return this._libp2p.dial(peer, options);\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toString();\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n}\n\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\nasync function writeMessage(stream, msg, log) {\n  try {\n    /** @type {Uint8Array} */\n    let serialized;\n    switch (stream.stat.protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n      default:\n        throw new Error('Unknown protocol: ' + stream.stat.protocol);\n    }\n    await pipe([serialized], lp.encode(), stream);\n  } catch (err) {\n    log(err);\n  } finally {\n    stream.close();\n  }\n}","map":{"version":3,"names":["lp","pipe","createTopology","BitswapMessage","Message","CONSTANTS","logger","TimeoutController","abortableSource","BITSWAP100","BITSWAP110","BITSWAP120","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","DEFAULT_INCOMING_STREAM_TIMEOUT","Network","constructor","libp2p","bitswap","stats","options","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashLoader","hashLoader","_maxInboundStreams","maxInboundStreams","_maxOutboundStreams","maxOutboundStreams","_incomingStreamTimeout","incomingStreamTimeout","start","handle","topology","onConnect","onDisconnect","_registrarIds","protocol","push","register","getConnections","forEach","conn","remotePeer","stop","unhandle","id","unregister","stream","connection","controller","Promise","resolve","then","stat","source","signal","decode","data","message","deserialize","subarray","_receiveMessage","err","_receiveError","reset","catch","abort","finally","clear","close","_onPeerConnected","_onPeerDisconnected","findProviders","cid","contentRouting","findAndConnect","connectAttempts","found","provider","connectTo","error","maxProvidersPerRequest","all","provide","sendMessage","peer","msg","Error","stringId","toString","dial","newStream","writeMessage","_updateSentStats","blocks","block","values","length","size","log","serialized","serializeToBitswap100","serializeToBitswap110","encode"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/network.js"],"sourcesContent":["import * as lp from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { createTopology } from '@libp2p/topology'\nimport { BitswapMessage as Message } from './message/index.js'\nimport * as CONSTANTS from './constants.js'\nimport { logger } from './utils/index.js'\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { abortableSource } from 'abortable-iterator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n * @typedef {import('@libp2p/interface-connection').Connection} Connection\n * @typedef {import('@libp2p/interface-connection').Stream} Stream\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n *\n * @typedef {object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {import('it-stream-types').Duplex<Uint8Array>} Duplex\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nconst DEFAULT_MAX_INBOUND_STREAMS = 32\nconst DEFAULT_MAX_OUTBOUND_STREAMS = 128\nconst DEFAULT_INCOMING_STREAM_TIMEOUT = 30000\n\nexport class Network {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {import('./bitswap').Bitswap} bitswap\n   * @param {import('./stats').Stats} stats\n   * @param {object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashLoader = options.hashLoader\n    this._maxInboundStreams = options.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS\n    this._maxOutboundStreams = options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n    this._incomingStreamTimeout = options.incomingStreamTimeout ?? DEFAULT_INCOMING_STREAM_TIMEOUT\n  }\n\n  async start () {\n    this._running = true\n    await this._libp2p.handle(this._protocols, this._onConnection, {\n      maxInboundStreams: this._maxInboundStreams,\n      maxOutboundStreams: this._maxOutboundStreams\n    })\n\n    // register protocol with topology\n    const topology = createTopology({\n      onConnect: this._onPeerConnect,\n      onDisconnect: this._onPeerDisconnect\n    })\n\n    /** @type {string[]} */\n    this._registrarIds = []\n\n    for (const protocol of this._protocols) {\n      this._registrarIds.push(await this._libp2p.register(protocol, topology))\n    }\n\n    // All existing connections are like new ones for us\n    this._libp2p.getConnections().forEach(conn => {\n      this._onPeerConnect(conn.remotePeer)\n    })\n  }\n\n  async stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    await this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarIds != null) {\n      for (const id of this._registrarIds) {\n        this._libp2p.unregister(id)\n      }\n\n      this._registrarIds = []\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {Stream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  _onConnection ({ stream, connection }) {\n    if (!this._running) {\n      return\n    }\n\n    const controller = new TimeoutController(this._incomingStreamTimeout)\n\n    Promise.resolve().then(async () => {\n      this._log('incoming new bitswap %s connection from %p', stream.stat.protocol, connection.remotePeer)\n\n      await pipe(\n        abortableSource(stream.source, controller.signal),\n        lp.decode(),\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.subarray(), this._hashLoader)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (/** @type {any} */ err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n\n            // we have received some data so reset the timeout controller\n            controller.reset()\n          }\n        }\n      )\n    })\n      .catch(err => {\n        this._log(err)\n        stream.abort(err)\n      })\n      .finally(() => {\n        controller.clear()\n        stream.close()\n      })\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, options = {}) {\n    return this._libp2p.contentRouting.findProviders(cid, options)\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    let found = 0\n\n    for await (const provider of this.findProviders(cid, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n\n      found++\n\n      if (found === CONSTANTS.maxProvidersPerRequest) {\n        break\n      }\n    }\n\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toString()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const stream = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    await writeMessage(stream, msg, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toString()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {Stream} stream\n * @param {Message} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    /** @type {Uint8Array} */\n    let serialized\n    switch (stream.stat.protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + stream.stat.protocol)\n    }\n\n    await pipe(\n      [serialized],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  } finally {\n    stream.close()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}