{"ast":null,"code":"import { isPeerId } from '@libp2p/interface-peer-id';\nimport { notFoundError } from 'datastore-core/errors';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport * as ipns from 'ipns';\nconst log = logger('ipfs:ipns:publisher');\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst ERR_NOT_FOUND = notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000;\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nexport class IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publishWithEOL(peerId, value, lifetime, options) {\n    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options);\n    return this._putRecordToRouting(record, peerId, options);\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} options\n   */\n  publish(peerId, value, options) {\n    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options);\n  }\n\n  /**\n   * @param {Uint8Array} record\n   * @param {PeerId} peerId\n   * @param {AbortOptions} [options]\n   */\n  async _putRecordToRouting(record, peerId, options) {\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    if (peerId.publicKey == null) {\n      throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY');\n    }\n    const routingKey = ipns.peerIdToRoutingKey(peerId);\n    await this._publishEntry(routingKey, record, options);\n    return record;\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} entry\n   * @param {AbortOptions} [options]\n   */\n  async _publishEntry(key, entry, options) {\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key, entry, options);\n      log(`ipns record for ${uint8ArrayToString(key, 'base32')} was stored in the routing`);\n      return res;\n    } catch ( /** @type {any} */err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key, 'base32')} could not be stored in the routing - ${err.stack}`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished(peerId, options = {}) {\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    const checkRouting = options.checkRouting !== false;\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()));\n\n      // unmarshal data\n      return this._unmarshalData(dsVal);\n    } catch ( /** @type {any} */err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      }\n\n      // Try to get from routing\n      try {\n        const routingKey = ipns.peerIdToRoutingKey(peerId);\n        const res = await this._routing.get(routingKey);\n\n        // unmarshal data\n        return this._unmarshalData(res);\n      } catch ( /** @type {any} */err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch ( /** @type {any} */err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async _updateOrCreateRecord(peerId, value, lifetime, options) {\n    if (!isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n\n    /** @type {IPNSEntry | undefined} */\n    let record;\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch ( /** @type {any} */err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err.stack}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n;\n    if (record && record.sequence !== undefined) {\n      // Increment if the published value is different\n      seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1);\n    }\n\n    /** @type {IPNSEntry} */\n    let entryData;\n    try {\n      // Create record\n      entryData = await ipns.create(peerId, value, seqNumber, lifetime);\n    } catch ( /** @type {any} */err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData);\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options);\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n      return data;\n    } catch ( /** @type {any} */err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n}\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;","map":{"version":3,"names":["isPeerId","notFoundError","errcode","logger","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","log","ERR_NOT_FOUND","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","peerId","value","lifetime","options","record","_updateOrCreateRecord","_putRecordToRouting","publish","errMsg","error","Error","publicKey","routingKey","peerIdToRoutingKey","_publishEntry","key","entry","res","put","err","stack","_getPublished","checkRouting","dsVal","get","getLocalKey","toBytes","_unmarshalData","data","unmarshal","getPublishedOptions","seqNumber","sequence","undefined","BigInt","entryData","create","marshal"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/publisher.js"],"sourcesContent":["import { isPeerId } from '@libp2p/interface-peer-id'\nimport { notFoundError } from 'datastore-core/errors'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport * as ipns from 'ipns'\n\nconst log = logger('ipfs:ipns:publisher')\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-keys').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst ERR_NOT_FOUND = notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nexport class IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publishWithEOL (peerId, value, lifetime, options) {\n    const record = await this._updateOrCreateRecord(peerId, value, lifetime, options)\n\n    return this._putRecordToRouting(record, peerId, options)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} options\n   */\n  publish (peerId, value, options) {\n    return this.publishWithEOL(peerId, value, defaultRecordLifetime, options)\n  }\n\n  /**\n   * @param {Uint8Array} record\n   * @param {PeerId} peerId\n   * @param {AbortOptions} [options]\n   */\n  async _putRecordToRouting (record, peerId, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    if (peerId.publicKey == null) {\n      throw errcode(new Error('Public key was missing'), 'ERR_MISSING_PUBLIC_KEY')\n    }\n\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n\n    await this._publishEntry(routingKey, record, options)\n\n    return record\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} entry\n   * @param {AbortOptions} [options]\n   */\n  async _publishEntry (key, entry, options) {\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key, entry, options)\n      log(`ipns record for ${uint8ArrayToString(key, 'base32')} was stored in the routing`)\n\n      return res\n    } catch (/** @type {any} */err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key, 'base32')} could not be stored in the routing - ${err.stack}`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.toBytes()))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.toString()} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const routingKey = ipns.peerIdToRoutingKey(peerId)\n        const res = await this._routing.get(routingKey)\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (/** @type {any} */ err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async _updateOrCreateRecord (peerId, value, lifetime, options) {\n    if (!(isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    /** @type {IPNSEntry | undefined} */\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.toString()} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      // Increment if the published value is different\n      seqNumber = uint8ArrayEquals(record.value, value) ? record.sequence : record.sequence + BigInt(1)\n    }\n\n    /** @type {IPNSEntry} */\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(peerId, value, seqNumber, lifetime)\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.toBytes()), data, options)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return data\n    } catch (/** @type {any} */ err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}