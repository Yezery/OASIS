{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Token, Type } from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${decodeErrPrefix} ${msg}`);\n  };\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = [];\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor; // uint.decodeUintCompact, handled by quick[]\n}\n\njump[0x18] = uint.decodeUint8; // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16; // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32; // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64; // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor;\njump[0x1d] = invalidMinor;\njump[0x1e] = invalidMinor;\njump[0x1f] = invalidMinor;\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor; // negintDecode, handled by quick[]\n}\n\njump[0x38] = negint.decodeNegint8; // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16; // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32; // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64; // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor;\njump[0x3d] = invalidMinor;\njump[0x3e] = invalidMinor;\njump[0x3f] = invalidMinor;\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[0x58] = bytes.decodeBytes8; // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16; // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32; // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64; // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor;\njump[0x5d] = invalidMinor;\njump[0x5e] = invalidMinor;\njump[0x5f] = errorer('indefinite length bytes/strings are not supported'); // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[0x78] = string.decodeString8; // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16; // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32; // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64; // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor;\njump[0x7d] = invalidMinor;\njump[0x7e] = invalidMinor;\njump[0x7f] = errorer('indefinite length bytes/strings are not supported'); // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[0x98] = array.decodeArray8; // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16; // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32; // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64; // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor;\njump[0x9d] = invalidMinor;\njump[0x9e] = invalidMinor;\njump[0x9f] = array.decodeArrayIndefinite; // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[0xb8] = map.decodeMap8; // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16; // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32; // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64; // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor;\njump[0xbd] = invalidMinor;\njump[0xbe] = invalidMinor;\njump[0xbf] = map.decodeMapIndefinite; // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[0xd8] = tag.decodeTag8;\njump[0xd9] = tag.decodeTag16;\njump[0xda] = tag.decodeTag32;\njump[0xdb] = tag.decodeTag64;\njump[0xdc] = invalidMinor;\njump[0xdd] = invalidMinor;\njump[0xde] = invalidMinor;\njump[0xdf] = invalidMinor;\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[0xf4] = invalidMinor; // false, handled by quick[]\njump[0xf5] = invalidMinor; // true, handled by quick[]\njump[0xf6] = invalidMinor; // null, handled by quick[]\njump[0xf7] = float.decodeUndefined; // undefined\njump[0xf8] = errorer('simple values are not supported'); // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16; // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32; // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64; // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor;\njump[0xfd] = invalidMinor;\njump[0xfe] = invalidMinor;\njump[0xff] = float.decodeBreak; // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = [];\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1);\n// empty string\nquick[0x60] = new Token(Type.string, '', 1);\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1);\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1);\n// false\nquick[0xf4] = new Token(Type.false, false, 1);\n// true\nquick[0xf5] = new Token(Type.true, true, 1);\n// null\nquick[0xf6] = new Token(Type.null, null, 1);\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4]);\n    case Type.true:\n      return fromArray([0xf5]);\n    case Type.null:\n      return fromArray([0xf6]);\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40]);\n      }\n      return;\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60]);\n      }\n      return;\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80]);\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return;\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0]);\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return;\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)]);\n      }\n      return;\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)]);\n      }\n  }\n}","map":{"version":3,"names":["Token","Type","uint","negint","bytes","string","array","map","tag","float","decodeErrPrefix","fromArray","invalidMinor","data","pos","minor","Error","errorer","msg","jump","i","decodeUint8","decodeUint16","decodeUint32","decodeUint64","decodeNegint8","decodeNegint16","decodeNegint32","decodeNegint64","decodeBytesCompact","decodeBytes8","decodeBytes16","decodeBytes32","decodeBytes64","decodeStringCompact","decodeString8","decodeString16","decodeString32","decodeString64","decodeArrayCompact","decodeArray8","decodeArray16","decodeArray32","decodeArray64","decodeArrayIndefinite","decodeMapCompact","decodeMap8","decodeMap16","decodeMap32","decodeMap64","decodeMapIndefinite","decodeTagCompact","decodeTag8","decodeTag16","decodeTag32","decodeTag64","decodeUndefined","decodeFloat16","decodeFloat32","decodeFloat64","decodeBreak","quick","Uint8Array","false","true","null","quickEncodeToken","token","type","value","length","Number"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/cborg@4.0.1/node_modules/cborg/lib/jump.js"],"sourcesContent":["import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}