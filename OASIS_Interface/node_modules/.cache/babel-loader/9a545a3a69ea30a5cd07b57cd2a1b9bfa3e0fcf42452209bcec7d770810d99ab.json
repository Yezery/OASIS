{"ast":null,"code":"const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n    const {\n      version\n    } = _client.topology.s.options.metadata.driver;\n    const _v = version.split('.').map(v => parseInt(v));\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2]\n    };\n  } catch (err) {\n    return {\n      major: 0,\n      feature: 0,\n      patch: 0\n    };\n  }\n}\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client.then(conn => {\n        this.client = conn;\n        this._initCollection();\n        this._driverVersion = getDriverVersion(this.client);\n      });\n    } else {\n      this._initCollection();\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n  get dbName() {\n    return this._dbName;\n  }\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n  get tableName() {\n    return this._tableName;\n  }\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n  get client() {\n    return this._client;\n  }\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n    this._client = value;\n  }\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n  _initCollection() {\n    const db = typeof this.client.db === 'function' ? this.client.db(this.dbName) : this.client;\n    const collection = db.collection(this.tableName);\n    collection.createIndex({\n      expire: -1\n    }, {\n      expireAfterSeconds: 0\n    });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, {\n      key: 1\n    }), {\n      unique: true\n    });\n    this._collection = collection;\n  }\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n    let doc;\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0) : -1;\n    return res;\n  }\n  _upsert(key, points, msDuration, forceExpire = false, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n    const docAttrs = options.attrs || {};\n    let where;\n    let upsertData;\n    if (forceExpire) {\n      where = {\n        key\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n        }\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [{\n          expire: {\n            $gt: new Date()\n          }\n        }, {\n          expire: {\n            $eq: null\n          }\n        }],\n        key\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n        },\n        $inc: {\n          points\n        }\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    }\n\n    // Options for collection updates differ between driver versions\n    const upsertOptions = {\n      upsert: true\n    };\n    if (this._driverVersion.major >= 4 || this._driverVersion.major === 3 && this._driverVersion.feature >= 7 || this._driverVersion.feature >= 6 && this._driverVersion.patch >= 7) {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(where, upsertData, upsertOptions).then(res => {\n        resolve(res);\n      }).catch(errUpsert => {\n        if (errUpsert && errUpsert.code === 11000) {\n          // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({\n            // try to replace OLD limit doc\n            $or: [{\n              expire: {\n                $lte: new Date()\n              }\n            }, {\n              expire: {\n                $eq: null\n              }\n            }],\n            key\n          }, docAttrs);\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null\n            }, docAttrs)\n          };\n          this._collection.findOneAndUpdate(replaceWhere, replaceTo, upsertOptions).then(res => {\n            resolve(res);\n          }).catch(errReplace => {\n            if (errReplace && errReplace.code === 11000) {\n              // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire).then(res => resolve(res)).catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n  _get(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({\n      key: rlKey,\n      $or: [{\n        expire: {\n          $gt: new Date()\n        }\n      }, {\n        expire: {\n          $eq: null\n        }\n      }]\n    }, docAttrs);\n    return this._collection.findOne(where);\n  }\n  _delete(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({\n      key: rlKey\n    }, docAttrs);\n    return this._collection.deleteOne(where).then(res => res.deletedCount > 0);\n  }\n}\nmodule.exports = RateLimiterMongo;","map":{"version":3,"names":["RateLimiterStoreAbstract","require","RateLimiterRes","getDriverVersion","client","_client","version","topology","s","options","metadata","driver","_v","split","map","v","parseInt","major","feature","patch","err","RateLimiterMongo","constructor","opts","dbName","tableName","indexKeyPrefix","mongo","storeClient","then","conn","_initCollection","_driverVersion","_dbName","value","getDbName","_tableName","keyPrefix","Error","_indexKeyPrefix","obj","db","collection","createIndex","expire","expireAfterSeconds","Object","assign","key","unique","_collection","_getRateLimiterRes","rlKey","changedPoints","result","res","doc","isFirstInDuration","points","consumedPoints","remainingPoints","Math","max","msBeforeNext","Date","getTime","now","_upsert","msDuration","forceExpire","Promise","reject","docAttrs","attrs","where","upsertData","$set","$or","$gt","$eq","$setOnInsert","$inc","upsertOptions","upsert","returnDocument","returnOriginal","resolve","findOneAndUpdate","catch","errUpsert","code","replaceWhere","$lte","replaceTo","errReplace","_get","findOne","_delete","deleteOne","deletedCount","module","exports"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterMongo.js"],"sourcesContent":["const RateLimiterStoreAbstract = require('./RateLimiterStoreAbstract');\nconst RateLimiterRes = require('./RateLimiterRes');\n\n/**\n * Get MongoDB driver version as upsert options differ\n * @params {Object} Client instance\n * @returns {Object} Version Object containing major, feature & minor versions.\n */\nfunction getDriverVersion(client) {\n  try {\n    const _client = client.client ? client.client : client;\n\n    const { version } = _client.topology.s.options.metadata.driver;\n    const _v = version.split('.').map(v => parseInt(v));\n\n    return {\n      major: _v[0],\n      feature: _v[1],\n      patch: _v[2],\n    };\n  } catch (err) {\n    return { major: 0, feature: 0, patch: 0 };\n  }\n}\n\nclass RateLimiterMongo extends RateLimiterStoreAbstract {\n  /**\n   *\n   * @param {Object} opts\n   * Defaults {\n   *   indexKeyPrefix: {attr1: 1, attr2: 1}\n   *   ... see other in RateLimiterStoreAbstract\n   *\n   *   mongo: MongoClient\n   * }\n   */\n  constructor(opts) {\n    super(opts);\n\n    this.dbName = opts.dbName;\n    this.tableName = opts.tableName;\n    this.indexKeyPrefix = opts.indexKeyPrefix;\n\n    if (opts.mongo) {\n      this.client = opts.mongo;\n    } else {\n      this.client = opts.storeClient;\n    }\n    if (typeof this.client.then === 'function') {\n      // If Promise\n      this.client\n        .then((conn) => {\n          this.client = conn;\n          this._initCollection();\n          this._driverVersion = getDriverVersion(this.client);\n        });\n    } else {\n      this._initCollection();\n      this._driverVersion = getDriverVersion(this.client);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(value) {\n    this._dbName = typeof value === 'undefined' ? RateLimiterMongo.getDbName() : value;\n  }\n\n  static getDbName() {\n    return 'node-rate-limiter-flexible';\n  }\n\n  get tableName() {\n    return this._tableName;\n  }\n\n  set tableName(value) {\n    this._tableName = typeof value === 'undefined' ? this.keyPrefix : value;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('mongo is not set');\n    }\n    this._client = value;\n  }\n\n  get indexKeyPrefix() {\n    return this._indexKeyPrefix;\n  }\n\n  set indexKeyPrefix(obj) {\n    this._indexKeyPrefix = obj || {};\n  }\n\n  _initCollection() {\n    const db = typeof this.client.db === 'function'\n      ? this.client.db(this.dbName)\n      : this.client;\n\n    const collection = db.collection(this.tableName);\n    collection.createIndex({ expire: -1 }, { expireAfterSeconds: 0 });\n    collection.createIndex(Object.assign({}, this.indexKeyPrefix, { key: 1 }), { unique: true });\n\n    this._collection = collection;\n  }\n\n  _getRateLimiterRes(rlKey, changedPoints, result) {\n    const res = new RateLimiterRes();\n\n    let doc;\n    if (typeof result.value === 'undefined') {\n      doc = result;\n    } else {\n      doc = result.value;\n    }\n\n    res.isFirstInDuration = doc.points === changedPoints;\n    res.consumedPoints = doc.points;\n\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    res.msBeforeNext = doc.expire !== null\n      ? Math.max(new Date(doc.expire).getTime() - Date.now(), 0)\n      : -1;\n\n    return res;\n  }\n\n  _upsert(key, points, msDuration, forceExpire = false, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    let where;\n    let upsertData;\n    if (forceExpire) {\n      where = { key };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $set: {\n          key,\n          points,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n      };\n      upsertData.$set = Object.assign(upsertData.$set, docAttrs);\n    } else {\n      where = {\n        $or: [\n          { expire: { $gt: new Date() } },\n          { expire: { $eq: null } },\n        ],\n        key,\n      };\n      where = Object.assign(where, docAttrs);\n      upsertData = {\n        $setOnInsert: {\n          key,\n          expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n        },\n        $inc: { points },\n      };\n      upsertData.$setOnInsert = Object.assign(upsertData.$setOnInsert, docAttrs);\n    }\n\n    // Options for collection updates differ between driver versions\n    const upsertOptions = {\n      upsert: true,\n    };\n    if ((this._driverVersion.major >= 4) ||\n        (this._driverVersion.major === 3 &&\n          (this._driverVersion.feature >=7) || \n          (this._driverVersion.feature >= 6 && \n              this._driverVersion.patch >= 7 ))) \n    {\n      upsertOptions.returnDocument = 'after';\n    } else {\n      upsertOptions.returnOriginal = false;\n    }\n\n    /*\n     * 1. Find actual limit and increment points\n     * 2. If limit expired, but Mongo doesn't clean doc by TTL yet, try to replace limit doc completely\n     * 3. If 2 or more Mongo threads try to insert the new limit doc, only the first succeed\n     * 4. Try to upsert from step 1. Actual limit is created now, points are incremented without problems\n     */\n    return new Promise((resolve, reject) => {\n      this._collection.findOneAndUpdate(\n        where,\n        upsertData,\n        upsertOptions\n      ).then((res) => {\n        resolve(res);\n      }).catch((errUpsert) => {\n        if (errUpsert && errUpsert.code === 11000) { // E11000 duplicate key error collection\n          const replaceWhere = Object.assign({ // try to replace OLD limit doc\n            $or: [\n              { expire: { $lte: new Date() } },\n              { expire: { $eq: null } },\n            ],\n            key,\n          }, docAttrs);\n\n          const replaceTo = {\n            $set: Object.assign({\n              key,\n              points,\n              expire: msDuration > 0 ? new Date(Date.now() + msDuration) : null,\n            }, docAttrs)\n          };\n\n          this._collection.findOneAndUpdate(\n            replaceWhere,\n            replaceTo,\n            upsertOptions\n          ).then((res) => {\n            resolve(res);\n          }).catch((errReplace) => {\n            if (errReplace && errReplace.code === 11000) { // E11000 duplicate key error collection\n              this._upsert(key, points, msDuration, forceExpire)\n                .then(res => resolve(res))\n                .catch(err => reject(err));\n            } else {\n              reject(errReplace);\n            }\n          });\n        } else {\n          reject(errUpsert);\n        }\n      });\n    });\n  }\n\n  _get(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n\n    const where = Object.assign({\n      key: rlKey,\n      $or: [\n        { expire: { $gt: new Date() } },\n        { expire: { $eq: null } },\n      ],\n    }, docAttrs);\n\n    return this._collection.findOne(where);\n  }\n\n  _delete(rlKey, options = {}) {\n    if (!this._collection) {\n      return Promise.reject(Error('Mongo connection is not established'));\n    }\n\n    const docAttrs = options.attrs || {};\n    const where = Object.assign({ key: rlKey }, docAttrs);\n\n    return this._collection.deleteOne(where)\n      .then(res => res.deletedCount > 0);\n  }\n}\n\nmodule.exports = RateLimiterMongo;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}