{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * @example\n *\n * ```js\n * import { abortableSource } from 'abortable-iterator'\n *\n * async function main () {\n *   // An example function that creates an async iterator that yields an increasing\n *   // number every x milliseconds and NEVER ENDS!\n *   const asyncCounter = async function * (start, delay) {\n *     let i = start\n *     while (true) {\n *       yield new Promise(resolve => setTimeout(() => resolve(i++), delay))\n *     }\n *   }\n *\n *   // Create a counter that'll yield numbers from 0 upwards every second\n *   const everySecond = asyncCounter(0, 1000)\n *\n *   // Make everySecond abortable!\n *   const controller = new AbortController()\n *   const abortableEverySecond = abortableSource(everySecond, controller.signal)\n *\n *   // Abort after 5 seconds\n *   setTimeout(() => controller.abort(), 5000)\n *\n *   try {\n *     // Start the iteration, which will throw after 5 seconds when it is aborted\n *     for await (const n of abortableEverySecond) {\n *       console.log(n)\n *     }\n *   } catch (err) {\n *     if (err.code === 'ERR_ABORTED') {\n *       // Expected - all ok :D\n *     } else {\n *       throw err\n *     }\n *   }\n * }\n *\n * main()\n * ```\n */\nimport { AbortError } from './abort-error.js';\nimport { getIterator } from 'get-iterator';\n/**\n * Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n */\nexport function abortableSource(source, signal, options) {\n  const opts = options ?? {};\n  const iterator = getIterator(source);\n  async function* abortable() {\n    let nextAbortHandler;\n    const abortHandler = () => {\n      if (nextAbortHandler != null) nextAbortHandler();\n    };\n    signal.addEventListener('abort', abortHandler);\n    while (true) {\n      let result;\n      try {\n        if (signal.aborted) {\n          const {\n            abortMessage,\n            abortCode\n          } = opts;\n          throw new AbortError(abortMessage, abortCode);\n        }\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              abortMessage,\n              abortCode\n            } = opts;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        });\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, iterator.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        signal.removeEventListener('abort', abortHandler);\n        // Might not have been aborted by a known signal\n        const isKnownAborter = err.type === 'aborted' && signal.aborted;\n        if (isKnownAborter && opts.onAbort != null) {\n          // Do any custom abort handling for the iterator\n          opts.onAbort(source);\n        }\n        // End the iterator if it is a generator\n        if (typeof iterator.return === 'function') {\n          try {\n            const p = iterator.return();\n            if (p instanceof Promise) {\n              // eslint-disable-line max-depth\n              p.catch(err => {\n                if (opts.onReturnError != null) {\n                  opts.onReturnError(err);\n                }\n              });\n            }\n          } catch (err) {\n            if (opts.onReturnError != null) {\n              // eslint-disable-line max-depth\n              opts.onReturnError(err);\n            }\n          }\n        }\n        if (isKnownAborter && opts.returnOnAbort === true) {\n          return;\n        }\n        throw err;\n      }\n      if (result.done === true) {\n        break;\n      }\n      yield result.value;\n    }\n    signal.removeEventListener('abort', abortHandler);\n  }\n  return abortable();\n}\nexport function abortableSink(sink, signal, options) {\n  return source => sink(abortableSource(source, signal, options));\n}\nexport function abortableDuplex(duplex, signal, options) {\n  return {\n    sink: abortableSink(duplex.sink, signal, {\n      ...options,\n      onAbort: undefined\n    }),\n    source: abortableSource(duplex.source, signal, options)\n  };\n}\nexport { AbortError };\nexport { abortableSink as abortableTransform };","map":{"version":3,"names":["AbortError","getIterator","abortableSource","source","signal","options","opts","iterator","abortable","nextAbortHandler","abortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","race","next","err","removeEventListener","isKnownAborter","type","onAbort","return","p","catch","onReturnError","returnOnAbort","done","value","abortableSink","sink","abortableDuplex","duplex","undefined","abortableTransform"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}