{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { encode, prepare } from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\nimport { createHAMT, Bucket } from 'hamt-sharding';\n\n/**\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @typedef {import('./dir').DirProps} DirProps\n */\n\nclass DirSharded extends Dir {\n  /**\n   * @param {DirProps} props\n   * @param {ImporterOptions} options\n   */\n  constructor(props, options) {\n    super(props, options);\n\n    /** @type {Bucket<InProgressImportResult | Dir>} */\n    this._bucket = createHAMT({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    });\n  }\n\n  /**\n   * @param {string} name\n   * @param {InProgressImportResult | Dir} value\n   */\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n\n  /**\n   * @param {string} name\n   */\n  get(name) {\n    return this._bucket.get(name);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {\n      key,\n      value\n    } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n  async *flush(blockstore) {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      };\n    }\n  }\n}\nexport default DirSharded;\n\n/**\n * @param {Bucket<?>} bucket\n * @param {Blockstore} blockstore\n * @param {*} shardRoot\n * @param {ImporterOptions} options\n * @returns {AsyncIterable<ImportResult>}\n */\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n    if (!child) {\n      continue;\n    }\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n    if (child instanceof Bucket) {\n      let shard;\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n      if (!value.cid) {\n        continue;\n      }\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = encode(prepare(node));\n  const cid = await persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  };\n}","map":{"version":3,"names":["encode","prepare","UnixFS","Dir","persist","createHAMT","Bucket","DirSharded","constructor","props","options","_bucket","hashFn","hamtHashFn","bits","hamtBucketBits","put","name","value","get","childCount","leafCount","directChildrenCount","childrenCount","onlyChild","eachChildSeries","key","eachLeafSeries","child","flush","blockstore","entry","path","bucket","shardRoot","children","_children","links","childrenSize","i","length","labelPrefix","toString","toUpperCase","padStart","shard","subShard","Error","push","Name","Tsize","size","Hash","cid","dir","flushedDir","label","data","Uint8Array","from","bitField","reverse","type","fanout","tableSize","hashType","hamtHashCode","mtime","mode","node","Data","marshal","Links","buffer","unixfs"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-importer@12.0.1/node_modules/ipfs-unixfs-importer/src/dir-sharded.js"],"sourcesContent":["import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport Dir from './dir.js'\nimport persist from './utils/persist.js'\nimport { createHAMT, Bucket } from 'hamt-sharding'\n\n/**\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @typedef {import('./dir').DirProps} DirProps\n */\n\nclass DirSharded extends Dir {\n  /**\n   * @param {DirProps} props\n   * @param {ImporterOptions} options\n   */\n  constructor (props, options) {\n    super(props, options)\n\n    /** @type {Bucket<InProgressImportResult | Dir>} */\n    this._bucket = createHAMT({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {InProgressImportResult | Dir} value\n   */\n  async put (name, value) {\n    await this._bucket.put(name, value)\n  }\n\n  /**\n   * @param {string} name\n   */\n  get (name) {\n    return this._bucket.get(name)\n  }\n\n  childCount () {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount () {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild () {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries () {\n    for await (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n  async * flush (blockstore) {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nexport default DirSharded\n\n/**\n * @param {Bucket<?>} bucket\n * @param {Blockstore} blockstore\n * @param {*} shardRoot\n * @param {ImporterOptions} options\n * @returns {AsyncIterable<ImportResult>}\n */\nasync function * flush (bucket, blockstore, shardRoot, options) {\n  const children = bucket._children\n  const links = []\n  let childrenSize = 0\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (!child) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      let flushedDir\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (!value.cid) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      })\n      childrenSize += size\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = buffer.length + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}