{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\n/**\n * Checks a record and ensures it is still valid.\n * It runs the needed validators.\n * If verification fails the returned Promise will reject with the error.\n */\nexport async function verifyRecord(validators, record) {\n  const key = record.key;\n  const keyString = uint8ArrayToString(key);\n  const parts = keyString.split('/');\n  if (parts.length < 3) {\n    // No validator available\n    return;\n  }\n  const validator = validators[parts[1].toString()];\n  if (validator == null) {\n    const errMsg = 'Invalid record keytype';\n    throw new CodeError(errMsg, 'ERR_INVALID_RECORD_KEY_TYPE');\n  }\n  await validator(key, record.value);\n}\n/**\n * Validator for public key records.\n * Verifies that the passed in record value is the PublicKey\n * that matches the passed in key.\n * If validation fails the returned Promise will reject with the error.\n *\n * @param {Uint8Array} key - A valid key is of the form `'/pk/<keymultihash>'`\n * @param {Uint8Array} publicKey - The public key to validate against (protobuf encoded).\n */\nconst validatePublicKeyRecord = async (key, publicKey) => {\n  if (!(key instanceof Uint8Array)) {\n    throw new CodeError('\"key\" must be a Uint8Array', 'ERR_INVALID_RECORD_KEY_NOT_BUFFER');\n  }\n  if (key.byteLength < 5) {\n    throw new CodeError('invalid public key record', 'ERR_INVALID_RECORD_KEY_TOO_SHORT');\n  }\n  const prefix = uint8ArrayToString(key.subarray(0, 4));\n  if (prefix !== '/pk/') {\n    throw new CodeError('key was not prefixed with /pk/', 'ERR_INVALID_RECORD_KEY_BAD_PREFIX');\n  }\n  const keyhash = key.slice(4);\n  const publicKeyHash = await sha256.digest(publicKey);\n  if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {\n    throw new CodeError('public key does not match passed in key', 'ERR_INVALID_RECORD_HASH_MISMATCH');\n  }\n};\nexport const validators = {\n  pk: validatePublicKeyRecord\n};","map":{"version":3,"names":["CodeError","sha256","equals","uint8ArrayEquals","toString","uint8ArrayToString","verifyRecord","validators","record","key","keyString","parts","split","length","validator","errMsg","value","validatePublicKeyRecord","publicKey","Uint8Array","byteLength","prefix","subarray","keyhash","slice","publicKeyHash","digest","bytes","pk"],"sources":["../../src/validators.ts"],"sourcesContent":[null],"mappings":";;;AAAA,SAASA,SAAS,QAAQ,2BAA2B;AACrD,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,MAAM,IAAIC,gBAAgB,QAAQ,oBAAoB;AAC/D,SAASC,QAAQ,IAAIC,kBAAkB,QAAQ,uBAAuB;AAItE;;;;;AAKA,OAAO,eAAeC,YAAYA,CAAEC,UAAsB,EAAEC,MAAoB;EAC9E,MAAMC,GAAG,GAAGD,MAAM,CAACC,GAAG;EACtB,MAAMC,SAAS,GAAGL,kBAAkB,CAACI,GAAG,CAAC;EACzC,MAAME,KAAK,GAAGD,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC;EAElC,IAAID,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;IACpB;IACA;;EAGF,MAAMC,SAAS,GAAGP,UAAU,CAACI,KAAK,CAAC,CAAC,CAAC,CAACP,QAAQ,EAAE,CAAC;EAEjD,IAAIU,SAAS,IAAI,IAAI,EAAE;IACrB,MAAMC,MAAM,GAAG,wBAAwB;IAEvC,MAAM,IAAIf,SAAS,CAACe,MAAM,EAAE,6BAA6B,CAAC;;EAG5D,MAAMD,SAAS,CAACL,GAAG,EAAED,MAAM,CAACQ,KAAK,CAAC;AACpC;AAEA;;;;;;;;;AASA,MAAMC,uBAAuB,GAAG,MAAAA,CAAOR,GAAe,EAAES,SAAqB,KAAmB;EAC9F,IAAI,EAAET,GAAG,YAAYU,UAAU,CAAC,EAAE;IAChC,MAAM,IAAInB,SAAS,CAAC,4BAA4B,EAAE,mCAAmC,CAAC;;EAGxF,IAAIS,GAAG,CAACW,UAAU,GAAG,CAAC,EAAE;IACtB,MAAM,IAAIpB,SAAS,CAAC,2BAA2B,EAAE,kCAAkC,CAAC;;EAGtF,MAAMqB,MAAM,GAAGhB,kBAAkB,CAACI,GAAG,CAACa,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAErD,IAAID,MAAM,KAAK,MAAM,EAAE;IACrB,MAAM,IAAIrB,SAAS,CAAC,gCAAgC,EAAE,mCAAmC,CAAC;;EAG5F,MAAMuB,OAAO,GAAGd,GAAG,CAACe,KAAK,CAAC,CAAC,CAAC;EAE5B,MAAMC,aAAa,GAAG,MAAMxB,MAAM,CAACyB,MAAM,CAACR,SAAS,CAAC;EAEpD,IAAI,CAACf,gBAAgB,CAACoB,OAAO,EAAEE,aAAa,CAACE,KAAK,CAAC,EAAE;IACnD,MAAM,IAAI3B,SAAS,CAAC,yCAAyC,EAAE,kCAAkC,CAAC;;AAEtG,CAAC;AAED,OAAO,MAAMO,UAAU,GAAe;EACpCqB,EAAE,EAAEX;CACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}