{"ast":null,"code":"import { loadMfsRoot } from './with-mfs-root.js';\nimport { toPathComponents } from './to-path-components.js';\nimport { exporter } from 'ipfs-unixfs-exporter';\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nconst IPFS_PREFIX = 'ipfs';\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nexport const toMfsPath = async (context, path, options) => {\n  const root = await loadMfsRoot(context, options);\n\n  /** @type {MfsPath} */\n  // @ts-expect-error fields get set later\n  let output = {\n    entryType: 'file'\n  };\n  let ipfsPath = '';\n  if (CID.asCID(path)) {\n    ipfsPath = `/ipfs/${path}`;\n  } else {\n    ipfsPath = path.toString();\n  }\n  ipfsPath = ipfsPath.trim();\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n  if (!ipfsPath) {\n    throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n  }\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n  }\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n  }\n  const pathComponents = toPathComponents(ipfsPath);\n  if (pathComponents[0] === IPFS_PREFIX) {\n    // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n    let mfsDirectory;\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`;\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    }\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  }\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n  try {\n    const res = await exporter(cidPath, context.repo.blocks, options);\n    output.cid = res.cid;\n    output.mfsPath = `/ipfs/${res.path}`;\n    output.entryType = res.type;\n    output.content = res.content;\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs;\n    }\n  } catch ( /** @type {any} */err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n  output.exists = Boolean(output.cid);\n  return output;\n};","map":{"version":3,"names":["loadMfsRoot","toPathComponents","exporter","errCode","CID","IPFS_PREFIX","toMfsPath","context","path","options","root","output","entryType","ipfsPath","asCID","toString","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","cidPath","res","repo","blocks","cid","content","unixfs","err","code","exists","Boolean"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js"],"sourcesContent":["import { loadMfsRoot } from './with-mfs-root.js'\nimport { toPathComponents } from './to-path-components.js'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\n\nconst IPFS_PREFIX = 'ipfs'\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nexport const toMfsPath = async (context, path, options) => {\n  const root = await loadMfsRoot(context, options)\n\n  /** @type {MfsPath} */\n  // @ts-expect-error fields get set later\n  let output = {\n    entryType: 'file'\n  }\n\n  let ipfsPath = ''\n\n  if (CID.asCID(path)) {\n    ipfsPath = `/ipfs/${path}`\n  } else {\n    ipfsPath = path.toString()\n  }\n\n  ipfsPath = ipfsPath.trim()\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/')\n\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  if (!ipfsPath) {\n    throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n  }\n\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n  }\n\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  const pathComponents = toPathComponents(ipfsPath)\n\n  if (pathComponents[0] === IPFS_PREFIX) {\n    // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n    let mfsDirectory\n\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n    }\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    // @ts-expect-error fields being set\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  }\n\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path\n\n  try {\n    const res = await exporter(cidPath, context.repo.blocks, options)\n\n    output.cid = res.cid\n    output.mfsPath = `/ipfs/${res.path}`\n    output.entryType = res.type\n    output.content = res.content\n\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs\n    }\n  } catch (/** @type {any} */ err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  output.exists = Boolean(output.cid)\n\n  return output\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}