{"ast":null,"code":"import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\n\n/**\n * @typedef {import('../../types').Resolve} Resolve\n * @typedef {import('../../types').Resolver} Resolver\n * @typedef {import('../../types').UnixfsV1Resolver} UnixfsV1Resolver\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n */\n\n/**\n * @param {PBNode} node\n * @param {string} name\n */\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\n\n/**\n * @type {{ [key: string]: UnixfsV1Resolver }}\n */\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\n\n/**\n * @type {Resolver}\n */\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options);\n  const node = decode(block);\n  let unixfs;\n  let next;\n  if (!name) {\n    name = cid.toString();\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch ( /** @type {any} */err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (!path) {\n    path = name;\n  }\n  if (toResolve.length) {\n    let linkCid;\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift();\n    const nextPath = `${path}/${nextName}`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    };\n  }\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      // @ts-ignore\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  };\n};\nexport default unixFsResolver;","map":{"version":3,"names":["errCode","UnixFS","findShardCid","decode","contentFile","contentDirectory","contentHamtShardedDirectory","findLinkCid","node","name","link","Links","find","Name","Hash","contentExporters","raw","file","directory","metadata","cid","unixfs","path","resolve","depth","blockstore","symlink","unixFsResolver","toResolve","options","block","get","next","toString","Data","Error","unmarshal","err","length","linkCid","type","nextName","shift","nextPath","entry","isDirectory","content","size","fileSize"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-exporter@10.0.1/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js"],"sourcesContent":["import errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport { decode } from '@ipld/dag-pb'\n\nimport contentFile from './content/file.js'\nimport contentDirectory from './content/directory.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\n\n/**\n * @typedef {import('../../types').Resolve} Resolve\n * @typedef {import('../../types').Resolver} Resolver\n * @typedef {import('../../types').UnixfsV1Resolver} UnixfsV1Resolver\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n */\n\n/**\n * @param {PBNode} node\n * @param {string} name\n */\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link && link.Hash\n}\n\n/**\n * @type {{ [key: string]: UnixfsV1Resolver }}\n */\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n/**\n * @type {Resolver}\n */\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (!name) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (/** @type {any} */ err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  if (!path) {\n    path = name\n  }\n\n  if (toResolve.length) {\n    let linkCid\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    }\n  }\n\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      // @ts-ignore\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}