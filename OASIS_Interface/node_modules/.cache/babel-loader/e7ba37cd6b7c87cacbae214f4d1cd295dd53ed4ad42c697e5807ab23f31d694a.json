{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { logger } from '@libp2p/logger';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { generatePath, updateHamtDirectory } from './hamt-utils.js';\nimport errCode from 'err-code';\nconst log = logger('ipfs:mfs:core:utils:remove-link');\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nexport async function removeLink(context, options) {\n  let parent = options.parent;\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid);\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n    }\n    log(`Loading parent node ${parentCid}`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPB.decode(block);\n  }\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n  }\n  const meta = UnixFS.unmarshal(parent.Data);\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    });\n  }\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  });\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  const parentBlock = await dagPB.encode(options.parent);\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const hash = await hasher.digest(parentBlock);\n  const parentCid = CID.create(options.cidVersion, dagPB.code, hash);\n  await context.repo.blocks.put(parentCid, parentBlock);\n  log(`Updated regular directory ${parentCid}`);\n  return {\n    node: options.parent,\n    cid: parentCid\n  };\n};\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, options.name, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop();\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n  const {\n    bucket,\n    prefix,\n    node\n  } = last;\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n  const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n  }\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`);\n    const links = node.Links.filter(nodeLink => {\n      return nodeLink.Name !== link.Name;\n    });\n    await bucket.del(name);\n    return updateHamtDirectory(context, links, bucket, options);\n  }\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n  const result = await updateShard(context, positions, name, options);\n  let cid = result.cid;\n  let size = result.size;\n  let newName = prefix;\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`);\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0];\n    newName = `${prefix}${(link.Name || '').substring(2)}`;\n    cid = link.Hash;\n    size = link.Tsize || 0;\n  }\n  log(`Updating shard ${prefix} with name ${newName}`);\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n};\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};","map":{"version":3,"names":["dagPB","CID","logger","UnixFS","generatePath","updateHamtDirectory","errCode","log","removeLink","context","options","parent","parentCid","asCID","Error","block","repo","blocks","get","decode","name","Data","meta","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","parentBlock","encode","hasher","hashers","getHasher","hashAlg","hash","digest","create","cidVersion","code","put","node","cid","rootBucket","path","del","updateShard","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"sourcesContent":["\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport {\n  generatePath,\n  updateHamtDirectory\n} from './hamt-utils.js'\nimport errCode from 'err-code'\n\nconst log = logger('ipfs:mfs:core:utils:remove-link')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nexport async function removeLink (context, options) {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPB.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPB.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPB.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}