{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"names":["ENGINE","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["../../../../../../tfjs-core/src/ops/tensor_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {TensorLike, TypedArray} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike, shape: number[], inferredShape: number[],\n    dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAIhC,SAAQC,MAAM,EAAEC,kCAAkC,EAAEC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAEC,aAAa,EAAEC,YAAY,QAAO,SAAS;AAElI;AACA,OAAM,SAAUC,UAAUA,CACtBC,MAAkB,EAAEC,KAAe,EAAEC,aAAuB,EAC5DC,KAAgB;EAClB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjBA,KAAK,GAAGR,UAAU,CAACK,MAAM,CAAC;;EAE5B,IAAIG,KAAK,KAAK,WAAW,EAAE;IACzB,MAAM,IAAIC,KAAK,CACX,gDAAgD,GAChD,oCAAoC,CAAC;;EAE3C,IAAI,CAACR,YAAY,CAACI,MAAM,CAAC,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,IAC/C,OAAOA,MAAM,KAAK,QAAQ,IAAI,OAAOA,MAAM,KAAK,SAAS,IACzD,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAII,KAAK,CACX,qEAAqE,GACrE,uDAAuD,CAAC;;EAE9D,IAAIH,KAAK,IAAI,IAAI,EAAE;IACjBR,kCAAkC,CAACQ,KAAK,CAAC;IAEzC,MAAMM,YAAY,GAAGV,aAAa,CAACI,KAAK,CAAC;IACzC,MAAMO,YAAY,GAAGX,aAAa,CAACK,aAAa,CAAC;IACjDV,MAAM,CACFe,YAAY,KAAKC,YAAY,EAC7B,MACI,iCAAiCP,KAAK,4BAA4B,GAClE,GAAGM,YAAY,mBAAmBC,YAAY,EAAE,CAAC;IAEzD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,aAAa,CAACQ,MAAM,EAAE,EAAED,CAAC,EAAE;MAC7C,MAAME,QAAQ,GAAGT,aAAa,CAACO,CAAC,CAAC;MACjC,MAAMG,iBAAiB,GAAGH,CAAC,KAAKP,aAAa,CAACQ,MAAM,GAAG,CAAC,GACpDC,QAAQ,KAAKd,aAAa,CAACI,KAAK,CAACY,KAAK,CAACJ,CAAC,CAAC,CAAC,GAC1C,IAAI;MACRjB,MAAM,CACFU,aAAa,CAACO,CAAC,CAAC,KAAKR,KAAK,CAACQ,CAAC,CAAC,IAAI,CAACG,iBAAiB,EACnD,MAAM,8CAA8C,GAChD,IAAIV,aAAa,gCAAgC,GACjD,UAAUD,KAAK,KAAK,CAAC;;;EAIjC,IAAI,CAACL,YAAY,CAACI,MAAM,CAAC,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,EAAE;IACnDA,MAAM,GAAG,CAACA,MAAM,CAAa;;EAG/BC,KAAK,GAAGA,KAAK,IAAIC,aAAa;EAC9BF,MAAM,GAAGG,KAAK,KAAK,QAAQ,GACvBL,YAAY,CAACE,MAAM,EAAEG,KAAK,CAAC,GAC3BT,OAAO,CAACM,MAAkB,EAAE,EAAE,EAAE,IAAI,CAAa;EACrD,OAAOT,MAAM,CAACQ,UAAU,CAACC,MAAoB,EAAEC,KAAK,EAAEE,KAAK,CAAC;AAC9D"},"metadata":{},"sourceType":"module","externalDependencies":[]}