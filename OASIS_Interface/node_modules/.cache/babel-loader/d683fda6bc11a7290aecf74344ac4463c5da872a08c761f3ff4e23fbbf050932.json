{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\n\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').ExporterOptions} ExporterOptions\n * @typedef {import('./types').UnixFSFile} UnixFSFile\n * @typedef {import('./types').UnixFSDirectory} UnixFSDirectory\n * @typedef {import('./types').ObjectNode} ObjectNode\n * @typedef {import('./types').RawNode} RawNode\n * @typedef {import('./types').IdentityNode} IdentityNode\n * @typedef {import('./types').UnixFSEntry} UnixFSEntry\n */\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\n/**\n * @param {string|Uint8Array|CID} path\n */\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  /**\n   * @param {UnixFSDirectory} node\n   * @param {ExporterOptions} options\n   * @returns {AsyncGenerator<UnixFSEntry, void, any>}\n   */\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}","map":{"version":3,"names":["errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","cid","decode","toResolve","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-exporter@10.0.1/node_modules/ipfs-unixfs-exporter/src/index.js"],"sourcesContent":["import errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\nimport resolve from './resolvers/index.js'\nimport last from 'it-last'\n\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').ExporterOptions} ExporterOptions\n * @typedef {import('./types').UnixFSFile} UnixFSFile\n * @typedef {import('./types').UnixFSDirectory} UnixFSDirectory\n * @typedef {import('./types').ObjectNode} ObjectNode\n * @typedef {import('./types').RawNode} RawNode\n * @typedef {import('./types').IdentityNode} IdentityNode\n * @typedef {import('./types').UnixFSEntry} UnixFSEntry\n */\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) || [])\n    .filter(Boolean)\n}\n\n/**\n * @param {string|Uint8Array|CID} path\n */\nconst cidAndRest = (path) => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function * walkPath (path, blockstore, options = {}) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry) {\n      yield result.entry\n    }\n\n    if (!result.next) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function exporter (path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n  }\n\n  return result\n}\n\n/**\n * @param {string | CID} path\n * @param {Blockstore} blockstore\n * @param {ExporterOptions} [options]\n */\nexport async function * recursive (path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options)\n\n  if (!node) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  /**\n   * @param {UnixFSDirectory} node\n   * @param {ExporterOptions} options\n   * @returns {AsyncGenerator<UnixFSEntry, void, any>}\n   */\n  async function * recurse (node, options) {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}