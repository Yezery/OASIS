{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport cache from 'hashlru';\nimport varint from 'varint';\nimport { Key } from 'interface-datastore/key';\nimport Queue from 'p-queue';\nimport { PROVIDERS_CLEANUP_INTERVAL, PROVIDERS_VALIDITY, PROVIDERS_LRU_CACHE_SIZE, PROVIDER_KEY_PREFIX } from './constants.js';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromString } from '@libp2p/peer-id';\nconst log = logger('libp2p:kad-dht:providers');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nexport class Providers {\n  constructor(components, init = {}) {\n    const {\n      cacheSize,\n      cleanupInterval,\n      provideValidity\n    } = init;\n    this.components = components;\n    this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;\n    this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;\n    this.cache = cache(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n    this.started = false;\n  }\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * Start the provider cleanup service\n   */\n  async start() {\n    if (this.started) {\n      return;\n    }\n    this.started = true;\n    this.cleaner = setInterval(() => {\n      this._cleanup().catch(err => {\n        log.error(err);\n      });\n    }, this.cleanupInterval);\n  }\n  /**\n   * Release any resources.\n   */\n  async stop() {\n    this.started = false;\n    if (this.cleaner != null) {\n      clearInterval(this.cleaner);\n      this.cleaner = undefined;\n    }\n  }\n  /**\n   * Check all providers if they are still valid, and if not delete them\n   */\n  async _cleanup() {\n    await this.syncQueue.add(async () => {\n      const start = Date.now();\n      let count = 0;\n      let deleteCount = 0;\n      const deleted = new Map();\n      const batch = this.components.datastore.batch();\n      // Get all provider entries from the datastore\n      const query = this.components.datastore.query({\n        prefix: PROVIDER_KEY_PREFIX\n      });\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const {\n            cid,\n            peerId\n          } = parseProviderKey(entry.key);\n          const time = readTime(entry.value).getTime();\n          const now = Date.now();\n          const delta = now - time;\n          const expired = delta > this.provideValidity;\n          log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n          if (expired) {\n            deleteCount++;\n            batch.delete(entry.key);\n            const peers = deleted.get(cid) ?? new Set();\n            peers.add(peerId);\n            deleted.set(cid, peers);\n          }\n          count++;\n        } catch (err) {\n          log.error(err.message);\n        }\n      }\n      // Commit the deletes to the datastore\n      if (deleted.size > 0) {\n        log('deleting %d / %d entries', deleteCount, count);\n        await batch.commit();\n      } else {\n        log('nothing to delete');\n      }\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid);\n        const provs = this.cache.get(key);\n        if (provs != null) {\n          for (const peerId of peers) {\n            provs.delete(peerId);\n          }\n          if (provs.size === 0) {\n            this.cache.remove(key);\n          } else {\n            this.cache.set(key, provs);\n          }\n        }\n      }\n      log('Cleanup successful (%dms)', Date.now() - start);\n    });\n  }\n  /**\n   * Get the currently known provider peer ids for a given CID\n   */\n  async _getProvidersMap(cid) {\n    const cacheKey = makeProviderKey(cid);\n    let provs = this.cache.get(cacheKey);\n    if (provs == null) {\n      provs = await loadProviders(this.components.datastore, cid);\n      this.cache.set(cacheKey, provs);\n    }\n    return provs;\n  }\n  /**\n   * Add a new provider for the given CID\n   */\n  async addProvider(cid, provider) {\n    await this.syncQueue.add(async () => {\n      log('%p provides %s', provider, cid);\n      const provs = await this._getProvidersMap(cid);\n      log('loaded %s provs', provs.size);\n      const now = new Date();\n      provs.set(provider.toString(), now);\n      const dsKey = makeProviderKey(cid);\n      this.cache.set(dsKey, provs);\n      await writeProviderEntry(this.components.datastore, cid, provider, now);\n    });\n  }\n  /**\n   * Get a list of providers for the given CID\n   */\n  async getProviders(cid) {\n    return await this.syncQueue.add(async () => {\n      log('get providers for %s', cid);\n      const provs = await this._getProvidersMap(cid);\n      return [...provs.keys()].map(peerIdStr => {\n        return peerIdFromString(peerIdStr);\n      });\n    }, {\n      // no timeout is specified for this queue so it will not\n      // throw, but this is required to get the right return\n      // type since p-queue@7.3.4\n      throwOnTimeout: true\n    });\n  }\n}\n/**\n * Encode the given key its matching datastore key\n */\nfunction makeProviderKey(cid) {\n  const cidStr = typeof cid === 'string' ? cid : uint8ArrayToString(cid.multihash.bytes, 'base32');\n  return `${PROVIDER_KEY_PREFIX}/${cidStr}`;\n}\n/**\n * Write a provider into the given store\n */\nasync function writeProviderEntry(store, cid, peer, time) {\n  const dsKey = [makeProviderKey(cid), '/', peer.toString()].join('');\n  const key = new Key(dsKey);\n  const buffer = Uint8Array.from(varint.encode(time.getTime()));\n  await store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n */\nfunction parseProviderKey(key) {\n  const parts = key.toString().split('/');\n  if (parts.length !== 5) {\n    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);\n  }\n  return {\n    cid: parts[3],\n    peerId: parts[4]\n  };\n}\n/**\n * Load providers for the given CID from the store\n */\nasync function loadProviders(store, cid) {\n  const providers = new Map();\n  const query = store.query({\n    prefix: makeProviderKey(cid)\n  });\n  for await (const entry of query) {\n    const {\n      peerId\n    } = parseProviderKey(entry.key);\n    providers.set(peerId, readTime(entry.value));\n  }\n  return providers;\n}\nfunction readTime(buf) {\n  return new Date(varint.decode(buf));\n}","map":{"version":3,"names":["cache","varint","Key","Queue","PROVIDERS_CLEANUP_INTERVAL","PROVIDERS_VALIDITY","PROVIDERS_LRU_CACHE_SIZE","PROVIDER_KEY_PREFIX","logger","toString","uint8ArrayToString","peerIdFromString","log","Providers","constructor","components","init","cacheSize","cleanupInterval","provideValidity","syncQueue","concurrency","started","isStarted","start","cleaner","setInterval","_cleanup","catch","err","error","stop","clearInterval","undefined","add","Date","now","count","deleteCount","deleted","Map","batch","datastore","query","prefix","entry","cid","peerId","parseProviderKey","key","time","readTime","value","getTime","delta","expired","delete","peers","get","Set","set","message","size","commit","makeProviderKey","provs","remove","_getProvidersMap","cacheKey","loadProviders","addProvider","provider","dsKey","writeProviderEntry","getProviders","keys","map","peerIdStr","throwOnTimeout","cidStr","multihash","bytes","store","peer","join","buffer","Uint8Array","from","encode","put","parts","split","length","Error","providers","buf","decode"],"sources":["../../src/providers.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}