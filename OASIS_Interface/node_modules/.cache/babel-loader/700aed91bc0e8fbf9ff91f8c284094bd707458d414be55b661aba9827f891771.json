{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes(obj) {\n    /** @type {Reference|undefined} */\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent); // eslint-disable-line\n    return false;\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.array, obj.length), entries];\n  },\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object(obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object';\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.map, length), entries];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter(e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","makeCborEncoders","encoders","uint","major","negint","bytes","string","array","map","tag","float","cborEncoders","buf","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","reset","toBytes","encode","assign"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/encode.js"],"sourcesContent":["import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}