{"ast":null,"code":"import { RejectReason } from './types.js';\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {\n    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;\n    this.msgIdToStrFn = msgIdToStrFn;\n    this.metrics = metrics;\n    /**\n     * Promises to deliver a message\n     * Map per message id, per peer, promise expiration time\n     */\n    this.promises = new Map();\n    /**\n     * First request time by msgId. Used for metrics to track expire times.\n     * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n     */\n    this.requestMsByMsg = new Map();\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;\n  }\n  get size() {\n    return this.promises.size;\n  }\n  get requestMsByMsgSize() {\n    return this.requestMsByMsg.size;\n  }\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise(from, msgIds) {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length);\n    const msgId = msgIds[ix];\n    const msgIdStr = this.msgIdToStrFn(msgId);\n    let expireByPeer = this.promises.get(msgIdStr);\n    if (!expireByPeer) {\n      expireByPeer = new Map();\n      this.promises.set(msgIdStr, expireByPeer);\n    }\n    const now = Date.now();\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs);\n      if (this.metrics) {\n        this.metrics.iwantPromiseStarted.inc(1);\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises() {\n    const now = Date.now();\n    const result = new Map();\n    let brokenPromises = 0;\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1);\n          // delete from tracked promises\n          expireByPeer.delete(p);\n          // for metrics\n          brokenPromises++;\n        }\n      });\n      // clean up empty promises for a msgId\n      if (!expireByPeer.size) {\n        this.promises.delete(msgId);\n      }\n    });\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises);\n    return result;\n  }\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage(msgIdStr, isDuplicate = false) {\n    this.trackMessage(msgIdStr);\n    const expireByPeer = this.promises.get(msgIdStr);\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer) {\n      this.promises.delete(msgIdStr);\n      if (this.metrics) {\n        this.metrics.iwantPromiseResolved.inc(1);\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);\n      }\n    }\n  }\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage(msgIdStr, reason) {\n    this.trackMessage(msgIdStr);\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return;\n    }\n    this.promises.delete(msgIdStr);\n  }\n  clear() {\n    this.promises.clear();\n  }\n  prune() {\n    const maxMs = Date.now() - this.requestMsByMsgExpire;\n    let count = 0;\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k);\n        count++;\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break;\n      }\n    }\n    this.metrics?.iwantMessagePruned.inc(count);\n  }\n  trackMessage(msgIdStr) {\n    if (this.metrics) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr);\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000);\n        this.requestMsByMsg.delete(msgIdStr);\n      }\n    }\n  }\n}","map":{"version":3,"names":["RejectReason","IWantTracer","constructor","gossipsubIWantFollowupMs","msgIdToStrFn","metrics","promises","Map","requestMsByMsg","requestMsByMsgExpire","size","requestMsByMsgSize","addPromise","from","msgIds","ix","Math","floor","random","length","msgId","msgIdStr","expireByPeer","get","set","now","Date","has","iwantPromiseStarted","inc","getBrokenPromises","result","brokenPromises","forEach","expire","p","delete","iwantPromiseBroken","deliverMessage","isDuplicate","trackMessage","iwantPromiseResolved","iwantPromiseResolvedFromDuplicate","iwantPromiseResolvedPeers","rejectMessage","reason","Error","clear","prune","maxMs","count","k","v","entries","iwantMessagePruned","requestMs","undefined","iwantPromiseDeliveryTime","observe"],"sources":["../../src/tracer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}