{"ast":null,"code":"/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */0;\n};","map":{"version":3,"names":["Token","Type","uint","decodeErrPrefix","decodeNegint8","data","pos","_minor","options","negint","readUint8","decodeNegint16","readUint16","decodeNegint32","readUint32","neg1b","BigInt","pos1b","decodeNegint64","int","readUint64","value","Number","MIN_SAFE_INTEGER","allowBigInt","Error","encodeNegint","buf","token","unsigned","encodeUintValue","type","majorEncoded","encodedSize","uintBoundaries","compareTokens","tok1","tok2"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/1negint.js"],"sourcesContent":["/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}