{"ast":null,"code":"import \"core-js/modules/web.immediate.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport drain from 'it-drain';\nimport { pushable } from 'it-pushable';\nimport { Key } from 'interface-datastore/key';\nimport { CID } from 'multiformats/cid';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { base32, base32pad } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport errcode from 'err-code';\nimport { BaseBlockstore } from 'blockstore-core/base';\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nfunction cidToKey(cid) {\n  const c = CID.asCID(cid);\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\nfunction keyToCid(key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())));\n}\n\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\nfunction convertPrefix(prefix) {\n  const firstChar = prefix.substring(0, 1);\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1));\n  }\n\n  /** @type {(input: string) => Uint8Array } */\n  let decoder;\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = input => base32.decode(input.toLowerCase()).subarray(2);\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = input => base32pad.decode(input.toLowerCase()).subarray(2);\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = input => base58btc.decode(input).subarray(2);\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = input => base58btc.decode('z' + input);\n  } else {\n    decoder = input => base32.decode('b' + input.toLowerCase()).subarray(2);\n  }\n  let bytes;\n\n  // find the longest prefix that we can safely decode\n  for (let i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i));\n    } catch ( /** @type {any} */err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err;\n      }\n    }\n  }\n  let str = '/C';\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = `/${base32.encode(bytes).slice(1, -1).toUpperCase() || 'C'}`;\n  }\n  return str;\n}\n\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\nfunction convertQuery(query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(filter => pair => {\n      return filter({\n        key: keyToCid(pair.key),\n        value: pair.value\n      });\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order({\n        key: keyToCid(a.key),\n        value: a.value\n      }, {\n        key: keyToCid(b.key),\n        value: b.value\n      });\n    }) : undefined\n  };\n}\n\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\nfunction convertKeyQuery(query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(filter => key => {\n      return filter(keyToCid(key));\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order(keyToCid(a), keyToCid(b));\n    }) : undefined\n  };\n}\n\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\nexport class BlockstoreDatastoreAdapter extends BaseBlockstore {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor(datastore) {\n    super();\n    this.child = datastore;\n  }\n  open() {\n    return this.child.open();\n  }\n  close() {\n    return this.child.close();\n  }\n\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n  async *query(query, options) {\n    for await (const {\n      key,\n      value\n    } of this.child.query(convertQuery(query), options)) {\n      yield {\n        key: keyToCid(key),\n        value\n      };\n    }\n  }\n\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n  async *queryKeys(query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key);\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n  async get(cid, options) {\n    return this.child.get(cidToKey(cid), options);\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  async *getMany(cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put(cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options);\n  }\n\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n  async *putMany(blocks, options) {\n    // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable({\n      objectMode: true\n    });\n\n    // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;\n    runner(async () => {\n      try {\n        const store = this.child;\n        await drain(this.child.putMany(async function* () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key);\n            const exists = await store.has(key, options);\n            if (!exists) {\n              yield {\n                key,\n                value: block.value\n              };\n            }\n\n            // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n            output.push(block);\n          }\n        }()));\n        output.end();\n      } catch ( /** @type {any} */err) {\n        output.end(err);\n      }\n    });\n    yield* output;\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  has(cid, options) {\n    return this.child.has(cidToKey(cid), options);\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  delete(cid, options) {\n    return this.child.delete(cidToKey(cid), options);\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  deleteMany(cids, options) {\n    const out = pushable({\n      objectMode: true\n    });\n    drain(this.child.deleteMany(async function* () {\n      for await (const cid of cids) {\n        yield cidToKey(cid);\n        out.push(cid);\n      }\n      out.end();\n    }(), options)).catch(err => {\n      out.end(err);\n    });\n    return out;\n  }\n}","map":{"version":3,"names":["drain","pushable","Key","CID","raw","Digest","base32","base32pad","base58btc","errcode","BaseBlockstore","cidToKey","cid","c","asCID","Error","encode","multihash","bytes","slice","toUpperCase","keyToCid","key","createV1","code","decode","toString","toLowerCase","convertPrefix","prefix","firstChar","substring","decoder","input","subarray","i","length","err","message","str","convertQuery","query","undefined","filters","map","filter","pair","value","orders","order","a","b","convertKeyQuery","BlockstoreDatastoreAdapter","constructor","datastore","child","open","close","options","queryKeys","get","getMany","cids","put","putMany","blocks","output","objectMode","runner","globalThis","process","nextTick","setImmediate","setTimeout","store","block","exists","has","push","end","delete","deleteMany","out","catch"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/blockstore-datastore-adapter@5.0.0/node_modules/blockstore-datastore-adapter/src/index.js"],"sourcesContent":["import drain from 'it-drain'\nimport { pushable } from 'it-pushable'\nimport { Key } from 'interface-datastore/key'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { base32, base32pad } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport errcode from 'err-code'\nimport { BaseBlockstore } from 'blockstore-core/base'\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nfunction cidToKey (cid) {\n  const c = CID.asCID(cid)\n\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false)\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\nfunction keyToCid (key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())))\n}\n\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\nfunction convertPrefix (prefix) {\n  const firstChar = prefix.substring(0, 1)\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1))\n  }\n\n  /** @type {(input: string) => Uint8Array } */\n  let decoder\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = (input) => base58btc.decode(input).subarray(2)\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = (input) => base58btc.decode('z' + input)\n  } else {\n    decoder = (input) => base32.decode('b' + input.toLowerCase()).subarray(2)\n  }\n\n  let bytes\n\n  // find the longest prefix that we can safely decode\n  for (let i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i))\n    } catch (/** @type {any} */ err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err\n      }\n    }\n  }\n\n  let str = '/C'\n\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = `/${base32.encode(bytes).slice(1, -1).toUpperCase() || 'C'}`\n  }\n\n  return str\n}\n\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\nfunction convertQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (pair) => {\n          return filter({ key: keyToCid(pair.key), value: pair.value })\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order({ key: keyToCid(a.key), value: a.value }, { key: keyToCid(b.key), value: b.value })\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\nfunction convertKeyQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (key) => {\n          return filter(keyToCid(key))\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order(keyToCid(a), keyToCid(b))\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\nexport class BlockstoreDatastoreAdapter extends BaseBlockstore {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor (datastore) {\n    super()\n\n    this.child = datastore\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n  async * query (query, options) {\n    for await (const { key, value } of this.child.query(convertQuery(query), options)) {\n      yield { key: keyToCid(key), value }\n    }\n  }\n\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n  async * queryKeys (query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n  async get (cid, options) {\n    return this.child.get(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  async * getMany (cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options)\n  }\n\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n  async * putMany (blocks, options) { // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable({\n      objectMode: true\n    })\n\n    // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : (globalThis.setImmediate || globalThis.setTimeout)\n\n    runner(async () => {\n      try {\n        const store = this.child\n\n        await drain(this.child.putMany(async function * () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key)\n            const exists = await store.has(key, options)\n\n            if (!exists) {\n              yield { key, value: block.value }\n            }\n\n            // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n            output.push(block)\n          }\n        }()))\n\n        output.end()\n      } catch (/** @type {any} */ err) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  has (cid, options) {\n    return this.child.has(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  delete (cid, options) {\n    return this.child.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  deleteMany (cids, options) {\n    const out = pushable({\n      objectMode: true\n    })\n\n    drain(this.child.deleteMany((async function * () {\n      for await (const cid of cids) {\n        yield cidToKey(cid)\n\n        out.push(cid)\n      }\n\n      out.end()\n    }()), options)).catch(err => {\n      out.end(err)\n    })\n\n    return out\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}