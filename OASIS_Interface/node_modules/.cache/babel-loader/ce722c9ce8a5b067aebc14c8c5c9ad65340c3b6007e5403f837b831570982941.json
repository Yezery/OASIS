{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { CID } from 'multiformats/cid';\nimport { ipfs } from './pin.js';\n// @ts-ignore\nimport fnv1a from 'fnv1a';\nimport varint from 'varint';\nimport * as dagPb from '@ipld/dag-pb';\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { sha256 } from 'multiformats/hashes/sha2';\nconst PinSet = ipfs.pin.Set;\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes ?? 0;\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(key.toString());\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash;\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash;\n    }\n    idx++;\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nexport async function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb.decode(buf);\n  yield* walkItems(blockstore, node);\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint.encode(pbHeader.length);\n    const headerBuf = uint8ArrayConcat([header, pbHeader]);\n    const fanoutLinks = [];\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      });\n    }\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      })\n      // sorting makes any ordering of `pins` produce the same DAGNode\n      .sort((a, b) => {\n        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT;\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild(child, binIdx) {\n      const buf = dagPb.encode(child);\n      const digest = await sha256.digest(buf);\n      const cid = CID.createV0(digest);\n      await blockstore.put(cid, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      };\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nexport async function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    };\n  }));\n  const buf = dagPb.encode(rootNode);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  };\n}","map":{"version":3,"names":["CID","ipfs","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","PinSet","pin","Set","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","buf","get","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","finish","headerBuf","fanoutLinks","i","push","Tsize","nodes","map","item","sort","a","b","rootLinks","bins","reduce","n","bin","child","storeChild","binIdx","digest","cid","createV0","put","size","acc","curr","storeSet","type","cids"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/migrations/migration-9/pin-set.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport { ipfs } from './pin.js'\n// @ts-ignore\nimport fnv1a from 'fnv1a'\nimport varint from 'varint'\nimport * as dagPb from '@ipld/dag-pb'\nimport { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } from './utils.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { compare as uint8ArrayCompare } from 'uint8arrays/compare'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nconst PinSet = ipfs.pin.Set\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes ?? 0\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nexport async function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nexport async function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}