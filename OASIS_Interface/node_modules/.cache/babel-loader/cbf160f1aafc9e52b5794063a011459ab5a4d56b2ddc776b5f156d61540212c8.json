{"ast":null,"code":"import errCode from 'err-code';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { IpnsEntry } from './pb/ipns.js';\nimport { parseRFC3339, extractPublicKey, ipnsEntryDataForV2Sig, unmarshal, peerIdFromRoutingKey, parseCborData } from './utils.js';\nimport * as ERRORS from './errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipns:validator');\n/**\n * Validates the given ipns entry against the given public key\n */\nexport const validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  let dataForSignature;\n  let signature;\n  // Check v2 signature if it's available, otherwise use the v1 signature\n  if (entry.signatureV2 != null && entry.data != null) {\n    signature = entry.signatureV2;\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n    validateCborDataMatchesPbData(entry);\n  } else {\n    throw errCode(new Error('missing data or signatureV2'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  // Validate Signature\n  let isValid;\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature);\n  } catch (err) {\n    isValid = false;\n  }\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  // Validate according to the validity type\n  if (validity != null && validityType === IpnsEntry.ValidityType.EOL) {\n    let validityDate;\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity));\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired');\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType != null) {\n    log.error('unrecognized validity type');\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n  log('ipns entry for %b is valid', value);\n};\nconst validateCborDataMatchesPbData = entry => {\n  if (entry.data == null) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n  const data = parseCborData(entry.data);\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\nexport const ipnsValidator = async (key, marshalledData) => {\n  const peerId = peerIdFromRoutingKey(key);\n  const receivedEntry = unmarshal(marshalledData);\n  // extract public key\n  const pubKey = await extractPublicKey(peerId, receivedEntry);\n  // Record validation\n  await validate(pubKey, receivedEntry);\n};","map":{"version":3,"names":["errCode","toString","uint8ArrayToString","equals","uint8ArrayEquals","IpnsEntry","parseRFC3339","extractPublicKey","ipnsEntryDataForV2Sig","unmarshal","peerIdFromRoutingKey","parseCborData","ERRORS","logger","log","validate","publicKey","entry","value","validityType","validity","dataForSignature","signature","signatureV2","data","validateCborDataMatchesPbData","Error","ERR_SIGNATURE_VERIFICATION","isValid","verify","err","error","ValidityType","EOL","validityDate","e","ERR_UNRECOGNIZED_FORMAT","getTime","Date","now","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","ERR_INVALID_RECORD_DATA","Value","Validity","Sequence","sequence","TTL","ttl","ipnsValidator","key","marshalledData","peerId","receivedEntry","pubKey"],"sources":["../../src/validator.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}