{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { CID } from 'multiformats/cid';\nimport { bytesReader, readHeader } from './decoder.js';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;","map":{"version":3,"names":["CID","bytesReader","readHeader","createEncoder","createHeader","create","iteratorChannel","CarWriter","constructor","roots","encoder","_encoder","_mutex","setRoots","_ended","put","block","bytes","Uint8Array","cid","TypeError","Error","asCID","then","writeBlock","close","toRoots","iterator","encodeWriter","writer","out","CarWriterOut","createAppender","Promise","resolve","updateRootsInBytes","reader","newHeader","Number","pos","length","set","_iterator","Symbol","asyncIterator","_iterating","iw","undefined","Array","isArray","_roots","root","_root","push","__browser"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/@ipld+car@5.2.3/node_modules/@ipld/car/src/writer-browser.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { bytesReader, readHeader } from './decoder.js'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}