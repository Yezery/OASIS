{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport first from 'it-first';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nimport { Identify } from './pb/message.js';\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record';\nimport { MULTICODEC_IDENTIFY, MULTICODEC_IDENTIFY_PUSH, IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, MULTICODEC_IDENTIFY_PROTOCOL_VERSION, MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION } from './consts.js';\nimport { codes } from '../errors.js';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:identify');\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;\nexport class IdentifyService {\n  constructor(components, init) {\n    this.components = components;\n    this.started = false;\n    this.init = init;\n    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;\n    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...init.host\n    };\n    // When a new connection happens, trigger identify\n    this.components.connectionManager.addEventListener('peer:connect', evt => {\n      const connection = evt.detail;\n      this.identify(connection).catch(log.error);\n    });\n    // When self multiaddrs change, trigger identify-push\n    this.components.peerStore.addEventListener('change:multiaddrs', evt => {\n      const {\n        peerId\n      } = evt.detail;\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err));\n      }\n    });\n    // When self protocols change, trigger identify-push\n    this.components.peerStore.addEventListener('change:protocols', evt => {\n      const {\n        peerId\n      } = evt.detail;\n      if (this.components.peerId.equals(peerId)) {\n        void this.pushToPeerStore().catch(err => log.error(err));\n      }\n    });\n  }\n  isStarted() {\n    return this.started;\n  }\n  async start() {\n    if (this.started) {\n      return;\n    }\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'AgentVersion', uint8ArrayFromString(this.host.agentVersion));\n    await this.components.peerStore.metadataBook.setValue(this.components.peerId, 'ProtocolVersion', uint8ArrayFromString(this.host.protocolVersion));\n    await this.components.registrar.handle(this.identifyProtocolStr, data => {\n      void this._handleIdentify(data).catch(err => {\n        log.error(err);\n      });\n    }, {\n      maxInboundStreams: this.init.maxInboundStreams,\n      maxOutboundStreams: this.init.maxOutboundStreams\n    });\n    await this.components.registrar.handle(this.identifyPushProtocolStr, data => {\n      void this._handlePush(data).catch(err => {\n        log.error(err);\n      });\n    }, {\n      maxInboundStreams: this.init.maxPushIncomingStreams,\n      maxOutboundStreams: this.init.maxPushOutgoingStreams\n    });\n    this.started = true;\n  }\n  async stop() {\n    await this.components.registrar.unhandle(this.identifyProtocolStr);\n    await this.components.registrar.unhandle(this.identifyPushProtocolStr);\n    this.started = false;\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n  async push(connections) {\n    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId);\n    const listenAddrs = this.components.addressManager.getAddresses().map(ma => ma.bytes);\n    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId);\n    const pushes = connections.map(async connection => {\n      let stream;\n      const timeoutController = new TimeoutController(this.init.timeout);\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n      try {\n        stream = await connection.newStream([this.identifyPushProtocolStr], {\n          signal: timeoutController.signal\n        });\n        // make stream abortable\n        const source = abortableDuplex(stream, timeoutController.signal);\n        await source.sink(pipe([Identify.encode({\n          listenAddrs,\n          signedPeerRecord,\n          protocols\n        })], lp.encode()));\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      } finally {\n        if (stream != null) {\n          stream.close();\n        }\n        timeoutController.clear();\n      }\n    });\n    await Promise.all(pushes);\n  }\n  /**\n   * Calls `push` on all peer connections\n   */\n  async pushToPeerStore() {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return;\n    }\n    const connections = [];\n    for (const conn of this.components.connectionManager.getConnections()) {\n      const peerId = conn.remotePeer;\n      const peer = await this.components.peerStore.get(peerId);\n      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n        continue;\n      }\n      connections.push(conn);\n    }\n    await this.push(connections);\n  }\n  async _identify(connection, options = {}) {\n    let timeoutController;\n    let signal = options.signal;\n    let stream;\n    // create a timeout if no abort signal passed\n    if (signal == null) {\n      timeoutController = new TimeoutController(this.init.timeout);\n      signal = timeoutController.signal;\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, timeoutController.signal);\n      } catch {}\n    }\n    try {\n      stream = await connection.newStream([this.identifyProtocolStr], {\n        signal\n      });\n      // make stream abortable\n      const source = abortableDuplex(stream, signal);\n      const data = await pipe([], source, lp.decode({\n        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }), async source => await first(source));\n      if (data == null) {\n        throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n      }\n      try {\n        return Identify.decode(data);\n      } catch (err) {\n        throw errCode(err, codes.ERR_INVALID_MESSAGE);\n      }\n    } finally {\n      if (timeoutController != null) {\n        timeoutController.clear();\n      }\n      if (stream != null) {\n        stream.close();\n      }\n    }\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   */\n  async identify(connection, options = {}) {\n    const message = await this._identify(connection, options);\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord,\n      agentVersion,\n      protocolVersion\n    } = message;\n    if (publicKey == null) {\n      throw errCode(new Error('public key was missing from identify message'), codes.ERR_MISSING_PUBLIC_KEY);\n    }\n    const id = await peerIdFromKeys(publicKey);\n    if (!connection.remotePeer.equals(id)) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    }\n    if (this.components.peerId.equals(id)) {\n      throw errCode(new Error('identified peer is our own peer id?'), codes.ERR_INVALID_PEER);\n    }\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n    if (signedPeerRecord != null) {\n      log('received signed peer record from %p', id);\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n        if (!envelope.peerId.equals(id)) {\n          throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n        }\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          await this.components.peerStore.protoBook.set(id, protocols);\n          if (agentVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n          }\n          if (protocolVersion != null) {\n            await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n          }\n          log('identify completed for peer %p and protocols %o', id, protocols);\n          return;\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      }\n    } else {\n      log('no signed peer record received from %p', id);\n    }\n    log('falling back to legacy addresses from %p', id);\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.peerStore.addressBook.set(id, listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    }\n    await this.components.peerStore.protoBook.set(id, protocols);\n    if (agentVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'AgentVersion', uint8ArrayFromString(agentVersion));\n    }\n    if (protocolVersion != null) {\n      await this.components.peerStore.metadataBook.setValue(id, 'ProtocolVersion', uint8ArrayFromString(protocolVersion));\n    }\n    log('identify completed for peer %p and protocols %o', id, protocols);\n    // TODO: Add and score our observed addr\n    log('received observed address of %s', cleanObservedAddr?.toString());\n    // this.components.addressManager.addObservedAddr(observedAddr)\n  }\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async _handleIdentify(data) {\n    const {\n      connection,\n      stream\n    } = data;\n    const timeoutController = new TimeoutController(this.init.timeout);\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n    try {\n      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0);\n      const peerData = await this.components.peerStore.get(this.components.peerId);\n      const multiaddrs = this.components.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code));\n      let signedPeerRecord = peerData.peerRecordEnvelope;\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.components.peerId,\n          multiaddrs\n        });\n        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);\n        await this.components.peerStore.addressBook.consumePeerRecord(envelope);\n        signedPeerRecord = envelope.marshal().subarray();\n      }\n      const message = Identify.encode({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr: connection.remoteAddr.bytes,\n        protocols: peerData.protocols\n      });\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal);\n      const msgWithLenPrefix = pipe([message], lp.encode());\n      await source.sink(msgWithLenPrefix);\n    } catch (err) {\n      log.error('could not respond to identify request', err);\n    } finally {\n      stream.close();\n      timeoutController.clear();\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async _handlePush(data) {\n    const {\n      connection,\n      stream\n    } = data;\n    const timeoutController = new TimeoutController(this.init.timeout);\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n    let message;\n    try {\n      // make stream abortable\n      const source = abortableDuplex(stream, timeoutController.signal);\n      const data = await pipe([], source, lp.decode({\n        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }), async source => await first(source));\n      if (data != null) {\n        message = Identify.decode(data);\n      }\n    } catch (err) {\n      return log.error('received invalid message', err);\n    } finally {\n      stream.close();\n      timeoutController.clear();\n    }\n    if (message == null) {\n      return log.error('received invalid message');\n    }\n    const id = connection.remotePeer;\n    if (this.components.peerId.equals(id)) {\n      log('received push from ourselves?');\n      return;\n    }\n    log('received push from %p', id);\n    if (message.signedPeerRecord != null) {\n      log('received signedPeerRecord in push');\n      try {\n        const envelope = await RecordEnvelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {\n          log('consumed signedPeerRecord sent in push');\n          await this.components.peerStore.protoBook.set(id, message.protocols);\n          return;\n        } else {\n          log('failed to consume signedPeerRecord sent in push');\n        }\n      } catch (err) {\n        log('received invalid envelope, discard it and fallback to listenAddrs is available', err);\n      }\n    } else {\n      log('did not receive signedPeerRecord in push');\n    }\n    // LEGACY: Update peers data in PeerStore\n    try {\n      await this.components.peerStore.addressBook.set(id, message.listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      log.error('received invalid addrs', err);\n    }\n    // Update the protocols\n    try {\n      await this.components.peerStore.protoBook.set(id, message.protocols);\n    } catch (err) {\n      log.error('received invalid protocols', err);\n    }\n    log('handled push from %p', id);\n  }\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   */\n  static getCleanMultiaddr(addr) {\n    if (addr != null && addr.length > 0) {\n      try {\n        return multiaddr(addr);\n      } catch {}\n    }\n  }\n}\n/**\n * The protocols the IdentifyService supports\n */\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nexport const Message = {\n  Identify\n};","map":{"version":3,"names":["logger","errCode","lp","pipe","first","fromString","uint8ArrayFromString","multiaddr","protocols","Identify","RecordEnvelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION","codes","peerIdFromKeys","TimeoutController","abortableDuplex","setMaxListeners","log","MAX_IDENTIFY_MESSAGE_SIZE","IdentifyService","constructor","components","init","started","identifyProtocolStr","protocolPrefix","identifyPushProtocolStr","host","protocolVersion","connectionManager","addEventListener","evt","connection","detail","identify","catch","error","peerStore","peerId","equals","pushToPeerStore","err","isStarted","start","metadataBook","setValue","agentVersion","registrar","handle","data","_handleIdentify","maxInboundStreams","maxOutboundStreams","_handlePush","maxPushIncomingStreams","maxPushOutgoingStreams","stop","unhandle","push","connections","signedPeerRecord","addressBook","getRawEnvelope","listenAddrs","addressManager","getAddresses","map","ma","bytes","protoBook","get","pushes","stream","timeoutController","timeout","Infinity","signal","newStream","source","sink","encode","close","clear","Promise","all","conn","getConnections","remotePeer","peer","includes","_identify","options","decode","maxDataLength","maxIdentifyMessageSize","Error","ERR_CONNECTION_ENDED","ERR_INVALID_MESSAGE","message","publicKey","observedAddr","ERR_MISSING_PUBLIC_KEY","id","ERR_INVALID_PEER","cleanObservedAddr","getCleanMultiaddr","envelope","openAndCertify","DOMAIN","consumePeerRecord","set","addr","toString","Uint8Array","peerData","multiaddrs","decapsulateCode","code","peerRecordEnvelope","length","peerRecord","seal","marshal","subarray","remoteAddr","msgWithLenPrefix","multicodecs","IDENTIFY","IDENTIFY_PUSH","Message"],"sources":["../../../src/identify/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}