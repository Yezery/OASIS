{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  AbstractIterator\n} = require('abstract-level');\nconst createKeyRange = require('./util/key-range');\nconst deserialize = require('./util/deserialize');\nconst kCache = Symbol('cache');\nconst kFinished = Symbol('finished');\nconst kOptions = Symbol('options');\nconst kCurrentOptions = Symbol('currentOptions');\nconst kPosition = Symbol('position');\nconst kLocation = Symbol('location');\nconst kFirst = Symbol('first');\nconst emptyOptions = {};\nclass Iterator extends AbstractIterator {\n  constructor(db, location, options) {\n    super(db, options);\n    this[kCache] = [];\n    this[kFinished] = this.limit === 0;\n    this[kOptions] = options;\n    this[kCurrentOptions] = {\n      ...options\n    };\n    this[kPosition] = undefined;\n    this[kLocation] = location;\n    this[kFirst] = true;\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _nextv(size, options, callback) {\n    this[kFirst] = false;\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, []);\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length);\n      return this.nextTick(callback, null, this[kCache].splice(0, size));\n    }\n\n    // Adjust range by what we already visited\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition];\n        this[kCurrentOptions].lte = undefined;\n      } else {\n        this[kCurrentOptions].gt = this[kPosition];\n        this[kCurrentOptions].gte = undefined;\n      }\n    }\n    let keyRange;\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions]);\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true;\n      return this.nextTick(callback, null, []);\n    }\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly');\n    const store = transaction.objectStore(this[kLocation]);\n    const entries = [];\n    if (!this[kOptions].reverse) {\n      let keys;\n      let values;\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return;\n        const length = Math.max(keys.length, values.length);\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true;\n        } else {\n          this[kPosition] = keys[length - 1];\n        }\n\n        // Resize\n        entries.length = length;\n\n        // Merge keys and values\n        for (let i = 0; i < length; i++) {\n          const key = keys[i];\n          const value = values[i];\n          entries[i] = [this[kOptions].keys && key !== undefined ? deserialize(key) : undefined, this[kOptions].values && value !== undefined ? deserialize(value) : undefined];\n        }\n        maybeCommit(transaction);\n      };\n\n      // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = ev => {\n          keys = ev.target.result;\n          complete();\n        };\n      } else {\n        keys = [];\n        this.nextTick(complete);\n      }\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = ev => {\n          values = ev.target.result;\n          complete();\n        };\n      } else {\n        values = [];\n        this.nextTick(complete);\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor';\n      store[method](keyRange, 'prev').onsuccess = ev => {\n        const cursor = ev.target.result;\n        if (cursor) {\n          const {\n            key,\n            value\n          } = cursor;\n          this[kPosition] = key;\n          entries.push([this[kOptions].keys && key !== undefined ? deserialize(key) : undefined, this[kOptions].values && value !== undefined ? deserialize(value) : undefined]);\n          if (entries.length < size) {\n            cursor.continue();\n          } else {\n            maybeCommit(transaction);\n          }\n        } else {\n          this[kFinished] = true;\n        }\n      };\n    }\n\n    // If an error occurs (on the request), the transaction will abort.\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'));\n      callback = null;\n    };\n    transaction.oncomplete = () => {\n      callback(null, entries);\n      callback = null;\n    };\n  }\n  _next(callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift();\n      this.nextTick(callback, null, key, value);\n    } else if (this[kFinished]) {\n      this.nextTick(callback);\n    } else {\n      let size = Math.min(100, this.limit - this.count);\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false;\n        size = 1;\n      }\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err);\n        this[kCache] = entries;\n        this._next(callback);\n      });\n    }\n  }\n  _all(options, callback) {\n    this[kFirst] = false;\n\n    // TODO: mixing next and all is not covered by test suite\n    const cache = this[kCache].splice(0, this[kCache].length);\n    const size = this.limit - this.count - cache.length;\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache);\n    }\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err);\n      if (cache.length > 0) entries = cache.concat(entries);\n      callback(null, entries);\n    });\n  }\n  _seek(target, options) {\n    this[kFirst] = true;\n    this[kCache] = [];\n    this[kFinished] = false;\n    this[kPosition] = undefined;\n\n    // TODO: not covered by test suite\n    this[kCurrentOptions] = {\n      ...this[kOptions]\n    };\n    let keyRange;\n    try {\n      keyRange = createKeyRange(this[kOptions]);\n    } catch (_) {\n      this[kFinished] = true;\n      return;\n    }\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true;\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target;\n    } else {\n      this[kCurrentOptions].gte = target;\n    }\n  }\n}\nexports.Iterator = Iterator;\nfunction maybeCommit(transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit();\n  }\n}","map":{"version":3,"names":["require","AbstractIterator","createKeyRange","deserialize","kCache","Symbol","kFinished","kOptions","kCurrentOptions","kPosition","kLocation","kFirst","emptyOptions","Iterator","constructor","db","location","options","limit","undefined","_nextv","size","callback","nextTick","length","Math","min","splice","reverse","lt","lte","gt","gte","keyRange","_","transaction","store","objectStore","entries","keys","values","complete","max","Infinity","i","key","value","maybeCommit","getAllKeys","onsuccess","ev","target","result","getAll","method","openKeyCursor","cursor","push","continue","onabort","error","Error","oncomplete","_next","shift","count","err","_all","cache","concat","_seek","includes","exports","commit"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/browser-level@1.0.1/node_modules/browser-level/iterator.js"],"sourcesContent":["'use strict'\n\nconst { AbstractIterator } = require('abstract-level')\nconst createKeyRange = require('./util/key-range')\nconst deserialize = require('./util/deserialize')\n\nconst kCache = Symbol('cache')\nconst kFinished = Symbol('finished')\nconst kOptions = Symbol('options')\nconst kCurrentOptions = Symbol('currentOptions')\nconst kPosition = Symbol('position')\nconst kLocation = Symbol('location')\nconst kFirst = Symbol('first')\nconst emptyOptions = {}\n\nclass Iterator extends AbstractIterator {\n  constructor (db, location, options) {\n    super(db, options)\n\n    this[kCache] = []\n    this[kFinished] = this.limit === 0\n    this[kOptions] = options\n    this[kCurrentOptions] = { ...options }\n    this[kPosition] = undefined\n    this[kLocation] = location\n    this[kFirst] = true\n  }\n\n  // Note: if called by _all() then size can be Infinity. This is an internal\n  // detail; by design AbstractIterator.nextv() does not support Infinity.\n  _nextv (size, options, callback) {\n    this[kFirst] = false\n\n    if (this[kFinished]) {\n      return this.nextTick(callback, null, [])\n    } else if (this[kCache].length > 0) {\n      // TODO: mixing next and nextv is not covered by test suite\n      size = Math.min(size, this[kCache].length)\n      return this.nextTick(callback, null, this[kCache].splice(0, size))\n    }\n\n    // Adjust range by what we already visited\n    if (this[kPosition] !== undefined) {\n      if (this[kOptions].reverse) {\n        this[kCurrentOptions].lt = this[kPosition]\n        this[kCurrentOptions].lte = undefined\n      } else {\n        this[kCurrentOptions].gt = this[kPosition]\n        this[kCurrentOptions].gte = undefined\n      }\n    }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kCurrentOptions])\n    } catch (_) {\n      // The lower key is greater than the upper key.\n      // IndexedDB throws an error, but we'll just return 0 results.\n      this[kFinished] = true\n      return this.nextTick(callback, null, [])\n    }\n\n    const transaction = this.db.db.transaction([this[kLocation]], 'readonly')\n    const store = transaction.objectStore(this[kLocation])\n    const entries = []\n\n    if (!this[kOptions].reverse) {\n      let keys\n      let values\n\n      const complete = () => {\n        // Wait for both requests to complete\n        if (keys === undefined || values === undefined) return\n\n        const length = Math.max(keys.length, values.length)\n\n        if (length === 0 || size === Infinity) {\n          this[kFinished] = true\n        } else {\n          this[kPosition] = keys[length - 1]\n        }\n\n        // Resize\n        entries.length = length\n\n        // Merge keys and values\n        for (let i = 0; i < length; i++) {\n          const key = keys[i]\n          const value = values[i]\n\n          entries[i] = [\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ]\n        }\n\n        maybeCommit(transaction)\n      }\n\n      // If keys were not requested and size is Infinity, we don't have to keep\n      // track of position and can thus skip getting keys.\n      if (this[kOptions].keys || size < Infinity) {\n        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          keys = ev.target.result\n          complete()\n        }\n      } else {\n        keys = []\n        this.nextTick(complete)\n      }\n\n      if (this[kOptions].values) {\n        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = (ev) => {\n          values = ev.target.result\n          complete()\n        }\n      } else {\n        values = []\n        this.nextTick(complete)\n      }\n    } else {\n      // Can't use getAll() in reverse, so use a slower cursor that yields one item at a time\n      // TODO: test if all target browsers support openKeyCursor\n      const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor'\n\n      store[method](keyRange, 'prev').onsuccess = (ev) => {\n        const cursor = ev.target.result\n\n        if (cursor) {\n          const { key, value } = cursor\n          this[kPosition] = key\n\n          entries.push([\n            this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,\n            this[kOptions].values && value !== undefined ? deserialize(value) : undefined\n          ])\n\n          if (entries.length < size) {\n            cursor.continue()\n          } else {\n            maybeCommit(transaction)\n          }\n        } else {\n          this[kFinished] = true\n        }\n      }\n    }\n\n    // If an error occurs (on the request), the transaction will abort.\n    transaction.onabort = () => {\n      callback(transaction.error || new Error('aborted by user'))\n      callback = null\n    }\n\n    transaction.oncomplete = () => {\n      callback(null, entries)\n      callback = null\n    }\n  }\n\n  _next (callback) {\n    if (this[kCache].length > 0) {\n      const [key, value] = this[kCache].shift()\n      this.nextTick(callback, null, key, value)\n    } else if (this[kFinished]) {\n      this.nextTick(callback)\n    } else {\n      let size = Math.min(100, this.limit - this.count)\n\n      if (this[kFirst]) {\n        // It's common to only want one entry initially or after a seek()\n        this[kFirst] = false\n        size = 1\n      }\n\n      this._nextv(size, emptyOptions, (err, entries) => {\n        if (err) return callback(err)\n        this[kCache] = entries\n        this._next(callback)\n      })\n    }\n  }\n\n  _all (options, callback) {\n    this[kFirst] = false\n\n    // TODO: mixing next and all is not covered by test suite\n    const cache = this[kCache].splice(0, this[kCache].length)\n    const size = this.limit - this.count - cache.length\n\n    if (size <= 0) {\n      return this.nextTick(callback, null, cache)\n    }\n\n    this._nextv(size, emptyOptions, (err, entries) => {\n      if (err) return callback(err)\n      if (cache.length > 0) entries = cache.concat(entries)\n      callback(null, entries)\n    })\n  }\n\n  _seek (target, options) {\n    this[kFirst] = true\n    this[kCache] = []\n    this[kFinished] = false\n    this[kPosition] = undefined\n\n    // TODO: not covered by test suite\n    this[kCurrentOptions] = { ...this[kOptions] }\n\n    let keyRange\n\n    try {\n      keyRange = createKeyRange(this[kOptions])\n    } catch (_) {\n      this[kFinished] = true\n      return\n    }\n\n    if (keyRange !== null && !keyRange.includes(target)) {\n      this[kFinished] = true\n    } else if (this[kOptions].reverse) {\n      this[kCurrentOptions].lte = target\n    } else {\n      this[kCurrentOptions].gte = target\n    }\n  }\n}\n\nexports.Iterator = Iterator\n\nfunction maybeCommit (transaction) {\n  // Commit (meaning close) now instead of waiting for auto-commit\n  if (typeof transaction.commit === 'function') {\n    transaction.commit()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}