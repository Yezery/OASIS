{"ast":null,"code":"import { createReadStream, readFileSync } from 'node:fs';\nimport { isStream } from 'is-stream';\nimport getStream from 'get-stream';\nimport mergeStream from 'merge-stream';\nconst validateInputOptions = input => {\n  if (input !== undefined) {\n    throw new TypeError('The `input` and `inputFile` options cannot be both set.');\n  }\n};\nconst getInputSync = ({\n  input,\n  inputFile\n}) => {\n  if (typeof inputFile !== 'string') {\n    return input;\n  }\n  validateInputOptions(input);\n  return readFileSync(inputFile);\n};\n\n// `input` and `inputFile` option in sync mode\nexport const handleInputSync = options => {\n  const input = getInputSync(options);\n  if (isStream(input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n  return input;\n};\nconst getInput = ({\n  input,\n  inputFile\n}) => {\n  if (typeof inputFile !== 'string') {\n    return input;\n  }\n  validateInputOptions(input);\n  return createReadStream(inputFile);\n};\n\n// `input` and `inputFile` option in async mode\nexport const handleInput = (spawned, options) => {\n  const input = getInput(options);\n  if (input === undefined) {\n    return;\n  }\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n};\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = (spawned, {\n  all\n}) => {\n  if (!all || !spawned.stdout && !spawned.stderr) {\n    return;\n  }\n  const mixed = mergeStream();\n  if (spawned.stdout) {\n    mixed.add(spawned.stdout);\n  }\n  if (spawned.stderr) {\n    mixed.add(spawned.stderr);\n  }\n  return mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n  // When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\n  if (!stream || streamPromise === undefined) {\n    return;\n  }\n  stream.destroy();\n  try {\n    return await streamPromise;\n  } catch (error) {\n    return error.bufferedData;\n  }\n};\nconst getStreamPromise = (stream, {\n  encoding,\n  buffer,\n  maxBuffer\n}) => {\n  if (!stream || !buffer) {\n    return;\n  }\n  if (encoding) {\n    return getStream(stream, {\n      encoding,\n      maxBuffer\n    });\n  }\n  return getStream.buffer(stream, {\n    maxBuffer\n  });\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nexport const getSpawnedResult = async ({\n  stdout,\n  stderr,\n  all\n}, {\n  encoding,\n  buffer,\n  maxBuffer\n}, processDone) => {\n  const stdoutPromise = getStreamPromise(stdout, {\n    encoding,\n    buffer,\n    maxBuffer\n  });\n  const stderrPromise = getStreamPromise(stderr, {\n    encoding,\n    buffer,\n    maxBuffer\n  });\n  const allPromise = getStreamPromise(all, {\n    encoding,\n    buffer,\n    maxBuffer: maxBuffer * 2\n  });\n  try {\n    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n  } catch (error) {\n    return Promise.all([{\n      error,\n      signal: error.signal,\n      timedOut: error.timedOut\n    }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]);\n  }\n};","map":{"version":3,"names":["createReadStream","readFileSync","isStream","getStream","mergeStream","validateInputOptions","input","undefined","TypeError","getInputSync","inputFile","handleInputSync","options","getInput","handleInput","spawned","pipe","stdin","end","makeAllStream","all","stdout","stderr","mixed","add","getBufferedData","stream","streamPromise","destroy","error","bufferedData","getStreamPromise","encoding","buffer","maxBuffer","getSpawnedResult","processDone","stdoutPromise","stderrPromise","allPromise","Promise","signal","timedOut"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/execa@7.2.0/node_modules/execa/lib/stream.js"],"sourcesContent":["import {createReadStream, readFileSync} from 'node:fs';\nimport {isStream} from 'is-stream';\nimport getStream from 'get-stream';\nimport mergeStream from 'merge-stream';\n\nconst validateInputOptions = input => {\n\tif (input !== undefined) {\n\t\tthrow new TypeError('The `input` and `inputFile` options cannot be both set.');\n\t}\n};\n\nconst getInputSync = ({input, inputFile}) => {\n\tif (typeof inputFile !== 'string') {\n\t\treturn input;\n\t}\n\n\tvalidateInputOptions(input);\n\treturn readFileSync(inputFile);\n};\n\n// `input` and `inputFile` option in sync mode\nexport const handleInputSync = options => {\n\tconst input = getInputSync(options);\n\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n\n\treturn input;\n};\n\nconst getInput = ({input, inputFile}) => {\n\tif (typeof inputFile !== 'string') {\n\t\treturn input;\n\t}\n\n\tvalidateInputOptions(input);\n\treturn createReadStream(inputFile);\n};\n\n// `input` and `inputFile` option in async mode\nexport const handleInput = (spawned, options) => {\n\tconst input = getInput(options);\n\n\tif (input === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\t// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\n\tif (!stream || streamPromise === undefined) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nexport const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise),\n\t\t]);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}