{"ast":null,"code":"/* eslint max-depth: [\"error\", 6] */\nimport errCode from 'err-code';\nimport * as varint from 'uint8-varint';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { isAsyncIterable } from './utils.js';\n// Maximum length of the length section of the message\nexport const MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nexport const MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar ReadMode;\n(function (ReadMode) {\n  ReadMode[ReadMode[\"LENGTH\"] = 0] = \"LENGTH\";\n  ReadMode[ReadMode[\"DATA\"] = 1] = \"DATA\";\n})(ReadMode || (ReadMode = {}));\nconst defaultDecoder = buf => {\n  const length = varint.decode(buf);\n  defaultDecoder.bytes = varint.encodingLength(length);\n  return length;\n};\ndefaultDecoder.bytes = 0;\nexport function decode(source, options) {\n  const buffer = new Uint8ArrayList();\n  let mode = ReadMode.LENGTH;\n  let dataLength = -1;\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;\n  function* maybeYield() {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer);\n          if (dataLength < 0) {\n            throw errCode(new Error('invalid message length'), 'ERR_INVALID_MSG_LENGTH');\n          }\n          if (dataLength > maxDataLength) {\n            throw errCode(new Error('message length too long'), 'ERR_MSG_DATA_TOO_LONG');\n          }\n          const dataLengthLength = lengthDecoder.bytes;\n          buffer.consume(dataLengthLength);\n          if (options?.onLength != null) {\n            options.onLength(dataLength);\n          }\n          mode = ReadMode.DATA;\n        } catch (err) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw errCode(new Error('message length length too long'), 'ERR_MSG_LENGTH_TOO_LONG');\n            }\n            break;\n          }\n          throw err;\n        }\n      }\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break;\n        }\n        const data = buffer.sublist(0, dataLength);\n        buffer.consume(dataLength);\n        if (options?.onData != null) {\n          options.onData(data);\n        }\n        yield data;\n        mode = ReadMode.LENGTH;\n      }\n    }\n  }\n  if (isAsyncIterable(source)) {\n    return async function* () {\n      for await (const buf of source) {\n        buffer.append(buf);\n        yield* maybeYield();\n      }\n      if (buffer.byteLength > 0) {\n        throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n      }\n    }();\n  }\n  return function* () {\n    for (const buf of source) {\n      buffer.append(buf);\n      yield* maybeYield();\n    }\n    if (buffer.byteLength > 0) {\n      throw errCode(new Error('unexpected end of input'), 'ERR_UNEXPECTED_EOF');\n    }\n  }();\n}\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n  const varByteSource = async function* () {\n    while (true) {\n      try {\n        const {\n          done,\n          value\n        } = await reader.next(byteLength);\n        if (done === true) {\n          return;\n        }\n        if (value != null) {\n          yield value;\n        }\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  }();\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = l => {\n    byteLength = l;\n  };\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  });\n};","map":{"version":3,"names":["errCode","varint","Uint8ArrayList","isAsyncIterable","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","ReadMode","defaultDecoder","buf","length","decode","bytes","encodingLength","source","options","buffer","mode","LENGTH","dataLength","lengthDecoder","maxLengthLength","maxDataLength","maybeYield","byteLength","Error","dataLengthLength","consume","onLength","DATA","err","RangeError","data","sublist","onData","append","fromReader","reader","varByteSource","done","value","next","code","l"],"sources":["../../src/decode.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}