{"ast":null,"code":"import errCode from 'err-code';\nimport parallel from 'it-parallel';\nimport map from 'it-map';\nimport filter from 'it-filter';\nimport { pipe } from 'it-pipe';\nimport { cleanCid } from './utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst BLOCK_RM_CONCURRENCY = 8;\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createRm({\n  repo\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/block').API<{}>[\"rm\"]}\n   */\n  async function* rm(cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await repo.gcLock.writeLock();\n    try {\n      yield* pipe(cids, source => map(source, cid => {\n        return async () => {\n          cid = cleanCid(cid);\n\n          /** @type {import('ipfs-core-types/src/block').RmResult} */\n          const result = {\n            cid\n          };\n          try {\n            const has = await repo.blocks.has(cid);\n            if (!has) {\n              throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n            }\n            await repo.blocks.delete(cid);\n          } catch ( /** @type {any} */err) {\n            if (!options.force) {\n              err.message = `cannot remove ${cid}: ${err.message}`;\n              result.error = err;\n            }\n          }\n          return result;\n        };\n      }), source => parallel(source, {\n        concurrency: BLOCK_RM_CONCURRENCY\n      }), source => filter(source, () => !options.quiet));\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption(rm);\n}","map":{"version":3,"names":["errCode","parallel","map","filter","pipe","cleanCid","withTimeoutOption","BLOCK_RM_CONCURRENCY","createRm","repo","rm","cids","options","Array","isArray","release","gcLock","writeLock","source","cid","result","has","blocks","Error","delete","err","force","message","error","concurrency","quiet"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/block/rm.js"],"sourcesContent":["import errCode from 'err-code'\nimport parallel from 'it-parallel'\nimport map from 'it-map'\nimport filter from 'it-filter'\nimport { pipe } from 'it-pipe'\nimport { cleanCid } from './utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst BLOCK_RM_CONCURRENCY = 8\n\n/**\n * @param {object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nexport function createRm ({ repo }) {\n  /**\n   * @type {import('ipfs-core-types/src/block').API<{}>[\"rm\"]}\n   */\n  async function * rm (cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await repo.gcLock.writeLock()\n\n    try {\n      yield * pipe(\n        cids,\n        source => map(source, cid => {\n          return async () => {\n            cid = cleanCid(cid)\n\n            /** @type {import('ipfs-core-types/src/block').RmResult} */\n            const result = { cid }\n\n            try {\n              const has = await repo.blocks.has(cid)\n\n              if (!has) {\n                throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n              }\n\n              await repo.blocks.delete(cid)\n            } catch (/** @type {any} */ err) {\n              if (!options.force) {\n                err.message = `cannot remove ${cid}: ${err.message}`\n                result.error = err\n              }\n            }\n\n            return result\n          }\n        }),\n        source => parallel(source, { concurrency: BLOCK_RM_CONCURRENCY }),\n        source => filter(source, () => !options.quiet)\n      )\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(rm)\n}\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,UAAU;AAC9B,OAAOC,QAAQ,MAAM,aAAa;AAClC,OAAOC,GAAG,MAAM,QAAQ;AACxB,OAAOC,MAAM,MAAM,WAAW;AAC9B,SAASC,IAAI,QAAQ,SAAS;AAC9B,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,iBAAiB,QAAQ,qCAAqC;AAEvE,MAAMC,oBAAoB,GAAG,CAAC;;AAE9B;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAAE;EAAEC;AAAK,CAAC,EAAE;EAClC;AACF;AACA;EACE,gBAAiBC,EAAEA,CAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACvC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE;MACxBA,IAAI,GAAG,CAACA,IAAI,CAAC;IACf;;IAEA;IACA;IACA,MAAMI,OAAO,GAAG,MAAMN,IAAI,CAACO,MAAM,CAACC,SAAS,CAAC,CAAC;IAE7C,IAAI;MACF,OAAQb,IAAI,CACVO,IAAI,EACJO,MAAM,IAAIhB,GAAG,CAACgB,MAAM,EAAEC,GAAG,IAAI;QAC3B,OAAO,YAAY;UACjBA,GAAG,GAAGd,QAAQ,CAACc,GAAG,CAAC;;UAEnB;UACA,MAAMC,MAAM,GAAG;YAAED;UAAI,CAAC;UAEtB,IAAI;YACF,MAAME,GAAG,GAAG,MAAMZ,IAAI,CAACa,MAAM,CAACD,GAAG,CAACF,GAAG,CAAC;YAEtC,IAAI,CAACE,GAAG,EAAE;cACR,MAAMrB,OAAO,CAAC,IAAIuB,KAAK,CAAC,iBAAiB,CAAC,EAAE,qBAAqB,CAAC;YACpE;YAEA,MAAMd,IAAI,CAACa,MAAM,CAACE,MAAM,CAACL,GAAG,CAAC;UAC/B,CAAC,CAAC,QAAO,kBAAmBM,GAAG,EAAE;YAC/B,IAAI,CAACb,OAAO,CAACc,KAAK,EAAE;cAClBD,GAAG,CAACE,OAAO,GAAI,iBAAgBR,GAAI,KAAIM,GAAG,CAACE,OAAQ,EAAC;cACpDP,MAAM,CAACQ,KAAK,GAAGH,GAAG;YACpB;UACF;UAEA,OAAOL,MAAM;QACf,CAAC;MACH,CAAC,CAAC,EACFF,MAAM,IAAIjB,QAAQ,CAACiB,MAAM,EAAE;QAAEW,WAAW,EAAEtB;MAAqB,CAAC,CAAC,EACjEW,MAAM,IAAIf,MAAM,CAACe,MAAM,EAAE,MAAM,CAACN,OAAO,CAACkB,KAAK,CAC/C,CAAC;IACH,CAAC,SAAS;MACRf,OAAO,CAAC,CAAC;IACX;EACF;EAEA,OAAOT,iBAAiB,CAACI,EAAE,CAAC;AAC9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}