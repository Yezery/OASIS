{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WantManager } from './want-manager/index.js';\nimport { Network } from './network.js';\nimport { DecisionEngine } from './decision-engine/index.js';\nimport { Notifications } from './notifications.js';\nimport { logger } from './utils/index.js';\nimport { Stats } from './stats/index.js';\nimport { anySignal } from 'any-signal';\nimport { BaseBlockstore } from 'blockstore-core/base';\nimport { CID } from 'multiformats/cid';\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nexport class Bitswap extends BaseBlockstore {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  constructor(libp2p, blockstore, options = {}) {\n    super();\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options);\n\n    // stats\n    this._stats = new Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    });\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    });\n\n    // local database\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);\n    this.notifications = new Notifications(this.peerId);\n    this.started = false;\n  }\n  isStarted() {\n    return this.started;\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage(peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = [];\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      });\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(received.filter(({\n      wasWanted\n    }) => wasWanted).map(({\n      cid\n    }) => cid));\n    await Promise.all(received.map(({\n      cid,\n      wasWanted,\n      data\n    }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)));\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    this._log('received block');\n    const has = await this.blockstore.has(cid);\n    this._updateReceiveCounters(peerId.toString(), cid, data, has);\n    if (!wasWanted) {\n      return;\n    }\n    await this.put(cid, data);\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n    this._stats.disconnected(peerId);\n  }\n  enableStats() {\n    this._stats.enable();\n  }\n  disableStats() {\n    this._stats.disable();\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get(cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n    let promptedNetwork = false;\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch ( /** @type {any} */err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid, options).catch(err => this._log.error(err));\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options);\n      }\n    };\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController();\n    const signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n    try {\n      const block = await Promise.race([this.notifications.wantBlock(cid, {\n        signal\n      }), loadOrFetchFromNetwork(cid, {\n        signal\n      })]);\n      return block;\n    } finally {\n      // since we have the block we can now remove our listener\n      controller.abort();\n    }\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async *getMany(cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put(cid, block, _options) {\n    await this.blockstore.put(cid, block);\n    this._sendHaveBlockNotifications(cid, block);\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async *putMany(source, options) {\n    for await (const {\n      key,\n      value\n    } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]);\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers() {\n    return this.engine.peers();\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat() {\n    return this._stats;\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  async start() {\n    this.wm.start();\n    await this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  async stop() {\n    this._stats.stop();\n    this.wm.stop();\n    await this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n  unwrap() {\n    return this.blockstore;\n  }\n\n  /**\n   * @param {CID} cid\n   * @returns {Promise<boolean>}\n   */\n  has(cid) {\n    return this.blockstore.has(cid);\n  }\n}","map":{"version":3,"names":["WantManager","Network","DecisionEngine","Notifications","logger","Stats","anySignal","BaseBlockstore","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","hashLoader","maxInboundStreams","maxOutboundStreams","incomingStreamTimeout","engine","wm","notifications","started","isStarted","_receiveMessage","incoming","messageReceived","err","blocks","size","received","cidStr","data","entries","cid","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toString","put","peerIdStr","exists","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","block","code","findAndConnect","catch","controller","AbortController","signal","race","abort","getMany","cids","unwant","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","source","key","value","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","start","stop","unwrap"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/bitswap.js"],"sourcesContent":["import { WantManager } from './want-manager/index.js'\nimport { Network } from './network.js'\nimport { DecisionEngine } from './decision-engine/index.js'\nimport { Notifications } from './notifications.js'\nimport { logger } from './utils/index.js'\nimport { Stats } from './stats/index.js'\nimport { anySignal } from 'any-signal'\nimport { BaseBlockstore } from 'blockstore-core/base'\nimport { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('./types').MultihashHasherLoader} MultihashHasherLoader\n * @typedef {import('./message').BitswapMessage} BitswapMessage\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nexport class Bitswap extends BaseBlockstore {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {Blockstore} blockstore\n   * @param {object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {number} [options.maxInboundStreams=32]\n   * @param {number} [options.maxOutboundStreams=32]\n   * @param {number} [options.incomingStreamTimeout=30000]\n   * @param {MultihashHasherLoader} [options.hashLoader]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(libp2p, statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashLoader: options.hashLoader,\n      maxInboundStreams: options.maxInboundStreams,\n      maxOutboundStreams: options.maxOutboundStreams,\n      incomingStreamTimeout: options.incomingStreamTimeout\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toString(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (/** @type {any} */ err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid, options)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    try {\n      const block = await Promise.race([\n        this.notifications.wantBlock(cid, {\n          signal\n        }),\n        loadOrFetchFromNetwork(cid, {\n          signal\n        })\n      ])\n\n      return block\n    } finally {\n      // since we have the block we can now remove our listener\n      controller.abort()\n    }\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  async start () {\n    this.wm.start()\n    await this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  async stop () {\n    this._stats.stop()\n    this.wm.stop()\n    await this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n\n  /**\n   * @param {CID} cid\n   * @returns {Promise<boolean>}\n   */\n  has (cid) {\n    return this.blockstore.has(cid)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}