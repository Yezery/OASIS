{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nimport { abortableSource } from 'abortable-iterator';\nimport first from 'it-first';\nimport * as lp from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { MAX_PROTOCOL_LENGTH } from './constants.js';\nconst log = logger('libp2p:mss');\nconst NewLine = uint8ArrayFromString('\\n');\nexport function encode(buffer) {\n  const list = new Uint8ArrayList(buffer, NewLine);\n  return lp.encode.single(list);\n}\n/**\n * `write` encodes and writes a single buffer\n */\nexport function write(writer, buffer, options = {}) {\n  const encoded = encode(buffer);\n  if (options.writeBytes === true) {\n    writer.push(encoded.subarray());\n  } else {\n    writer.push(encoded);\n  }\n}\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport function writeAll(writer, buffers, options = {}) {\n  const list = new Uint8ArrayList();\n  for (const buf of buffers) {\n    list.append(encode(buf));\n  }\n  if (options.writeBytes === true) {\n    writer.push(list.subarray());\n  } else {\n    writer.push(list);\n  }\n}\nexport async function read(reader, options) {\n  let byteLength = 1; // Read single byte chunks until the length is known\n  const varByteSource = {\n    [Symbol.asyncIterator]: () => varByteSource,\n    next: async () => reader.next(byteLength)\n  };\n  let input = varByteSource;\n  // If we have been passed an abort signal, wrap the input source in an abortable\n  // iterator that will throw if the operation is aborted\n  if (options?.signal != null) {\n    input = abortableSource(varByteSource, options.signal);\n  }\n  // Once the length has been parsed, read chunk for that length\n  const onLength = l => {\n    byteLength = l;\n  };\n  const buf = await pipe(input, source => lp.decode(source, {\n    onLength,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  }), async source => first(source));\n  if (buf == null || buf.length === 0) {\n    throw new CodeError('no buffer returned', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    log.error('Invalid mss message - missing newline - %s', buf.subarray());\n    throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n  return buf.sublist(0, -1); // Remove newline\n}\n\nexport async function readString(reader, options) {\n  const buf = await read(reader, options);\n  return uint8ArrayToString(buf.subarray());\n}","map":{"version":3,"names":["CodeError","logger","abortableSource","first","lp","pipe","Uint8ArrayList","fromString","uint8ArrayFromString","toString","uint8ArrayToString","MAX_PROTOCOL_LENGTH","log","NewLine","encode","buffer","list","single","write","writer","options","encoded","writeBytes","push","subarray","writeAll","buffers","buf","append","read","reader","byteLength","varByteSource","Symbol","asyncIterator","next","input","signal","onLength","l","source","decode","maxDataLength","length","get","error","sublist","readString"],"sources":["../../src/multistream.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}