{"ast":null,"code":"const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n  get client() {\n    return this._client;\n  }\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0) && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res);\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= this.points + changedPoints) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n      blockPromise.then(() => {\n        reject(res);\n      }).catch(err => {\n        reject(err);\n      });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options).then(res => {\n        resolve(res);\n      }).catch(res => {\n        reject(res);\n      });\n    }\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {BlockedKeys}\n   * @private\n   */\n  get _inmemoryBlockedKeys() {\n    return this._inMemoryBlockedKeys;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param rlKey\n   * @returns {number}\n   */\n  getInmemoryBlockMsBeforeExpire(rlKey) {\n    return this.getInMemoryBlockMsBeforeExpire(rlKey);\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockOnConsumed() {\n    return this.inMemoryBlockOnConsumed;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockOnConsumed(value) {\n    this.inMemoryBlockOnConsumed = value;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockDuration() {\n    return this.inMemoryBlockDuration;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockDuration(value) {\n    this.inMemoryBlockDuration = value;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number}\n   */\n  get msInmemoryBlockDuration() {\n    return this.inMemoryBlockDuration * 1000;\n  }\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n    return 0;\n  }\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n      }).catch(err => {\n        this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n      });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        resolve(this._getRateLimiterRes(rlKey, points, res));\n      }).catch(err => {\n        this._handleError(err, 'penalty', resolve, reject, key, points, options);\n      });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options).then(res => {\n        resolve(this._getRateLimiterRes(rlKey, -points, res));\n      }).catch(err => {\n        this._handleError(err, 'reward', resolve, reject, key, points, options);\n      });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options).then(res => {\n        if (res === null || typeof res === 'undefined') {\n          resolve(null);\n        } else {\n          resolve(this._getRateLimiterRes(rlKey, 0, res));\n        }\n      }).catch(err => {\n        this._handleError(err, 'get', resolve, reject, key, options);\n      });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options).then(res => {\n        this._inMemoryBlockedKeys.delete(rlKey);\n        resolve(res);\n      }).catch(err => {\n        this._handleError(err, 'delete', resolve, reject, key, options);\n      });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) {\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options).then(() => {\n        resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n      }).catch(err => {\n        this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n      });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) {\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) {\n    // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};","map":{"version":3,"names":["RateLimiterAbstract","require","BlockedKeys","RateLimiterRes","module","exports","RateLimiterStoreAbstract","constructor","opts","inMemoryBlockOnConsumed","inmemoryBlockOnConsumed","inMemoryBlockDuration","inmemoryBlockDuration","insuranceLimiter","_inMemoryBlockedKeys","client","_client","value","Error","_afterConsume","resolve","reject","rlKey","changedPoints","storeResult","options","res","_getRateLimiterRes","consumedPoints","addMs","msBeforeNext","points","blockPromise","Promise","blockDuration","msBlockDuration","_block","add","msInMemoryBlockDuration","then","catch","err","execEvenly","isFirstInDuration","delay","Math","ceil","remainingPoints","execEvenlyMinDelayMs","setTimeout","_handleError","funcName","key","data","_inmemoryBlockedKeys","getInmemoryBlockMsBeforeExpire","getInMemoryBlockMsBeforeExpire","msInmemoryBlockDuration","msBeforeExpire","_inMemoryBlockOnConsumed","parseInt","_inMemoryBlockDuration","_insuranceLimiter","block","secDuration","msDuration","getKey","set","duration","consume","pointsToConsume","inMemoryBlockMsBeforeExpire","_upsert","_getKeySecDuration","penalty","reward","get","_get","delete","_delete","deleteInMemoryBlockedAll","initPoints","parseKey","forceExpire"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterStoreAbstract.js"],"sourcesContent":["const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst BlockedKeys = require('./component/BlockedKeys');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nmodule.exports = class RateLimiterStoreAbstract extends RateLimiterAbstract {\n  /**\n   *\n   * @param opts Object Defaults {\n   *   ... see other in RateLimiterAbstract\n   *\n   *   inMemoryBlockOnConsumed: 40, // Number of points when key is blocked\n   *   inMemoryBlockDuration: 10, // Block duration in seconds\n   *   insuranceLimiter: RateLimiterAbstract\n   * }\n   */\n  constructor(opts = {}) {\n    super(opts);\n\n    this.inMemoryBlockOnConsumed = opts.inMemoryBlockOnConsumed || opts.inmemoryBlockOnConsumed;\n    this.inMemoryBlockDuration = opts.inMemoryBlockDuration || opts.inmemoryBlockDuration;\n    this.insuranceLimiter = opts.insuranceLimiter;\n    this._inMemoryBlockedKeys = new BlockedKeys();\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  set client(value) {\n    if (typeof value === 'undefined') {\n      throw new Error('storeClient is not set');\n    }\n    this._client = value;\n  }\n\n  /**\n   * Have to be launched after consume\n   * It blocks key and execute evenly depending on result from store\n   *\n   * It uses _getRateLimiterRes function to prepare RateLimiterRes from store result\n   *\n   * @param resolve\n   * @param reject\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @param {Object} options\n   * @private\n   */\n  _afterConsume(resolve, reject, rlKey, changedPoints, storeResult, options = {}) {\n    const res = this._getRateLimiterRes(rlKey, changedPoints, storeResult);\n\n    if (this.inMemoryBlockOnConsumed > 0 && !(this.inMemoryBlockDuration > 0)\n      && res.consumedPoints >= this.inMemoryBlockOnConsumed\n    ) {\n      this._inMemoryBlockedKeys.addMs(rlKey, res.msBeforeNext);\n      if (res.consumedPoints > this.points) {\n        return reject(res);\n      } else {\n        return resolve(res)\n      }\n    } else if (res.consumedPoints > this.points) {\n      let blockPromise = Promise.resolve();\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + changedPoints)) {\n        res.msBeforeNext = this.msBlockDuration;\n        blockPromise = this._block(rlKey, res.consumedPoints, this.msBlockDuration, options);\n      }\n\n      if (this.inMemoryBlockOnConsumed > 0 && res.consumedPoints >= this.inMemoryBlockOnConsumed) {\n        // Block key for this.inMemoryBlockDuration seconds\n        this._inMemoryBlockedKeys.add(rlKey, this.inMemoryBlockDuration);\n        res.msBeforeNext = this.msInMemoryBlockDuration;\n      }\n\n      blockPromise\n        .then(() => {\n          reject(res);\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n      if (delay < this.execEvenlyMinDelayMs) {\n        delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n      }\n\n      setTimeout(resolve, delay, res);\n    } else {\n      resolve(res);\n    }\n  }\n\n  _handleError(err, funcName, resolve, reject, key, data = false, options = {}) {\n    if (!(this.insuranceLimiter instanceof RateLimiterAbstract)) {\n      reject(err);\n    } else {\n      this.insuranceLimiter[funcName](key, data, options)\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((res) => {\n          reject(res);\n        });\n    }\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {BlockedKeys}\n   * @private\n   */\n  get _inmemoryBlockedKeys() {\n    return this._inMemoryBlockedKeys\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param rlKey\n   * @returns {number}\n   */\n  getInmemoryBlockMsBeforeExpire(rlKey) {\n    return this.getInMemoryBlockMsBeforeExpire(rlKey)\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockOnConsumed() {\n    return this.inMemoryBlockOnConsumed;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockOnConsumed(value) {\n    this.inMemoryBlockOnConsumed = value;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number|number}\n   */\n  get inmemoryBlockDuration() {\n    return this.inMemoryBlockDuration;\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @param value\n   */\n  set inmemoryBlockDuration(value) {\n    this.inMemoryBlockDuration = value\n  }\n\n  /**\n   * @deprecated Use camelCase version\n   * @returns {number}\n   */\n  get msInmemoryBlockDuration() {\n    return this.inMemoryBlockDuration * 1000;\n  }\n\n  getInMemoryBlockMsBeforeExpire(rlKey) {\n    if (this.inMemoryBlockOnConsumed > 0) {\n      return this._inMemoryBlockedKeys.msBeforeExpire(rlKey);\n    }\n\n    return 0;\n  }\n\n  get inMemoryBlockOnConsumed() {\n    return this._inMemoryBlockOnConsumed;\n  }\n\n  set inMemoryBlockOnConsumed(value) {\n    this._inMemoryBlockOnConsumed = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockOnConsumed > 0 && this.points > this.inMemoryBlockOnConsumed) {\n      throw new Error('inMemoryBlockOnConsumed option must be greater or equal \"points\" option');\n    }\n  }\n\n  get inMemoryBlockDuration() {\n    return this._inMemoryBlockDuration;\n  }\n\n  set inMemoryBlockDuration(value) {\n    this._inMemoryBlockDuration = value ? parseInt(value) : 0;\n    if (this.inMemoryBlockDuration > 0 && this.inMemoryBlockOnConsumed === 0) {\n      throw new Error('inMemoryBlockOnConsumed option must be set up');\n    }\n  }\n\n  get msInMemoryBlockDuration() {\n    return this._inMemoryBlockDuration * 1000;\n  }\n\n  get insuranceLimiter() {\n    return this._insuranceLimiter;\n  }\n\n  set insuranceLimiter(value) {\n    if (typeof value !== 'undefined' && !(value instanceof RateLimiterAbstract)) {\n      throw new Error('insuranceLimiter must be instance of RateLimiterAbstract');\n    }\n    this._insuranceLimiter = value;\n    if (this._insuranceLimiter) {\n      this._insuranceLimiter.blockDuration = this.blockDuration;\n      this._insuranceLimiter.execEvenly = this.execEvenly;\n    }\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  block(key, secDuration, options = {}) {\n    const msDuration = secDuration * 1000;\n    return this._block(this.getKey(key), this.points + 1, msDuration, options);\n  }\n\n  /**\n   * Set points by key for any duration\n   *\n   * @param key\n   * @param points\n   * @param secDuration\n   * @param {Object} options\n   *\n   * @return Promise<RateLimiterRes>\n   */\n  set(key, points, secDuration, options = {}) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    return this._block(this.getKey(key), points, msDuration, options);\n  }\n\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n\n      const inMemoryBlockMsBeforeExpire = this.getInMemoryBlockMsBeforeExpire(rlKey);\n      if (inMemoryBlockMsBeforeExpire > 0) {\n        return reject(new RateLimiterRes(0, inMemoryBlockMsBeforeExpire));\n      }\n\n      this._upsert(rlKey, pointsToConsume, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          this._afterConsume(resolve, reject, rlKey, pointsToConsume, res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'consume', resolve, reject, key, pointsToConsume, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'penalty', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param points\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>\n   */\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, -points, this._getKeySecDuration(options) * 1000, false, options)\n        .then((res) => {\n          resolve(this._getRateLimiterRes(rlKey, -points, res));\n        })\n        .catch((err) => {\n          this._handleError(err, 'reward', resolve, reject, key, points, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<RateLimiterRes>|null\n   */\n  get(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._get(rlKey, options)\n        .then((res) => {\n          if (res === null || typeof res === 'undefined') {\n            resolve(null);\n          } else {\n            resolve(this._getRateLimiterRes(rlKey, 0, res));\n          }\n        })\n        .catch((err) => {\n          this._handleError(err, 'get', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   *\n   * @param key\n   * @param {Object} options\n   * @returns Promise<boolean>\n   */\n  delete(key, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve, reject) => {\n      this._delete(rlKey, options)\n        .then((res) => {\n          this._inMemoryBlockedKeys.delete(rlKey);\n          resolve(res);\n        })\n        .catch((err) => {\n          this._handleError(err, 'delete', resolve, reject, key, options);\n        });\n    });\n  }\n\n  /**\n   * Cleanup keys no-matter expired or not.\n   */\n  deleteInMemoryBlockedAll() {\n    this._inMemoryBlockedKeys.delete();\n  }\n\n  /**\n   * Get RateLimiterRes object filled depending on storeResult, which specific for exact store\n   *\n   * @param rlKey\n   * @param changedPoints\n   * @param storeResult\n   * @private\n   */\n  _getRateLimiterRes(rlKey, changedPoints, storeResult) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_getRateLimiterRes'!\");\n  }\n\n  /**\n   * Block key for this.msBlockDuration milliseconds\n   * Usually, it just prolongs lifetime of key\n   *\n   * @param rlKey\n   * @param initPoints\n   * @param msDuration\n   * @param {Object} options\n   *\n   * @return Promise<any>\n   */\n  _block(rlKey, initPoints, msDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._upsert(rlKey, initPoints, msDuration, true, options)\n        .then(() => {\n          resolve(new RateLimiterRes(0, msDuration > 0 ? msDuration : -1, initPoints));\n        })\n        .catch((err) => {\n          this._handleError(err, 'block', resolve, reject, this.parseKey(rlKey), msDuration / 1000, options);\n        });\n    });\n  }\n\n  /**\n   * Have to be implemented in every limiter\n   * Resolve with raw result from Store OR null if rlKey is not set\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _get(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_get'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with true OR false if rlKey doesn't exist\n   * or Reject with error\n   *\n   * @param rlKey\n   * @param {Object} options\n   * @private\n   *\n   * @return Promise<any>\n   */\n  _delete(rlKey, options = {}) { // eslint-disable-line no-unused-vars\n    throw new Error(\"You have to implement the method '_delete'!\");\n  }\n\n  /**\n   * Have to be implemented\n   * Resolve with object used for {@link _getRateLimiterRes} to generate {@link RateLimiterRes}\n   *\n   * @param {string} rlKey\n   * @param {number} points\n   * @param {number} msDuration\n   * @param {boolean} forceExpire\n   * @param {Object} options\n   * @abstract\n   *\n   * @return Promise<Object>\n   */\n  _upsert(rlKey, points, msDuration, forceExpire = false, options = {}) {\n    throw new Error(\"You have to implement the method '_upsert'!\");\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}