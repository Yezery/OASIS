{"ast":null,"code":"import { LockExistsError } from '../errors.js';\nimport debug from 'debug';\nconst log = debug('ipfs:repo:lock:memory');\nconst lockFile = 'repo.lock';\n\n/** @type {Record<string,boolean>} */\nconst LOCKS = {};\n\n/**\n * @typedef {import('../types').LockCloser} LockCloser\n */\n\n/**\n * Lock the repo in the given dir.\n *\n * @param {string} dir\n * @returns {Promise<LockCloser>}\n */\nasync function lock(dir) {\n  const file = dir + '/' + lockFile;\n  log('locking %s', file);\n  if (LOCKS[file] === true) {\n    throw new LockExistsError(`Lock already being held for file: ${file}`);\n  }\n  LOCKS[file] = true;\n  const closer = {\n    async close() {\n      if (LOCKS[file]) {\n        delete LOCKS[file];\n      }\n    }\n  };\n  return closer;\n}\n\n/**\n * Check if the repo in the given directory is locked.\n *\n * @param {string} dir\n * @returns {Promise<boolean>}\n */\nasync function locked(dir) {\n  const file = dir + '/' + lockFile;\n  log(`checking lock: ${file}`);\n  return Boolean(LOCKS[file]);\n}\nexport const MemoryLock = {\n  lock,\n  locked\n};","map":{"version":3,"names":["LockExistsError","debug","log","lockFile","LOCKS","lock","dir","file","closer","close","locked","Boolean","MemoryLock"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/locks/memory.js"],"sourcesContent":["\nimport { LockExistsError } from '../errors.js'\nimport debug from 'debug'\n\nconst log = debug('ipfs:repo:lock:memory')\nconst lockFile = 'repo.lock'\n\n/** @type {Record<string,boolean>} */\nconst LOCKS = {}\n\n/**\n * @typedef {import('../types').LockCloser} LockCloser\n */\n\n/**\n * Lock the repo in the given dir.\n *\n * @param {string} dir\n * @returns {Promise<LockCloser>}\n */\nasync function lock (dir) {\n  const file = dir + '/' + lockFile\n  log('locking %s', file)\n\n  if (LOCKS[file] === true) {\n    throw new LockExistsError(`Lock already being held for file: ${file}`)\n  }\n\n  LOCKS[file] = true\n  const closer = {\n    async close () {\n      if (LOCKS[file]) {\n        delete LOCKS[file]\n      }\n    }\n  }\n  return closer\n}\n\n/**\n * Check if the repo in the given directory is locked.\n *\n * @param {string} dir\n * @returns {Promise<boolean>}\n */\nasync function locked (dir) {\n  const file = dir + '/' + lockFile\n  log(`checking lock: ${file}`)\n\n  return Boolean(LOCKS[file])\n}\n\nexport const MemoryLock = {\n  lock,\n  locked\n}\n"],"mappings":"AACA,SAASA,eAAe,QAAQ,cAAc;AAC9C,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,GAAG,GAAGD,KAAK,CAAC,uBAAuB,CAAC;AAC1C,MAAME,QAAQ,GAAG,WAAW;;AAE5B;AACA,MAAMC,KAAK,GAAG,CAAC,CAAC;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,IAAIA,CAAEC,GAAG,EAAE;EACxB,MAAMC,IAAI,GAAGD,GAAG,GAAG,GAAG,GAAGH,QAAQ;EACjCD,GAAG,CAAC,YAAY,EAAEK,IAAI,CAAC;EAEvB,IAAIH,KAAK,CAACG,IAAI,CAAC,KAAK,IAAI,EAAE;IACxB,MAAM,IAAIP,eAAe,CAAE,qCAAoCO,IAAK,EAAC,CAAC;EACxE;EAEAH,KAAK,CAACG,IAAI,CAAC,GAAG,IAAI;EAClB,MAAMC,MAAM,GAAG;IACb,MAAMC,KAAKA,CAAA,EAAI;MACb,IAAIL,KAAK,CAACG,IAAI,CAAC,EAAE;QACf,OAAOH,KAAK,CAACG,IAAI,CAAC;MACpB;IACF;EACF,CAAC;EACD,OAAOC,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeE,MAAMA,CAAEJ,GAAG,EAAE;EAC1B,MAAMC,IAAI,GAAGD,GAAG,GAAG,GAAG,GAAGH,QAAQ;EACjCD,GAAG,CAAE,kBAAiBK,IAAK,EAAC,CAAC;EAE7B,OAAOI,OAAO,CAACP,KAAK,CAACG,IAAI,CAAC,CAAC;AAC7B;AAEA,OAAO,MAAMK,UAAU,GAAG;EACxBP,IAAI;EACJK;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}