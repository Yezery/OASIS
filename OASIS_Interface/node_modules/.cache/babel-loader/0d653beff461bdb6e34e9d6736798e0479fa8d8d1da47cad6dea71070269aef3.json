{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { logger } from '@libp2p/logger';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { isMultiaddr } from '@multiformats/multiaddr';\nimport { codes } from './errors.js';\nimport { PeerRecord, RecordEnvelope } from '@libp2p/peer-record';\nimport { peerIdFromPeerId } from '@libp2p/peer-id';\nimport { CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:peer-store:address-book');\nconst EVENT_NAME = 'change:multiaddrs';\nasync function allowAll() {\n  return true;\n}\nexport class PeerStoreAddressBook {\n  constructor(dispatchEvent, store, addressFilter) {\n    this.dispatchEvent = dispatchEvent;\n    this.store = store;\n    this.addressFilter = addressFilter ?? allowAll;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   */\n  async consumePeerRecord(envelope) {\n    log.trace('consumePeerRecord await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('consumePeerRecord got write lock');\n    let peerId;\n    let peer;\n    let updatedPeer;\n    try {\n      let peerRecord;\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n      } catch (err) {\n        log.error('invalid peer record received');\n        return false;\n      }\n      peerId = peerRecord.peerId;\n      const multiaddrs = peerRecord.multiaddrs;\n      // Verify peerId\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord');\n        return false;\n      }\n      // ensure the record has multiaddrs\n      if (multiaddrs == null || multiaddrs.length === 0) {\n        return false;\n      }\n      if (await this.store.has(peerId)) {\n        peer = await this.store.load(peerId);\n        if (peer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber);\n            return false;\n          }\n        }\n      }\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);\n      // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses,\n        peerRecordEnvelope: envelope.marshal().subarray()\n      });\n      log('stored provided peer record for %p', peerRecord.peerId);\n    } finally {\n      log.trace('consumePeerRecord release write lock');\n      release();\n    }\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(({\n          multiaddr\n        }) => multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({\n          multiaddr\n        }) => multiaddr)\n      }\n    }));\n    return true;\n  }\n  async getRawEnvelope(peerId) {\n    log.trace('getRawEnvelope await read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('getRawEnvelope got read lock');\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.peerRecordEnvelope;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('getRawEnvelope release read lock');\n      release();\n    }\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   */\n  async getPeerRecord(peerId) {\n    const raw = await this.getRawEnvelope(peerId);\n    if (raw == null) {\n      return undefined;\n    }\n    return await RecordEnvelope.createFromProtobuf(raw);\n  }\n  async get(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('get wait for read lock');\n    const release = await this.store.lock.readLock();\n    log.trace('get got read lock');\n    try {\n      const peer = await this.store.load(peerId);\n      return peer.addresses;\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log.trace('get release read lock');\n      release();\n    }\n    return [];\n  }\n  async set(peerId, multiaddrs) {\n    peerId = peerIdFromPeerId(peerId);\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS);\n    }\n    log.trace('set await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('set got write lock');\n    let hasPeer = false;\n    let peer;\n    let updatedPeer;\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return;\n      }\n      try {\n        peer = await this.store.load(peerId);\n        hasPeer = true;\n        if (new Set([...addresses.map(({\n          multiaddr\n        }) => multiaddr.toString()), ...peer.addresses.map(({\n          multiaddr\n        }) => multiaddr.toString())]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n      updatedPeer = await this.store.patchOrCreate(peerId, {\n        addresses\n      });\n      log('set multiaddrs for %p', peerId);\n    } finally {\n      log.trace('set multiaddrs for %p', peerId);\n      log('set release write lock');\n      release();\n    }\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({\n          multiaddr\n        }) => multiaddr)\n      }\n    }));\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }));\n    }\n  }\n  async add(peerId, multiaddrs) {\n    peerId = peerIdFromPeerId(peerId);\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw new CodeError('multiaddrs must be an array of Multiaddrs', codes.ERR_INVALID_PARAMETERS);\n    }\n    log.trace('add await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('add got write lock');\n    let hasPeer;\n    let peer;\n    let updatedPeer;\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);\n      // No valid addresses found\n      if (addresses.length === 0) {\n        return;\n      }\n      try {\n        peer = await this.store.load(peerId);\n        hasPeer = true;\n        if (new Set([...addresses.map(({\n          multiaddr\n        }) => multiaddr.toString()), ...peer.addresses.map(({\n          multiaddr\n        }) => multiaddr.toString())]).size === peer.addresses.length) {\n          return;\n        }\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n      updatedPeer = await this.store.mergeOrCreate(peerId, {\n        addresses\n      });\n      log('added multiaddrs for %p', peerId);\n    } finally {\n      log.trace('set release write lock');\n      release();\n    }\n    this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n      detail: {\n        peerId,\n        multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({\n          multiaddr\n        }) => multiaddr)\n      }\n    }));\n    // Notify the existence of a new peer\n    if (hasPeer === true) {\n      this.dispatchEvent(new CustomEvent('peer', {\n        detail: {\n          id: peerId,\n          multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr),\n          protocols: updatedPeer.protocols\n        }\n      }));\n    }\n  }\n  async delete(peerId) {\n    peerId = peerIdFromPeerId(peerId);\n    log.trace('delete await write lock');\n    const release = await this.store.lock.writeLock();\n    log.trace('delete got write lock');\n    let peer;\n    try {\n      try {\n        peer = await this.store.load(peerId);\n      } catch (err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n      await this.store.patchOrCreate(peerId, {\n        addresses: []\n      });\n    } finally {\n      log.trace('delete release write lock');\n      release();\n    }\n    if (peer != null) {\n      this.dispatchEvent(new CustomEvent(EVENT_NAME, {\n        detail: {\n          peerId,\n          multiaddrs: [],\n          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({\n            multiaddr\n          }) => multiaddr)\n        }\n      }));\n    }\n  }\n}\nasync function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {\n  const output = [];\n  await Promise.all(multiaddrs.map(async multiaddr => {\n    if (!isMultiaddr(multiaddr)) {\n      log.error('multiaddr must be an instance of Multiaddr');\n      throw new CodeError('multiaddr must be an instance of Multiaddr', codes.ERR_INVALID_PARAMETERS);\n    }\n    const include = await addressFilter(peerId, multiaddr);\n    if (!include) {\n      return;\n    }\n    output.push({\n      multiaddr,\n      isCertified\n    });\n  }));\n  return output;\n}","map":{"version":3,"names":["logger","CodeError","isMultiaddr","codes","PeerRecord","RecordEnvelope","peerIdFromPeerId","CustomEvent","log","EVENT_NAME","allowAll","PeerStoreAddressBook","constructor","dispatchEvent","store","addressFilter","consumePeerRecord","envelope","trace","release","lock","writeLock","peerId","peer","updatedPeer","peerRecord","createFromProtobuf","payload","err","error","multiaddrs","equals","length","has","load","peerRecordEnvelope","storedEnvelope","storedRecord","seqNumber","addresses","filterMultiaddrs","patchOrCreate","marshal","subarray","detail","map","multiaddr","oldMultiaddrs","getRawEnvelope","readLock","code","ERR_NOT_FOUND","getPeerRecord","raw","undefined","get","set","Array","isArray","ERR_INVALID_PARAMETERS","hasPeer","Set","toString","size","addr","id","protocols","add","mergeOrCreate","delete","isCertified","output","Promise","all","include","push"],"sources":["../../src/address-book.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}