{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport { jump, quick } from './jump.js';\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor(data, options = {}) {\n    this._pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  pos() {\n    return this._pos;\n  }\n  done() {\n    return this._pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this._pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this._pos, minor, this.options);\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break;\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break;\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value);\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value;\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj;\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject(tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported');\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`);\n  }\n  return [decoded, data.subarray(tokeniser.pos())];\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode(data, options) {\n  const [decoded, remainder] = decodeFirst(data, options);\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport { Tokeniser, tokensToObject, decode, decodeFirst };","map":{"version":3,"names":["decodeErrPrefix","Type","jump","quick","defaultDecodeOptions","strict","allowIndefinite","allowUndefined","allowBigInt","Tokeniser","constructor","data","options","_pos","pos","done","length","next","byt","token","undefined","decoder","Error","toString","padStart","minor","encodedLength","DONE","Symbol","for","BREAK","tokenToArray","tokeniser","arr","i","value","tokensToObject","Infinity","tokenToMap","useMaps","obj","m","Map","key","rejectDuplicateMapKeys","has","set","type","break","terminal","array","map","tag","tags","tagged","decodeFirst","Uint8Array","Object","assign","tokenizer","decoded","subarray","decode","remainder"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.1/node_modules/cborg/lib/decode.js"],"sourcesContent":["import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,aAAa;AAC7C,SAASC,IAAI,QAAQ,YAAY;AACjC,SAASC,IAAI,EAAEC,KAAK,QAAQ,WAAW;;AAEvC;AACA;AACA;AACA;AACA;;AAEA,MAAMC,oBAAoB,GAAG;EAC3BC,MAAM,EAAE,KAAK;EACbC,eAAe,EAAE,IAAI;EACrBC,cAAc,EAAE,IAAI;EACpBC,WAAW,EAAE;AACf,CAAC;;AAED;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EACd;AACF;AACA;AACA;EACEC,WAAWA,CAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC/B,IAAI,CAACC,IAAI,GAAG,CAAC;IACb,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,OAAO,GAAGA,OAAO;EACxB;EAEAE,GAAGA,CAAA,EAAI;IACL,OAAO,IAAI,CAACD,IAAI;EAClB;EAEAE,IAAIA,CAAA,EAAI;IACN,OAAO,IAAI,CAACF,IAAI,IAAI,IAAI,CAACF,IAAI,CAACK,MAAM;EACtC;EAEAC,IAAIA,CAAA,EAAI;IACN,MAAMC,GAAG,GAAG,IAAI,CAACP,IAAI,CAAC,IAAI,CAACE,IAAI,CAAC;IAChC,IAAIM,KAAK,GAAGhB,KAAK,CAACe,GAAG,CAAC;IACtB,IAAIC,KAAK,KAAKC,SAAS,EAAE;MACvB,MAAMC,OAAO,GAAGnB,IAAI,CAACgB,GAAG,CAAC;MACzB;MACA;MACA,IAAI,CAACG,OAAO,EAAE;QACZ,MAAM,IAAIC,KAAK,CAAE,GAAEtB,eAAgB,8BAA6BkB,GAAG,KAAK,CAAE,YAAWA,GAAG,CAACK,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,CAAC;MAC5H;MACA,MAAMC,KAAK,GAAGP,GAAG,GAAG,EAAE;MACtBC,KAAK,GAAGE,OAAO,CAAC,IAAI,CAACV,IAAI,EAAE,IAAI,CAACE,IAAI,EAAEY,KAAK,EAAE,IAAI,CAACb,OAAO,CAAC;IAC5D;IACA;IACA,IAAI,CAACC,IAAI,IAAIM,KAAK,CAACO,aAAa;IAChC,OAAOP,KAAK;EACd;AACF;AAEA,MAAMQ,IAAI,GAAGC,MAAM,CAACC,GAAG,CAAC,MAAM,CAAC;AAC/B,MAAMC,KAAK,GAAGF,MAAM,CAACC,GAAG,CAAC,OAAO,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,YAAYA,CAAEZ,KAAK,EAAEa,SAAS,EAAEpB,OAAO,EAAE;EAChD,MAAMqB,GAAG,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACgB,KAAK,EAAED,CAAC,EAAE,EAAE;IACpC,MAAMC,KAAK,GAAGC,cAAc,CAACJ,SAAS,EAAEpB,OAAO,CAAC;IAChD,IAAIuB,KAAK,KAAKL,KAAK,EAAE;MACnB,IAAIX,KAAK,CAACgB,KAAK,KAAKE,QAAQ,EAAE;QAC5B;QACA;MACF;MACA,MAAM,IAAIf,KAAK,CAAE,GAAEtB,eAAgB,yCAAwC,CAAC;IAC9E;IACA,IAAImC,KAAK,KAAKR,IAAI,EAAE;MAClB,MAAM,IAAIL,KAAK,CAAE,GAAEtB,eAAgB,4CAA2CkC,CAAE,cAAaf,KAAK,CAACgB,KAAM,GAAE,CAAC;IAC9G;IACAF,GAAG,CAACC,CAAC,CAAC,GAAGC,KAAK;EAChB;EACA,OAAOF,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,UAAUA,CAAEnB,KAAK,EAAEa,SAAS,EAAEpB,OAAO,EAAE;EAC9C,MAAM2B,OAAO,GAAG3B,OAAO,CAAC2B,OAAO,KAAK,IAAI;EACxC,MAAMC,GAAG,GAAGD,OAAO,GAAGnB,SAAS,GAAG,CAAC,CAAC;EACpC,MAAMqB,CAAC,GAAGF,OAAO,GAAG,IAAIG,GAAG,CAAC,CAAC,GAAGtB,SAAS;EACzC,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACgB,KAAK,EAAED,CAAC,EAAE,EAAE;IACpC,MAAMS,GAAG,GAAGP,cAAc,CAACJ,SAAS,EAAEpB,OAAO,CAAC;IAC9C,IAAI+B,GAAG,KAAKb,KAAK,EAAE;MACjB,IAAIX,KAAK,CAACgB,KAAK,KAAKE,QAAQ,EAAE;QAC5B;QACA;MACF;MACA,MAAM,IAAIf,KAAK,CAAE,GAAEtB,eAAgB,uCAAsC,CAAC;IAC5E;IACA,IAAI2C,GAAG,KAAKhB,IAAI,EAAE;MAChB,MAAM,IAAIL,KAAK,CAAE,GAAEtB,eAAgB,0CAAyCkC,CAAE,uBAAsBf,KAAK,CAACgB,KAAM,GAAE,CAAC;IACrH;IACA,IAAII,OAAO,KAAK,IAAI,IAAI,OAAOI,GAAG,KAAK,QAAQ,EAAE;MAC/C,MAAM,IAAIrB,KAAK,CAAE,GAAEtB,eAAgB,uCAAsC,OAAO2C,GAAI,GAAE,CAAC;IACzF;IACA,IAAI/B,OAAO,CAACgC,sBAAsB,KAAK,IAAI,EAAE;MAC3C;MACA,IAAKL,OAAO,IAAIE,CAAC,CAACI,GAAG,CAACF,GAAG,CAAC,IAAM,CAACJ,OAAO,IAAKI,GAAG,IAAIH,GAAK,EAAE;QACzD,MAAM,IAAIlB,KAAK,CAAE,GAAEtB,eAAgB,0BAAyB2C,GAAI,GAAE,CAAC;MACrE;IACF;IACA,MAAMR,KAAK,GAAGC,cAAc,CAACJ,SAAS,EAAEpB,OAAO,CAAC;IAChD,IAAIuB,KAAK,KAAKR,IAAI,EAAE;MAClB,MAAM,IAAIL,KAAK,CAAE,GAAEtB,eAAgB,0CAAyCkC,CAAE,yBAAwBf,KAAK,CAACgB,KAAM,GAAE,CAAC;IACvH;IACA,IAAII,OAAO,EAAE;MACX;MACAE,CAAC,CAACK,GAAG,CAACH,GAAG,EAAER,KAAK,CAAC;IACnB,CAAC,MAAM;MACL;MACAK,GAAG,CAACG,GAAG,CAAC,GAAGR,KAAK;IAClB;EACF;EACA;EACA,OAAOI,OAAO,GAAGE,CAAC,GAAGD,GAAG;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASJ,cAAcA,CAAEJ,SAAS,EAAEpB,OAAO,EAAE;EAC3C;EACA;EACA,IAAIoB,SAAS,CAACjB,IAAI,CAAC,CAAC,EAAE;IACpB,OAAOY,IAAI;EACb;EAEA,MAAMR,KAAK,GAAGa,SAAS,CAACf,IAAI,CAAC,CAAC;EAE9B,IAAIE,KAAK,CAAC4B,IAAI,KAAK9C,IAAI,CAAC+C,KAAK,EAAE;IAC7B,OAAOlB,KAAK;EACd;EAEA,IAAIX,KAAK,CAAC4B,IAAI,CAACE,QAAQ,EAAE;IACvB,OAAO9B,KAAK,CAACgB,KAAK;EACpB;EAEA,IAAIhB,KAAK,CAAC4B,IAAI,KAAK9C,IAAI,CAACiD,KAAK,EAAE;IAC7B,OAAOnB,YAAY,CAACZ,KAAK,EAAEa,SAAS,EAAEpB,OAAO,CAAC;EAChD;EAEA,IAAIO,KAAK,CAAC4B,IAAI,KAAK9C,IAAI,CAACkD,GAAG,EAAE;IAC3B,OAAOb,UAAU,CAACnB,KAAK,EAAEa,SAAS,EAAEpB,OAAO,CAAC;EAC9C;EAEA,IAAIO,KAAK,CAAC4B,IAAI,KAAK9C,IAAI,CAACmD,GAAG,EAAE;IAC3B,IAAIxC,OAAO,CAACyC,IAAI,IAAI,OAAOzC,OAAO,CAACyC,IAAI,CAAClC,KAAK,CAACgB,KAAK,CAAC,KAAK,UAAU,EAAE;MACnE,MAAMmB,MAAM,GAAGlB,cAAc,CAACJ,SAAS,EAAEpB,OAAO,CAAC;MACjD,OAAOA,OAAO,CAACyC,IAAI,CAAClC,KAAK,CAACgB,KAAK,CAAC,CAACmB,MAAM,CAAC;IAC1C;IACA,MAAM,IAAIhC,KAAK,CAAE,GAAEtB,eAAgB,uBAAsBmB,KAAK,CAACgB,KAAM,GAAE,CAAC;EAC1E;EACA;EACA,MAAM,IAAIb,KAAK,CAAC,aAAa,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASiC,WAAWA,CAAE5C,IAAI,EAAEC,OAAO,EAAE;EACnC,IAAI,EAAED,IAAI,YAAY6C,UAAU,CAAC,EAAE;IACjC,MAAM,IAAIlC,KAAK,CAAE,GAAEtB,eAAgB,sCAAqC,CAAC;EAC3E;EACAY,OAAO,GAAG6C,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEtD,oBAAoB,EAAEQ,OAAO,CAAC;EAC1D,MAAMoB,SAAS,GAAGpB,OAAO,CAAC+C,SAAS,IAAI,IAAIlD,SAAS,CAACE,IAAI,EAAEC,OAAO,CAAC;EACnE,MAAMgD,OAAO,GAAGxB,cAAc,CAACJ,SAAS,EAAEpB,OAAO,CAAC;EAClD,IAAIgD,OAAO,KAAKjC,IAAI,EAAE;IACpB,MAAM,IAAIL,KAAK,CAAE,GAAEtB,eAAgB,qCAAoC,CAAC;EAC1E;EACA,IAAI4D,OAAO,KAAK9B,KAAK,EAAE;IACrB,MAAM,IAAIR,KAAK,CAAE,GAAEtB,eAAgB,uBAAsB,CAAC;EAC5D;EACA,OAAO,CAAC4D,OAAO,EAAEjD,IAAI,CAACkD,QAAQ,CAAC7B,SAAS,CAAClB,GAAG,CAAC,CAAC,CAAC,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASgD,MAAMA,CAAEnD,IAAI,EAAEC,OAAO,EAAE;EAC9B,MAAM,CAACgD,OAAO,EAAEG,SAAS,CAAC,GAAGR,WAAW,CAAC5C,IAAI,EAAEC,OAAO,CAAC;EACvD,IAAImD,SAAS,CAAC/C,MAAM,GAAG,CAAC,EAAE;IACxB,MAAM,IAAIM,KAAK,CAAE,GAAEtB,eAAgB,0CAAyC,CAAC;EAC/E;EACA,OAAO4D,OAAO;AAChB;AAEA,SAASnD,SAAS,EAAE2B,cAAc,EAAE0B,MAAM,EAAEP,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}