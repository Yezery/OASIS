{"ast":null,"code":"'use strict';\n\nconst ModuleError = require('module-error');\nconst encodings = require('./lib/encodings');\nconst {\n  Encoding\n} = require('./lib/encoding');\nconst {\n  BufferFormat,\n  ViewFormat,\n  UTF8Format\n} = require('./lib/formats');\nconst kFormats = Symbol('formats');\nconst kEncodings = Symbol('encodings');\nconst validFormats = new Set(['buffer', 'view', 'utf8']);\n\n/** @template T */\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor(formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\");\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map();\n    this[kFormats] = new Set(formats);\n\n    // Register encodings (done early in order to populate encodings())\n    for (const k in encodings) {\n      try {\n        this.encoding(k);\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err;\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  encodings() {\n    return Array.from(new Set(this[kEncodings].values()));\n  }\n\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n  encoding(encoding) {\n    let resolved = this[kEncodings].get(encoding);\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding];\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          });\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\");\n      } else {\n        resolved = from(encoding);\n      }\n      const {\n        name,\n        format\n      } = resolved;\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder();\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder();\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder();\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          });\n        }\n      }\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved);\n      }\n    }\n    return resolved;\n  }\n}\nexports.Transcoder = Transcoder;\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from(options) {\n  if (options instanceof Encoding) {\n    return options;\n  }\n\n  // Loosely typed for ecosystem compatibility\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined;\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`;\n  switch (detectFormat(options)) {\n    case 'view':\n      return new ViewFormat({\n        ...options,\n        name\n      });\n    case 'utf8':\n      return new UTF8Format({\n        ...options,\n        name\n      });\n    case 'buffer':\n      return new BufferFormat({\n        ...options,\n        name\n      });\n    default:\n      {\n        throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\");\n      }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat(options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format;\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8'; // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view'; // multiformats\n  } else {\n    return 'buffer';\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n};\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst lookup = {\n  ...encodings,\n  ...aliases\n};\nlet anonymousCount = 0;","map":{"version":3,"names":["ModuleError","require","encodings","Encoding","BufferFormat","ViewFormat","UTF8Format","kFormats","Symbol","kEncodings","validFormats","Set","Transcoder","constructor","formats","Array","isArray","TypeError","every","f","has","Map","k","encoding","err","code","from","values","resolved","get","undefined","lookup","name","format","createViewTranscoder","createBufferTranscoder","createUTF8Transcoder","commonName","set","exports","options","maybeType","type","anonymousCount","detectFormat","buffer","Number","isInteger","aliases","binary","utf8"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/level-transcoder@1.0.1/node_modules/level-transcoder/index.js"],"sourcesContent":["'use strict'\n\nconst ModuleError = require('module-error')\nconst encodings = require('./lib/encodings')\nconst { Encoding } = require('./lib/encoding')\nconst { BufferFormat, ViewFormat, UTF8Format } = require('./lib/formats')\n\nconst kFormats = Symbol('formats')\nconst kEncodings = Symbol('encodings')\nconst validFormats = new Set(['buffer', 'view', 'utf8'])\n\n/** @template T */\nclass Transcoder {\n  /**\n   * @param {Array<'buffer'|'view'|'utf8'>} formats\n   */\n  constructor (formats) {\n    if (!Array.isArray(formats)) {\n      throw new TypeError(\"The first argument 'formats' must be an array\")\n    } else if (!formats.every(f => validFormats.has(f))) {\n      // Note: we only only support aliases in key- and valueEncoding options (where we already did)\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n\n    /** @type {Map<string|MixedEncoding<any, any, any>, Encoding<any, any, any>>} */\n    this[kEncodings] = new Map()\n    this[kFormats] = new Set(formats)\n\n    // Register encodings (done early in order to populate encodings())\n    for (const k in encodings) {\n      try {\n        this.encoding(k)\n      } catch (err) {\n        /* istanbul ignore if: assertion */\n        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err\n      }\n    }\n  }\n\n  /**\n   * @returns {Array<Encoding<any,T,any>>}\n   */\n  encodings () {\n    return Array.from(new Set(this[kEncodings].values()))\n  }\n\n  /**\n   * @param {string|MixedEncoding<any, any, any>} encoding\n   * @returns {Encoding<any, T, any>}\n   */\n  encoding (encoding) {\n    let resolved = this[kEncodings].get(encoding)\n\n    if (resolved === undefined) {\n      if (typeof encoding === 'string' && encoding !== '') {\n        resolved = lookup[encoding]\n\n        if (!resolved) {\n          throw new ModuleError(`Encoding '${encoding}' is not found`, {\n            code: 'LEVEL_ENCODING_NOT_FOUND'\n          })\n        }\n      } else if (typeof encoding !== 'object' || encoding === null) {\n        throw new TypeError(\"First argument 'encoding' must be a string or object\")\n      } else {\n        resolved = from(encoding)\n      }\n\n      const { name, format } = resolved\n\n      if (!this[kFormats].has(format)) {\n        if (this[kFormats].has('view')) {\n          resolved = resolved.createViewTranscoder()\n        } else if (this[kFormats].has('buffer')) {\n          resolved = resolved.createBufferTranscoder()\n        } else if (this[kFormats].has('utf8')) {\n          resolved = resolved.createUTF8Transcoder()\n        } else {\n          throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {\n            code: 'LEVEL_ENCODING_NOT_SUPPORTED'\n          })\n        }\n      }\n\n      for (const k of [encoding, name, resolved.name, resolved.commonName]) {\n        this[kEncodings].set(k, resolved)\n      }\n    }\n\n    return resolved\n  }\n}\n\nexports.Transcoder = Transcoder\n\n/**\n * @param {MixedEncoding<any, any, any>} options\n * @returns {Encoding<any, any, any>}\n */\nfunction from (options) {\n  if (options instanceof Encoding) {\n    return options\n  }\n\n  // Loosely typed for ecosystem compatibility\n  const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined\n  const name = options.name || maybeType || `anonymous-${anonymousCount++}`\n\n  switch (detectFormat(options)) {\n    case 'view': return new ViewFormat({ ...options, name })\n    case 'utf8': return new UTF8Format({ ...options, name })\n    case 'buffer': return new BufferFormat({ ...options, name })\n    default: {\n      throw new TypeError(\"Format must be one of 'buffer', 'view', 'utf8'\")\n    }\n  }\n}\n\n/**\n * If format is not provided, fallback to detecting `level-codec`\n * or `multiformats` encodings, else assume a format of buffer.\n * @param {MixedEncoding<any, any, any>} options\n * @returns {string}\n */\nfunction detectFormat (options) {\n  if ('format' in options && options.format !== undefined) {\n    return options.format\n  } else if ('buffer' in options && typeof options.buffer === 'boolean') {\n    return options.buffer ? 'buffer' : 'utf8' // level-codec\n  } else if ('code' in options && Number.isInteger(options.code)) {\n    return 'view' // multiformats\n  } else {\n    return 'buffer'\n  }\n}\n\n/**\n * @typedef {import('./lib/encoding').MixedEncoding<TIn,TFormat,TOut>} MixedEncoding\n * @template TIn, TFormat, TOut\n */\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst aliases = {\n  binary: encodings.buffer,\n  'utf-8': encodings.utf8\n}\n\n/**\n * @type {Object.<string, Encoding<any, any, any>>}\n */\nconst lookup = {\n  ...encodings,\n  ...aliases\n}\n\nlet anonymousCount = 0\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}