{"ast":null,"code":"import filter from 'it-filter';\nimport take from 'it-take';\nimport merge from 'it-merge';\nimport { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport { sortAll } from './utils.js';\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\nexport class MountDatastore extends BaseDatastore {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key} | undefined}\n   */\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        };\n      }\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  put(key, value, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.put(key, value, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.get(key, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n    return match.datastore.has(key, options);\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.delete(key, options);\n  }\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch() {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {};\n    /**\n     * @param {Key} key\n     */\n    const lookup = key => {\n      const match = this._lookup(key);\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n      const m = match.mountpoint.toString();\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n      return {\n        batch: batchMounts[m]\n      };\n    };\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(key, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(key);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n\n    /** @type AsyncIterable<Pair> */\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= /** @type {number} */q.offset);\n    }\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n\n    /** @type AsyncIterable<Key> */\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= /** @type {number} */q.offset);\n    }\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n}","map":{"version":3,"names":["filter","take","merge","BaseDatastore","Errors","sortAll","MountDatastore","constructor","mounts","slice","open","Promise","all","map","m","datastore","_lookup","key","mount","prefix","toString","isAncestorOf","mountpoint","put","value","options","match","dbWriteFailedError","Error","get","notFoundError","has","resolve","delete","dbDeleteFailedError","close","batch","batchMounts","lookup","commit","Object","keys","p","query","q","qs","filters","it","forEach","f","orders","o","offset","i","limit","queryKeys"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/datastore-core@8.0.4/node_modules/datastore-core/src/mount.js"],"sourcesContent":["import filter from 'it-filter'\nimport take from 'it-take'\nimport merge from 'it-merge'\nimport { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport {\n  sortAll\n} from './utils.js'\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\nexport class MountDatastore extends BaseDatastore {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor (mounts) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  async open () {\n    await Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key} | undefined}\n   */\n  _lookup (key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  put (key, value, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(key, value, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return Promise.resolve(false)\n    }\n    return match.datastore.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(key, options)\n  }\n\n  async close () {\n    await Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {}\n    /**\n     * @param {Key} key\n     */\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m]\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(key, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(key)\n      },\n      commit: async (options) => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)))\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    /** @type AsyncIterable<Pair> */\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    /** @type AsyncIterable<Key> */\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}