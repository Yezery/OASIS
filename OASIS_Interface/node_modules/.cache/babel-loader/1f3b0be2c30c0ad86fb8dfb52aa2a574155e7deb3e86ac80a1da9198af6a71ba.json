{"ast":null,"code":"import * as ipns from 'ipns';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport * as Errors from 'datastore-core/errors';\nimport { ipnsValidator } from 'ipns/validator';\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst log = logger('ipfs:ipns:resolver');\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\nexport class IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve(name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n    const key = nameSegments[2];\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity;\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n    const res = await this.resolver(key, depth, options);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @param {AbortOptions} options\n   * @returns {Promise<string>}\n   */\n  async resolver(name, depth, options) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n    const res = await this._resolveName(name, options);\n    const nameSegments = res.split('/');\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1, options);\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   * @param {AbortOptions} options\n   */\n  async _resolveName(name, options) {\n    const peerId = peerIdFromString(name);\n    const routingKey = ipns.peerIdToRoutingKey(peerId);\n    let record;\n    try {\n      record = await this._routing.get(routingKey, options);\n    } catch ( /** @type {any} */err) {\n      log.error('could not get record from routing', err);\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, record);\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} record\n   */\n  async _validateRecord(peerId, record) {\n    // IPNS entry validation\n    await ipnsValidator(uint8ArrayConcat([uint8ArrayFromString('/ipns/'), peerId.toBytes()]), record);\n    const ipnsEntry = ipns.unmarshal(record);\n    return uint8ArrayToString(ipnsEntry.value);\n  }\n}","map":{"version":3,"names":["ipns","peerIdFromString","errcode","logger","toString","uint8ArrayToString","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","Errors","ipnsValidator","log","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","res","resolver","errMsg","error","_resolveName","peerId","routingKey","peerIdToRoutingKey","record","get","err","_validateRecord","toBytes","ipnsEntry","unmarshal","value"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/resolver.js"],"sourcesContent":["import * as ipns from 'ipns'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport * as Errors from 'datastore-core/errors'\nimport { ipnsValidator } from 'ipns/validator'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nconst log = logger('ipfs:ipns:resolver')\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nexport class IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth, options)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @param {AbortOptions} options\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth, options) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name, options)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1, options)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   * @param {AbortOptions} options\n   */\n  async _resolveName (name, options) {\n    const peerId = peerIdFromString(name)\n    const routingKey = ipns.peerIdToRoutingKey(peerId)\n    let record\n\n    try {\n      record = await this._routing.get(routingKey, options)\n    } catch (/** @type {any} */ err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, record)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} record\n   */\n  async _validateRecord (peerId, record) {\n    // IPNS entry validation\n    await ipnsValidator(uint8ArrayConcat([\n      uint8ArrayFromString('/ipns/'),\n      peerId.toBytes()\n    ]), record)\n\n    const ipnsEntry = ipns.unmarshal(record)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}