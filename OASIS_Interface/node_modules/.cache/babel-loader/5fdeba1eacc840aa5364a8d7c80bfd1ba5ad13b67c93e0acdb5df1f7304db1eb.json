{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport errCode from 'err-code';\nimport { anySignal } from 'any-signal';\nimport FIFO from 'p-fifo';\nimport { setMaxListeners } from 'events';\nimport { codes } from '../../errors.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:dialer:dial-request');\nexport class DialRequest {\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   */\n  constructor(options) {\n    const {\n      addrs,\n      dialAction,\n      dialer\n    } = options;\n    this.addrs = addrs;\n    this.dialer = dialer;\n    this.dialAction = dialAction;\n  }\n  async run(options = {}) {\n    const tokens = this.dialer.getTokens(this.addrs.length);\n    // If no tokens are available, throw\n    if (tokens.length < 1) {\n      throw errCode(new Error('No dial tokens available'), codes.ERR_NO_DIAL_TOKENS);\n    }\n    const tokenHolder = new FIFO();\n    for (const token of tokens) {\n      void tokenHolder.push(token).catch(err => {\n        log.error(err);\n      });\n    }\n    const dialAbortControllers = this.addrs.map(() => {\n      const controller = new AbortController();\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, controller.signal);\n      } catch {}\n      return controller;\n    });\n    if (options.signal != null) {\n      try {\n        // fails on node < 15.4\n        setMaxListeners?.(Infinity, options.signal);\n      } catch {}\n    }\n    let completedDials = 0;\n    let done = false;\n    try {\n      return await Promise.any(this.addrs.map(async (addr, i) => {\n        const token = await tokenHolder.shift(); // get token\n        // End attempt once another attempt succeeded\n        if (done) {\n          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n          throw errCode(new Error('dialAction already succeeded'), codes.ERR_ALREADY_SUCCEEDED);\n        }\n        const controller = dialAbortControllers[i];\n        if (controller == null) {\n          throw errCode(new Error('dialAction did not come with an AbortController'), codes.ERR_INVALID_PARAMETERS);\n        }\n        let conn;\n        try {\n          const signal = controller.signal;\n          conn = await this.dialAction(addr, {\n            ...options,\n            signal: options.signal != null ? anySignal([signal, options.signal]) : signal\n          });\n          // Remove the successful AbortController so it is not aborted\n          dialAbortControllers[i] = undefined;\n        } finally {\n          completedDials++;\n          // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n          if (this.addrs.length - completedDials >= tokens.length) {\n            void tokenHolder.push(token).catch(err => {\n              log.error(err);\n            });\n          } else {\n            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n          }\n        }\n        if (conn == null) {\n          // Notify Promise.any that attempt was not successful\n          // to prevent from returning undefined despite there\n          // were successful dial attempts\n          throw errCode(new Error('dialAction led to empty object'), codes.ERR_TRANSPORT_DIAL_FAILED);\n        } else {\n          // This dial succeeded, don't attempt anything else\n          done = true;\n        }\n        return conn;\n      }));\n    } finally {\n      // success/failure happened, abort everything else\n      dialAbortControllers.forEach(c => {\n        if (c !== undefined) {\n          c.abort();\n        }\n      });\n      tokens.forEach(token => this.dialer.releaseToken(token)); // release tokens back to the dialer\n    }\n  }\n}","map":{"version":3,"names":["errCode","anySignal","FIFO","setMaxListeners","codes","logger","log","DialRequest","constructor","options","addrs","dialAction","dialer","run","tokens","getTokens","length","Error","ERR_NO_DIAL_TOKENS","tokenHolder","token","push","catch","err","error","dialAbortControllers","map","controller","AbortController","Infinity","signal","completedDials","done","Promise","any","addr","i","shift","releaseToken","splice","indexOf","ERR_ALREADY_SUCCEEDED","ERR_INVALID_PARAMETERS","conn","undefined","ERR_TRANSPORT_DIAL_FAILED","forEach","c","abort"],"sources":["../../../../src/connection-manager/dialer/dial-request.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}