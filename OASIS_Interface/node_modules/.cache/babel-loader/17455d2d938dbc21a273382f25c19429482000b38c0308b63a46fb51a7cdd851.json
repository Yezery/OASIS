{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport mergeOpts from 'merge-options';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { base36 } from 'multiformats/bases/base36';\nimport { peerIdFromString } from '@libp2p/peer-id';\n// @ts-expect-error no types\nimport isDomain from 'is-domain-name';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { OFFLINE_ERROR } from '../../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:name:resolve');\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nexport function createResolve({\n  dns,\n  ipns,\n  isOnline,\n  options: {\n    offline\n  }\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  async function* resolve(name, options = {}) {\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options);\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    }\n\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    }\n    let ipnsName = name.toString();\n    if (!ipnsName.startsWith('/ipns/')) {\n      ipnsName = `/ipns/${ipnsName}`;\n    }\n    let [namespace, hash, ...remainder] = ipnsName.slice(1).split('/');\n    try {\n      if (hash.substring(0, 1) === '1') {\n        const id = peerIdFromString(hash);\n        const digest = Digest.decode(id.toBytes());\n        const libp2pKey = CID.createV1(0x72, digest);\n        hash = libp2pKey.toString(base36);\n      } else {\n        const cid = CID.parse(hash);\n        if (cid.version === 1) {\n          hash = cid.toString(base36);\n        }\n      }\n    } catch ( /** @type {any} */err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder);\n        return;\n      }\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options);\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n  }\n  return withTimeoutOption(resolve);\n}","map":{"version":3,"names":["logger","errcode","mergeOpts","CID","Digest","base36","peerIdFromString","isDomain","toString","uint8ArrayToString","OFFLINE_ERROR","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","appendRemainder","result","remainder","length","join","createResolve","dns","ipns","isOnline","options","offline","resolve","name","nocache","recursive","Error","ipnsName","startsWith","namespace","hash","slice","split","substring","id","digest","decode","toBytes","libp2pKey","createV1","cid","parse","version","err","error","value","Uint8Array"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/name/resolve.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport errcode from 'err-code'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { base36 } from 'multiformats/bases/base36'\nimport { peerIdFromString } from '@libp2p/peer-id'\n// @ts-expect-error no types\nimport isDomain from 'is-domain-name'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { OFFLINE_ERROR } from '../../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst log = logger('ipfs:name:resolve')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {object} config\n * @param {import('ipfs-core-types/src/root').API<{}>[\"dns\"]} config.dns\n * @param {import('../ipns').IPNSAPI} config.ipns\n * @param {import('ipfs-core-types/src/root').API<{}>[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nexport function createResolve ({ dns, ipns, isOnline, options: { offline } }) {\n  /**\n   * @type {import('ipfs-core-types/src/name').API<{}>[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    let ipnsName = name.toString()\n\n    if (!ipnsName.startsWith('/ipns/')) {\n      ipnsName = `/ipns/${ipnsName}`\n    }\n\n    let [namespace, hash, ...remainder] = ipnsName.slice(1).split('/')\n\n    try {\n      if (hash.substring(0, 1) === '1') {\n        const id = peerIdFromString(hash)\n        const digest = Digest.decode(id.toBytes())\n        const libp2pKey = CID.createV1(0x72, digest)\n        hash = libp2pKey.toString(base36)\n      } else {\n        const cid = CID.parse(hash)\n\n        if (cid.version === 1) {\n          hash = cid.toString(base36)\n        }\n      }\n    } catch (/** @type {any} */ err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}