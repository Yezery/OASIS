{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport { createRepo } from 'ipfs-core-config/repo';\nimport getDefaultConfig from 'ipfs-core-config/config';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { peerIdFromKeys } from '@libp2p/peer-id';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport mergeOpts from 'merge-options';\nimport { profiles as configProfiles } from './config/profiles.js';\nimport { NotEnabledError, NotInitializedError } from '../errors.js';\nimport { createLibp2p } from './libp2p.js';\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors';\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory';\nimport errCode from 'err-code';\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys';\nimport { Key } from 'interface-datastore/key';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:components:peer:storage');\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport class Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {\n      peerId,\n      keychain,\n      isNew\n    } = await loadRepo(print, repo, options);\n\n    // TODO: throw error?\n    // @ts-expect-error On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew);\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return {\n      ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  }\n  try {\n    await repo.open();\n    return {\n      ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } catch ( /** @type {any} */err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n    return {\n      ...(await initRepo(print, repo, options)),\n      isNew: true\n    };\n  }\n};\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {};\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n  if (exists === true) {\n    throw new Error('repo already exists');\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID);\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config);\n\n  // 4. Open initialized repo.\n  await repo.open();\n  log('repo opened');\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  };\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch ( /** @type {any} */err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n  if (!(await repo.datastore.has(new Key('/info/self')))) {\n    await libp2p.keychain.importPeer('self', peerId);\n  }\n  await repo.config.set('Keychain', {\n    // @ts-expect-error private field\n    DEK: libp2p.keychain.init.dek\n  });\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\nconst decodePeerId = async peerId => {\n  log('using user-supplied private-key');\n  if (isPeerId(peerId)) {\n    return peerId;\n  }\n  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad');\n  const key = await unmarshalPrivateKey(rawPrivateKey);\n  return await peerIdFromKeys(key.public.bytes, key.bytes);\n};\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, {\n  algorithm = 'Ed25519',\n  bits = 2048\n}) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId();\n  }\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({\n      bits\n    });\n  }\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM');\n};\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = peerId => {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY');\n  }\n  return {\n    PeerID: peerId.toString(),\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  };\n};\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad');\n  const key = await unmarshalPrivateKey(buf);\n  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes);\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configProfiles[name];\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"names":["logger","createRepo","getDefaultConfig","fromString","uint8ArrayFromString","toString","uint8ArrayToString","peerIdFromKeys","isPeerId","mergeOpts","profiles","configProfiles","NotEnabledError","NotInitializedError","createLibp2p","ERR_REPO_NOT_INITIALIZED","createEd25519PeerId","createRSAPeerId","errCode","unmarshalPrivateKey","Key","mergeOptions","bind","ignoreUndefined","log","Storage","constructor","peerId","keychain","repo","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","closed","configureRepo","open","err","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","Identity","keychainConfig","pass","dek","get","libp2p","undefined","multiaddrs","datastore","has","importPeer","set","DEK","rawPrivateKey","key","public","bytes","algorithm","bits","PrivKey","original","getAll","changed","mergeConfigs","replace","buf","Keychain","changes","reduce","name","profile","transform"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/storage.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { createRepo } from 'ipfs-core-config/repo'\nimport getDefaultConfig from 'ipfs-core-config/config'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { isPeerId } from '@libp2p/interface-peer-id'\nimport mergeOpts from 'merge-options'\nimport { profiles as configProfiles } from './config/profiles.js'\nimport { NotEnabledError, NotInitializedError } from '../errors.js'\nimport { createLibp2p } from './libp2p.js'\nimport { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors'\nimport { createEd25519PeerId, createRSAPeerId } from '@libp2p/peer-id-factory'\nimport errCode from 'err-code'\nimport { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { Key } from 'interface-datastore/key'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:components:peer:storage')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@libp2p/crypto/keys').KeyTypes} KeyType\n * @typedef {import('@libp2p/interface-keychain').KeyChain} Keychain\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\nexport class Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-expect-error On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (/** @type {any} */ err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (/** @type {any} */ err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (!(await repo.datastore.has(new Key('/info/self')))) {\n    await libp2p.keychain.importPeer('self', peerId)\n  }\n\n  await repo.config.set('Keychain', {\n    // @ts-expect-error private field\n    DEK: libp2p.keychain.init.dek\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>}\n */\nconst decodePeerId = async (peerId) => {\n  log('using user-supplied private-key')\n  if (isPeerId(peerId)) {\n    return peerId\n  }\n\n  const rawPrivateKey = uint8ArrayFromString(peerId, 'base64pad')\n  const key = await unmarshalPrivateKey(rawPrivateKey)\n  return await peerIdFromKeys(key.public.bytes, key.bytes)\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n\n  if (algorithm === 'Ed25519') {\n    return createEd25519PeerId()\n  }\n\n  if (algorithm === 'RSA') {\n    return createRSAPeerId({ bits })\n  }\n\n  throw errCode(new Error('Unknown PeerId algorithm'), 'ERR_UNKNOWN_PEER_ID_ALGORITHM')\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => {\n  if (peerId.privateKey == null) {\n    throw errCode(new Error('Private key missing'), 'ERR_MISSING_PRIVATE_KEY')\n  }\n\n  return {\n    PeerID: peerId.toString(),\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privateKey, 'base64pad')\n  }\n}\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const buf = uint8ArrayFromString(changed.Identity.PrivKey, 'base64pad')\n  const key = await unmarshalPrivateKey(buf)\n  const peerId = await peerIdFromKeys(key.public.bytes, key.bytes)\n  const libp2p = await createLibp2p({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configProfiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}