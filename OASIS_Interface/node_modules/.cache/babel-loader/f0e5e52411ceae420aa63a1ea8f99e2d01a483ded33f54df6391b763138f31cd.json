{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport errCode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { exporter } from 'ipfs-unixfs-exporter';\nimport { createNode } from './utils/create-node.js';\nimport { toPathComponents } from './utils/to-path-components.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { addLink } from './utils/add-link.js';\nimport { loadMfsRoot } from './utils/with-mfs-root.js';\nimport mergeOpts from 'merge-options';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:mfs:mkdir');\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createMkdir(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  async function mfsMkdir(path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n    path = path.trim();\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n    const root = await loadMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', opts);\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n      try {\n        parent = await exporter(subPath, context.repo.blocks);\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch ( /** @type {any} */err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts);\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n  return withTimeoutOption(mfsMkdir);\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":{"version":3,"names":["errCode","logger","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","loadMfsRoot","mergeOpts","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","createMkdir","context","mfsMkdir","path","options","opts","Error","trim","substring","pathComponents","root","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","repo","blocks","type","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","node","parentCid","size"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/mkdir.js"],"sourcesContent":["import errCode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { createNode } from './utils/create-node.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { addLink } from './utils/add-link.js'\nimport { loadMfsRoot } from './utils/with-mfs-root.js'\nimport mergeOpts from 'merge-options'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:mkdir')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createMkdir (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"mkdir\"]}\n   */\n  async function mfsMkdir (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (opts.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await loadMfsRoot(context, opts)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', opts)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks)\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (/** @type {any} */ err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsMkdir)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}