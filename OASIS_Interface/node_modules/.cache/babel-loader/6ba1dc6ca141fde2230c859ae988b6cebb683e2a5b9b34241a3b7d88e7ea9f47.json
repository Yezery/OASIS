{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { logger } from '@libp2p/logger';\nimport { handshake } from 'it-handshake';\nimport merge from 'it-merge';\nimport { pushable } from 'it-pushable';\nimport { reader } from 'it-reader';\nimport { Uint8ArrayList } from 'uint8arraylist';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport * as multistream from './multistream.js';\nimport { PROTOCOL_ID } from './index.js';\nconst log = logger('libp2p:mss:select');\nexport async function select(stream, protocols, options = {}) {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];\n  const {\n    reader,\n    writer,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n  const protocol = protocols.shift();\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified');\n  }\n  log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol);\n  const p1 = uint8ArrayFromString(PROTOCOL_ID);\n  const p2 = uint8ArrayFromString(protocol);\n  multistream.writeAll(writer, [p1, p2], options);\n  let response = await multistream.readString(reader, options);\n  log.trace('select: read \"%s\"', response);\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    response = await multistream.readString(reader, options);\n    log.trace('select: read \"%s\"', response);\n  }\n  // We're done\n  if (response === protocol) {\n    rest();\n    return {\n      stream: shakeStream,\n      protocol\n    };\n  }\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    log.trace('select: write \"%s\"', protocol);\n    multistream.write(writer, uint8ArrayFromString(protocol), options);\n    const response = await multistream.readString(reader, options);\n    log.trace('select: read \"%s\" for \"%s\"', response, protocol);\n    if (response === protocol) {\n      rest(); // End our writer so others can start writing to stream\n      return {\n        stream: shakeStream,\n        protocol\n      };\n    }\n  }\n  rest();\n  throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n}\nexport function lazySelect(stream, protocol) {\n  // This is a signal to write the multistream headers if the consumer tries to\n  // read from the source\n  const negotiateTrigger = pushable();\n  let negotiated = false;\n  return {\n    stream: {\n      sink: async source => {\n        await stream.sink(async function* () {\n          let first = true;\n          for await (const chunk of merge(source, negotiateTrigger)) {\n            if (first) {\n              first = false;\n              negotiated = true;\n              negotiateTrigger.end();\n              const p1 = uint8ArrayFromString(PROTOCOL_ID);\n              const p2 = uint8ArrayFromString(protocol);\n              const list = new Uint8ArrayList(multistream.encode(p1), multistream.encode(p2));\n              if (chunk.length > 0) list.append(chunk);\n              yield* list;\n            } else {\n              yield chunk;\n            }\n          }\n        }());\n      },\n      source: async function* () {\n        if (!negotiated) negotiateTrigger.push(new Uint8Array());\n        const byteReader = reader(stream.source);\n        let response = await multistream.readString(byteReader);\n        if (response === PROTOCOL_ID) {\n          response = await multistream.readString(byteReader);\n        }\n        if (response !== protocol) {\n          throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL');\n        }\n        for await (const chunk of byteReader) {\n          yield* chunk;\n        }\n      }()\n    },\n    protocol\n  };\n}","map":{"version":3,"names":["CodeError","logger","handshake","merge","pushable","reader","Uint8ArrayList","fromString","uint8ArrayFromString","multistream","PROTOCOL_ID","log","select","stream","protocols","options","Array","isArray","writer","rest","shakeStream","protocol","shift","Error","trace","p1","p2","writeAll","response","readString","write","lazySelect","negotiateTrigger","negotiated","sink","source","first","chunk","end","list","encode","length","append","push","Uint8Array","byteReader"],"sources":["../../src/select.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}