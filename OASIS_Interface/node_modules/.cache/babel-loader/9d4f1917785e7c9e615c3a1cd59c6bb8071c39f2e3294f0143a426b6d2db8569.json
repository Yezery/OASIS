{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SortedMap } from '../utils/sorted-map.js';\n\n/**\n * @typedef {object} PopTaskResult\n * @property {PeerId} [peerId]\n * @property {Task[]} tasks\n * @property {number} pendingSize\n *\n * @typedef {object} PendingTask\n * @property {number} created\n * @property {Task} task\n *\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMerger\n */\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n *\n * @type {TaskMerger}\n */\nconst DefaultTaskMerger = {\n  hasNewInfo() {\n    return false;\n  },\n  merge() {}\n};\n\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nexport class RequestQueue {\n  /**\n   * @param {TaskMerger} [taskMerger]\n   */\n  constructor(taskMerger = DefaultTaskMerger) {\n    this._taskMerger = taskMerger;\n    /** @type {SortedMap<string, PeerTasks>} */\n    this._byPeer = new SortedMap([], PeerTasks.compare);\n  }\n\n  /**\n   * Push tasks onto the queue for the given peer\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks(peerId, tasks) {\n    let peerTasks = this._byPeer.get(peerId.toString());\n    if (!peerTasks) {\n      peerTasks = new PeerTasks(peerId, this._taskMerger);\n    }\n    peerTasks.pushTasks(tasks);\n    this._byPeer.set(peerId.toString(), peerTasks);\n  }\n\n  /**\n   * Choose the peer with the least active work (or if all have the same active\n   * work, the most pending tasks) and pop off the highest priority tasks until\n   * the total size is at least targetMinBytes.\n   * This puts the popped tasks into the \"active\" state, meaning they are\n   * actively being processed (and cannot be modified).\n   *\n   * @param {number} targetMinBytes - the minimum total size of tasks to pop\n   * @returns {PopTaskResult}\n   */\n  popTasks(targetMinBytes) {\n    // Get the queue of tasks for the best peer and pop off tasks up to\n    // targetMinBytes\n    const peerTasks = this._head();\n    if (peerTasks === undefined) {\n      return {\n        tasks: [],\n        pendingSize: 0\n      };\n    }\n    const {\n      tasks,\n      pendingSize\n    } = peerTasks.popTasks(targetMinBytes);\n    if (tasks.length === 0) {\n      return {\n        tasks,\n        pendingSize\n      };\n    }\n    const peerId = peerTasks.peerId;\n    if (peerTasks.isIdle()) {\n      // If there are no more tasks for the peer, free up its memory\n      this._byPeer.delete(peerId.toString());\n    } else {\n      // If there are still tasks remaining, update the sort order of peerTasks\n      // (because it depends on the number of pending tasks)\n      this._byPeer.update(0);\n    }\n    return {\n      peerId,\n      tasks,\n      pendingSize\n    };\n  }\n\n  /**\n   * @private\n   * @returns {PeerTasks|undefined}\n   */\n  _head() {\n    // Shortcut\n    if (this._byPeer.size === 0) {\n      return undefined;\n    }\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [, v] of this._byPeer) {\n      return v;\n    }\n    return undefined;\n  }\n\n  /**\n   * Remove the task with the given topic for the given peer.\n   *\n   * @param {string} topic\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  remove(topic, peerId) {\n    const peerTasks = this._byPeer.get(peerId.toString());\n    peerTasks && peerTasks.remove(topic);\n  }\n\n  /**\n   * Called when the tasks for the given peer complete.\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  tasksDone(peerId, tasks) {\n    const peerTasks = this._byPeer.get(peerId.toString());\n    if (!peerTasks) {\n      return;\n    }\n    const i = this._byPeer.indexOf(peerId.toString());\n    for (const task of tasks) {\n      peerTasks.taskDone(task);\n    }\n\n    // Marking the tasks as done takes them out of the \"active\" state, and the\n    // sort order depends on the size of the active tasks, so we need to update\n    // the order.\n    this._byPeer.update(i);\n  }\n}\n\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nclass PeerTasks {\n  /**\n   * @param {PeerId} peerId\n   * @param {TaskMerger} taskMerger\n   */\n  constructor(peerId, taskMerger) {\n    this.peerId = peerId;\n    this._taskMerger = taskMerger;\n    this._activeTotalSize = 0;\n    this._pending = new PendingTasks();\n    this._active = new Set();\n  }\n\n  /**\n   * Push tasks onto the queue.\n   *\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks(tasks) {\n    for (const t of tasks) {\n      this._pushTask(t);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Task} task\n   * @returns {void}\n   */\n\n  _pushTask(task) {\n    // If the new task doesn't add any more information over what we\n    // already have in the active queue, then we can skip the new task\n    if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n      return;\n    }\n\n    // If there is already a non-active (pending) task with this topic\n    const existingTask = this._pending.get(task.topic);\n    if (existingTask) {\n      // If the new task has a higher priority than the old task,\n      if (task.priority > existingTask.priority) {\n        // Update the priority and the task's position in the queue\n        this._pending.updatePriority(task.topic, task.priority);\n      }\n\n      // Merge the information from the new task into the existing task\n      this._taskMerger.merge(task, existingTask);\n\n      // A task with the topic exists, so we don't need to add\n      // the new task to the queue\n      return;\n    }\n\n    // Push the new task onto the queue\n    this._pending.add(task);\n  }\n\n  /**\n   * Indicates whether the new task adds any more information over tasks that are\n   * already in the active task queue\n   *\n   * @private\n   * @param {Task} task\n   * @returns {boolean}\n   */\n  _taskHasMoreInfoThanActiveTasks(task) {\n    const tasksWithTopic = [];\n    for (const activeTask of this._active) {\n      if (activeTask.topic === task.topic) {\n        tasksWithTopic.push(activeTask);\n      }\n    }\n\n    // No tasks with that topic, so the new task adds information\n    if (tasksWithTopic.length === 0) {\n      return true;\n    }\n    return this._taskMerger.hasNewInfo(task, tasksWithTopic);\n  }\n\n  /**\n   * Pop tasks off the queue such that the total size is at least targetMinBytes\n   *\n   * @param {number} targetMinBytes\n   * @returns {PopTaskResult}\n   */\n  popTasks(targetMinBytes) {\n    let size = 0;\n    const tasks = [];\n\n    // Keep popping tasks until we get up to targetMinBytes (or one item over\n    // targetMinBytes)\n    const pendingTasks = this._pending.tasks();\n    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n      const task = pendingTasks[i];\n      tasks.push(task);\n      size += task.size;\n\n      // Move tasks from pending to active\n      this._pending.delete(task.topic);\n      this._activeTotalSize += task.size;\n      this._active.add(task);\n    }\n    return {\n      tasks,\n      pendingSize: this._pending.totalSize\n    };\n  }\n\n  /**\n   * Called when a task completes.\n   * Note: must be the same reference as returned from popTasks.\n   *\n   * @param {Task} task\n   * @returns {void}\n   */\n  taskDone(task) {\n    if (this._active.has(task)) {\n      this._activeTotalSize -= task.size;\n      this._active.delete(task);\n    }\n  }\n\n  /**\n   * Remove pending tasks with the given topic\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n  remove(topic) {\n    this._pending.delete(topic);\n  }\n\n  /**\n   * No work to be done, this PeerTasks object can be freed.\n   *\n   * @returns {boolean}\n   */\n  isIdle() {\n    return this._pending.length === 0 && this._active.size === 0;\n  }\n\n  /**\n   * Compare PeerTasks\n   *\n   * @template Key\n   * @param {[Key, PeerTasks]} a\n   * @param {[Key, PeerTasks]} b\n   * @returns {number}\n   */\n  static compare(a, b) {\n    // Move peers with no pending tasks to the back of the queue\n    if (a[1]._pending.length === 0) {\n      return 1;\n    }\n    if (b[1]._pending.length === 0) {\n      return -1;\n    }\n\n    // If the amount of active work is the same\n    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n      // Choose the peer with the most pending work\n      return b[1]._pending.length - a[1]._pending.length;\n    }\n\n    // Choose the peer with the least amount of active work (\"keep peers busy\")\n    return a[1]._activeTotalSize - b[1]._activeTotalSize;\n  }\n}\n\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nclass PendingTasks {\n  constructor() {\n    /** @type {SortedMap<string, PendingTask>} */\n    this._tasks = new SortedMap([], this._compare);\n  }\n  get length() {\n    return this._tasks.size;\n  }\n\n  /**\n   * Sum of the size of all pending tasks\n   *\n   * @type {number}\n   **/\n  get totalSize() {\n    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {Task|void}\n   */\n  get(topic) {\n    return (this._tasks.get(topic) || {}).task;\n  }\n\n  /**\n   * @param {Task} task\n   */\n  add(task) {\n    this._tasks.set(task.topic, {\n      created: Date.now(),\n      task\n    });\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {void}\n   */\n  delete(topic) {\n    this._tasks.delete(topic);\n  }\n\n  // All pending tasks, in priority order\n  tasks() {\n    return [...this._tasks.values()].map(i => i.task);\n  }\n\n  /**\n   * Update the priority of the task with the given topic, and update the order\n   *\n   * @param {string} topic\n   * @param {number} priority\n   * @returns {void}\n   **/\n  updatePriority(topic, priority) {\n    const obj = this._tasks.get(topic);\n    if (!obj) {\n      return;\n    }\n    const i = this._tasks.indexOf(topic);\n    obj.task.priority = priority;\n    this._tasks.update(i);\n  }\n\n  /**\n   * Sort by priority desc then FIFO\n   *\n   * @param {[string, PendingTask]} a\n   * @param {[string, PendingTask]} b\n   * @returns {number}\n   * @private\n   */\n  _compare(a, b) {\n    if (a[1].task.priority === b[1].task.priority) {\n      // FIFO\n      return a[1].created - b[1].created;\n    }\n    // Priority high -> low\n    return b[1].task.priority - a[1].task.priority;\n  }\n}","map":{"version":3,"names":["SortedMap","DefaultTaskMerger","hasNewInfo","merge","RequestQueue","constructor","taskMerger","_taskMerger","_byPeer","PeerTasks","compare","pushTasks","peerId","tasks","peerTasks","get","toString","set","popTasks","targetMinBytes","_head","undefined","pendingSize","length","isIdle","delete","update","size","v","remove","topic","tasksDone","i","indexOf","task","taskDone","_activeTotalSize","_pending","PendingTasks","_active","Set","t","_pushTask","_taskHasMoreInfoThanActiveTasks","existingTask","priority","updatePriority","add","tasksWithTopic","activeTask","push","pendingTasks","totalSize","has","a","b","_tasks","_compare","values","reduce","created","Date","now","map","obj"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/decision-engine/req-queue.js"],"sourcesContent":["import { SortedMap } from '../utils/sorted-map.js'\n\n/**\n * @typedef {object} PopTaskResult\n * @property {PeerId} [peerId]\n * @property {Task[]} tasks\n * @property {number} pendingSize\n *\n * @typedef {object} PendingTask\n * @property {number} created\n * @property {Task} task\n *\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMerger\n */\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n *\n * @type {TaskMerger}\n */\nconst DefaultTaskMerger = {\n  hasNewInfo () {\n    return false\n  },\n\n  merge () {}\n}\n\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\nexport class RequestQueue {\n  /**\n   * @param {TaskMerger} [taskMerger]\n   */\n  constructor (taskMerger = DefaultTaskMerger) {\n    this._taskMerger = taskMerger\n    /** @type {SortedMap<string, PeerTasks>} */\n    this._byPeer = new SortedMap([], PeerTasks.compare)\n  }\n\n  /**\n   * Push tasks onto the queue for the given peer\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks (peerId, tasks) {\n    let peerTasks = this._byPeer.get(peerId.toString())\n\n    if (!peerTasks) {\n      peerTasks = new PeerTasks(peerId, this._taskMerger)\n    }\n\n    peerTasks.pushTasks(tasks)\n    this._byPeer.set(peerId.toString(), peerTasks)\n  }\n\n  /**\n   * Choose the peer with the least active work (or if all have the same active\n   * work, the most pending tasks) and pop off the highest priority tasks until\n   * the total size is at least targetMinBytes.\n   * This puts the popped tasks into the \"active\" state, meaning they are\n   * actively being processed (and cannot be modified).\n   *\n   * @param {number} targetMinBytes - the minimum total size of tasks to pop\n   * @returns {PopTaskResult}\n   */\n  popTasks (targetMinBytes) {\n    // Get the queue of tasks for the best peer and pop off tasks up to\n    // targetMinBytes\n    const peerTasks = this._head()\n    if (peerTasks === undefined) {\n      return { tasks: [], pendingSize: 0 }\n    }\n\n    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes)\n    if (tasks.length === 0) {\n      return { tasks, pendingSize }\n    }\n\n    const peerId = peerTasks.peerId\n    if (peerTasks.isIdle()) {\n      // If there are no more tasks for the peer, free up its memory\n      this._byPeer.delete(peerId.toString())\n    } else {\n      // If there are still tasks remaining, update the sort order of peerTasks\n      // (because it depends on the number of pending tasks)\n      this._byPeer.update(0)\n    }\n\n    return {\n      peerId, tasks, pendingSize\n    }\n  }\n\n  /**\n   * @private\n   * @returns {PeerTasks|undefined}\n   */\n  _head () {\n    // Shortcut\n    if (this._byPeer.size === 0) {\n      return undefined\n    }\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [, v] of this._byPeer) {\n      return v\n    }\n\n    return undefined\n  }\n\n  /**\n   * Remove the task with the given topic for the given peer.\n   *\n   * @param {string} topic\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  remove (topic, peerId) {\n    const peerTasks = this._byPeer.get(peerId.toString())\n    peerTasks && peerTasks.remove(topic)\n  }\n\n  /**\n   * Called when the tasks for the given peer complete.\n   *\n   * @param {PeerId} peerId\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  tasksDone (peerId, tasks) {\n    const peerTasks = this._byPeer.get(peerId.toString())\n    if (!peerTasks) {\n      return\n    }\n\n    const i = this._byPeer.indexOf(peerId.toString())\n    for (const task of tasks) {\n      peerTasks.taskDone(task)\n    }\n\n    // Marking the tasks as done takes them out of the \"active\" state, and the\n    // sort order depends on the size of the active tasks, so we need to update\n    // the order.\n    this._byPeer.update(i)\n  }\n}\n\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\nclass PeerTasks {\n  /**\n   * @param {PeerId} peerId\n   * @param {TaskMerger} taskMerger\n   */\n  constructor (peerId, taskMerger) {\n    this.peerId = peerId\n    this._taskMerger = taskMerger\n    this._activeTotalSize = 0\n    this._pending = new PendingTasks()\n    this._active = new Set()\n  }\n\n  /**\n   * Push tasks onto the queue.\n   *\n   * @param {Task[]} tasks\n   * @returns {void}\n   */\n  pushTasks (tasks) {\n    for (const t of tasks) {\n      this._pushTask(t)\n    }\n  }\n\n  /**\n   * @private\n   * @param {Task} task\n   * @returns {void}\n   */\n\n  _pushTask (task) {\n    // If the new task doesn't add any more information over what we\n    // already have in the active queue, then we can skip the new task\n    if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n      return\n    }\n\n    // If there is already a non-active (pending) task with this topic\n    const existingTask = this._pending.get(task.topic)\n    if (existingTask) {\n      // If the new task has a higher priority than the old task,\n      if (task.priority > existingTask.priority) {\n        // Update the priority and the task's position in the queue\n        this._pending.updatePriority(task.topic, task.priority)\n      }\n\n      // Merge the information from the new task into the existing task\n      this._taskMerger.merge(task, existingTask)\n\n      // A task with the topic exists, so we don't need to add\n      // the new task to the queue\n      return\n    }\n\n    // Push the new task onto the queue\n    this._pending.add(task)\n  }\n\n  /**\n   * Indicates whether the new task adds any more information over tasks that are\n   * already in the active task queue\n   *\n   * @private\n   * @param {Task} task\n   * @returns {boolean}\n   */\n  _taskHasMoreInfoThanActiveTasks (task) {\n    const tasksWithTopic = []\n    for (const activeTask of this._active) {\n      if (activeTask.topic === task.topic) {\n        tasksWithTopic.push(activeTask)\n      }\n    }\n\n    // No tasks with that topic, so the new task adds information\n    if (tasksWithTopic.length === 0) {\n      return true\n    }\n\n    return this._taskMerger.hasNewInfo(task, tasksWithTopic)\n  }\n\n  /**\n   * Pop tasks off the queue such that the total size is at least targetMinBytes\n   *\n   * @param {number} targetMinBytes\n   * @returns {PopTaskResult}\n   */\n  popTasks (targetMinBytes) {\n    let size = 0\n    const tasks = []\n\n    // Keep popping tasks until we get up to targetMinBytes (or one item over\n    // targetMinBytes)\n    const pendingTasks = this._pending.tasks()\n    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n      const task = pendingTasks[i]\n      tasks.push(task)\n      size += task.size\n\n      // Move tasks from pending to active\n      this._pending.delete(task.topic)\n      this._activeTotalSize += task.size\n      this._active.add(task)\n    }\n\n    return {\n      tasks, pendingSize: this._pending.totalSize\n    }\n  }\n\n  /**\n   * Called when a task completes.\n   * Note: must be the same reference as returned from popTasks.\n   *\n   * @param {Task} task\n   * @returns {void}\n   */\n  taskDone (task) {\n    if (this._active.has(task)) {\n      this._activeTotalSize -= task.size\n      this._active.delete(task)\n    }\n  }\n\n  /**\n   * Remove pending tasks with the given topic\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n  remove (topic) {\n    this._pending.delete(topic)\n  }\n\n  /**\n   * No work to be done, this PeerTasks object can be freed.\n   *\n   * @returns {boolean}\n   */\n  isIdle () {\n    return this._pending.length === 0 && this._active.size === 0\n  }\n\n  /**\n   * Compare PeerTasks\n   *\n   * @template Key\n   * @param {[Key, PeerTasks]} a\n   * @param {[Key, PeerTasks]} b\n   * @returns {number}\n   */\n  static compare (a, b) {\n    // Move peers with no pending tasks to the back of the queue\n    if (a[1]._pending.length === 0) {\n      return 1\n    }\n    if (b[1]._pending.length === 0) {\n      return -1\n    }\n\n    // If the amount of active work is the same\n    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n      // Choose the peer with the most pending work\n      return b[1]._pending.length - a[1]._pending.length\n    }\n\n    // Choose the peer with the least amount of active work (\"keep peers busy\")\n    return a[1]._activeTotalSize - b[1]._activeTotalSize\n  }\n}\n\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\nclass PendingTasks {\n  constructor () {\n    /** @type {SortedMap<string, PendingTask>} */\n    this._tasks = new SortedMap([], this._compare)\n  }\n\n  get length () {\n    return this._tasks.size\n  }\n\n  /**\n   * Sum of the size of all pending tasks\n   *\n   * @type {number}\n   **/\n  get totalSize () {\n    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0)\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {Task|void}\n   */\n  get (topic) {\n    return (this._tasks.get(topic) || {}).task\n  }\n\n  /**\n   * @param {Task} task\n   */\n  add (task) {\n    this._tasks.set(task.topic, {\n      created: Date.now(),\n      task\n    })\n  }\n\n  /**\n   * @param {string} topic\n   * @returns {void}\n   */\n  delete (topic) {\n    this._tasks.delete(topic)\n  }\n\n  // All pending tasks, in priority order\n  tasks () {\n    return [...this._tasks.values()].map(i => i.task)\n  }\n\n  /**\n   * Update the priority of the task with the given topic, and update the order\n   *\n   * @param {string} topic\n   * @param {number} priority\n   * @returns {void}\n   **/\n  updatePriority (topic, priority) {\n    const obj = this._tasks.get(topic)\n    if (!obj) {\n      return\n    }\n\n    const i = this._tasks.indexOf(topic)\n    obj.task.priority = priority\n    this._tasks.update(i)\n  }\n\n  /**\n   * Sort by priority desc then FIFO\n   *\n   * @param {[string, PendingTask]} a\n   * @param {[string, PendingTask]} b\n   * @returns {number}\n   * @private\n   */\n  _compare (a, b) {\n    if (a[1].task.priority === b[1].task.priority) {\n      // FIFO\n      return a[1].created - b[1].created\n    }\n    // Priority high -> low\n    return b[1].task.priority - a[1].task.priority\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}