{"ast":null,"code":"import errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { IpnsPublisher } from './publisher.js';\nimport { IpnsRepublisher } from './republisher.js';\nimport { IpnsResolver } from './resolver.js';\nimport { TLRU } from '../utils/tlru.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nconst log = logger('ipfs:ipns');\nconst defaultRecordTtl = 60 * 1000;\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport class IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor(routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publish(peerId, value, lifetime = IpnsPublisher.defaultRecordLifetime, options) {\n    try {\n      await this.publisher.publishWithEOL(peerId, value, lifetime, options);\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`);\n\n      // // Add to cache\n      const id = peerId.toString();\n      // @ts-expect-error - parseFloat expects string\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve(name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n      if (result) {\n        return result;\n      }\n    }\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${name} was resolved correctly`);\n      return result;\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  async initializeKeyspace(peerId, value, options) {\n    // eslint-disable-line require-await\n    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options);\n  }\n}","map":{"version":3,"names":["errcode","logger","IpnsPublisher","IpnsRepublisher","IpnsResolver","TLRU","toString","uint8ArrayToString","log","defaultRecordTtl","IPNS","constructor","routing","datastore","peerId","keychain","options","publisher","republisher","resolver","cache","publish","value","lifetime","defaultRecordLifetime","publishWithEOL","id","ttEol","parseFloat","ttl","set","name","err","error","resolve","Error","nocache","recursive","split","result","get","initializeKeyspace"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/index.js"],"sourcesContent":["import errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { IpnsPublisher } from './publisher.js'\nimport { IpnsRepublisher } from './republisher.js'\nimport { IpnsResolver } from './resolver.js'\nimport { TLRU } from '../utils/tlru.js'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst log = logger('ipfs:ipns')\nconst defaultRecordTtl = 60 * 1000\n\n/**\n * @typedef {import('@libp2p/interface-keys').PrivateKey} PrivateKey\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\nexport class IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('@libp2p/interface-keychain').KeyChain} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {AbortOptions} [options]\n   */\n  async publish (peerId, value, lifetime = IpnsPublisher.defaultRecordLifetime, options) {\n    try {\n      await this.publisher.publishWithEOL(peerId, value, lifetime, options)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toString()\n      // @ts-expect-error - parseFloat expects string\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   * @param {AbortSignal} [options.signal]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PeerId} peerId\n   * @param {Uint8Array} value\n   * @param {AbortOptions} [options]\n   */\n  async initializeKeyspace (peerId, value, options) { // eslint-disable-line require-await\n    return this.publish(peerId, value, IpnsPublisher.defaultRecordLifetime, options)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}