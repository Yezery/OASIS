{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport * as ed from '@noble/ed25519';\nconst PUBLIC_KEY_BYTE_LENGTH = 32;\nconst PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32;\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength };\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength };\nexport async function generateKey() {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey();\n  const publicKey = await ed.getPublicKey(privateKeyRaw);\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n}\n/**\n * Generate keypair from a 32 byte uint8array\n */\nexport async function generateKeyFromSeed(seed) {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.');\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n  }\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed;\n  const publicKey = await ed.getPublicKey(privateKeyRaw);\n  const privateKey = concatKeys(privateKeyRaw, publicKey);\n  return {\n    privateKey,\n    publicKey\n  };\n}\nexport async function hashAndSign(privateKey, msg) {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);\n  return ed.sign(msg, privateKeyRaw);\n}\nexport async function hashAndVerify(publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey);\n}\nfunction concatKeys(privateKeyRaw, publicKey) {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i];\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n  }\n  return privateKey;\n}","map":{"version":3,"names":["ed","PUBLIC_KEY_BYTE_LENGTH","PRIVATE_KEY_BYTE_LENGTH","KEYS_BYTE_LENGTH","publicKeyLength","privateKeyLength","generateKey","privateKeyRaw","utils","randomPrivateKey","publicKey","getPublicKey","privateKey","concatKeys","generateKeyFromSeed","seed","length","TypeError","Uint8Array","hashAndSign","msg","subarray","sign","hashAndVerify","sig","verify","i"],"sources":["../../../src/keys/ed25519-browser.ts"],"sourcesContent":[null],"mappings":";;;AAAA,OAAO,KAAKA,EAAE,MAAM,gBAAgB;AAGpC,MAAMC,sBAAsB,GAAG,EAAE;AACjC,MAAMC,uBAAuB,GAAG,EAAE,EAAC;AACnC,MAAMC,gBAAgB,GAAG,EAAE;AAE3B,SAASF,sBAAsB,IAAIG,eAAe;AAClD,SAASF,uBAAuB,IAAIG,gBAAgB;AAEpD,OAAO,eAAeC,WAAWA,CAAA;EAC/B;EACA,MAAMC,aAAa,GAAGP,EAAE,CAACQ,KAAK,CAACC,gBAAgB,EAAE;EACjD,MAAMC,SAAS,GAAG,MAAMV,EAAE,CAACW,YAAY,CAACJ,aAAa,CAAC;EAEtD;EACA,MAAMK,UAAU,GAAGC,UAAU,CAACN,aAAa,EAAEG,SAAS,CAAC;EAEvD,OAAO;IACLE,UAAU;IACVF;GACD;AACH;AAEA;;;AAGA,OAAO,eAAeI,mBAAmBA,CAAEC,IAAgB;EACzD,IAAIA,IAAI,CAACC,MAAM,KAAKb,gBAAgB,EAAE;IACpC,MAAM,IAAIc,SAAS,CAAC,oCAAoC,CAAC;GAC1D,MAAM,IAAI,EAAEF,IAAI,YAAYG,UAAU,CAAC,EAAE;IACxC,MAAM,IAAID,SAAS,CAAC,iDAAiD,CAAC;;EAGxE;EACA,MAAMV,aAAa,GAAGQ,IAAI;EAC1B,MAAML,SAAS,GAAG,MAAMV,EAAE,CAACW,YAAY,CAACJ,aAAa,CAAC;EAEtD,MAAMK,UAAU,GAAGC,UAAU,CAACN,aAAa,EAAEG,SAAS,CAAC;EAEvD,OAAO;IACLE,UAAU;IACVF;GACD;AACH;AAEA,OAAO,eAAeS,WAAWA,CAAEP,UAAsB,EAAEQ,GAAe;EACxE,MAAMb,aAAa,GAAGK,UAAU,CAACS,QAAQ,CAAC,CAAC,EAAElB,gBAAgB,CAAC;EAE9D,OAAOH,EAAE,CAACsB,IAAI,CAACF,GAAG,EAAEb,aAAa,CAAC;AACpC;AAEA,OAAO,eAAegB,aAAaA,CAAEb,SAAqB,EAAEc,GAAe,EAAEJ,GAAe;EAC1F,OAAOpB,EAAE,CAACyB,MAAM,CAACD,GAAG,EAAEJ,GAAG,EAAEV,SAAS,CAAC;AACvC;AAEA,SAASG,UAAUA,CAAEN,aAAyB,EAAEG,SAAqB;EACnE,MAAME,UAAU,GAAG,IAAIM,UAAU,CAAChB,uBAAuB,CAAC;EAC1D,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,gBAAgB,EAAEuB,CAAC,EAAE,EAAE;IACzCd,UAAU,CAACc,CAAC,CAAC,GAAGnB,aAAa,CAACmB,CAAC,CAAC;IAChCd,UAAU,CAACT,gBAAgB,GAAGuB,CAAC,CAAC,GAAGhB,SAAS,CAACgB,CAAC,CAAC;;EAEjD,OAAOd,UAAU;AACnB"},"metadata":{},"sourceType":"module","externalDependencies":[]}