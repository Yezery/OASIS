{"ast":null,"code":"/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix,\n    // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data\n  });\n};\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts\n    }\n  };\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n  let promise;\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n  if (promise) {\n    promise.then(res => {\n      masterSendToWorker(worker, msg, 'resolve', res);\n    }).catch(rejRes => {\n      masterSendToWorker(worker, msg, 'reject', rejRes);\n    });\n  }\n};\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(msg.data.remainingPoints, msg.data.msBeforeNext, msg.data.consumedPoints, msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix\n  };\n};\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs)\n  };\n  return promiseId;\n};\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n    this._rateLimiters = {};\n    cluster.setMaxListeners(0);\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n    masterInstance = this;\n  }\n}\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n    this._rateLimiters = {};\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', packet => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: msgData => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            }\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n    masterInstance = this;\n  }\n}\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n  constructor(opts = {}) {\n    super(opts);\n    process.setMaxListeners(0);\n    this.timeoutMs = opts.timeoutMs;\n    this._initiated = false;\n    process.on('message', msg => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this)\n    });\n    this._promises = {};\n  }\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker\n};","map":{"version":3,"names":["cluster","require","crypto","RateLimiterAbstract","RateLimiterMemory","RateLimiterRes","channel","masterInstance","masterSendToWorker","worker","msg","type","res","data","remainingPoints","msBeforeNext","consumedPoints","isFirstInDuration","send","keyPrefix","promiseId","workerWaitInit","payload","setTimeout","_initiated","process","_promises","call","workerSendToMaster","func","key","arg","opts","masterProcessMsg","_rateLimiters","promise","consume","penalty","reward","block","get","delete","then","catch","rejRes","workerProcessMsg","clearTimeout","timeoutId","resolve","reject","Error","getOpts","points","duration","blockDuration","execEvenly","execEvenlyMinDelayMs","savePromise","hrtime","toString","randomBytes","timeoutMs","RateLimiterClusterMaster","constructor","setMaxListeners","on","RateLimiterClusterMasterPM2","pm2","launchBus","err","pm2Bus","packet","raw","sendDataToProcessId","pm_id","topic","sendErr","console","log","msgData","pm2Message","RateLimiterClusterWorker","_timeoutMs","value","Math","abs","parseInt","pointsToConsume","options","Promise","secDuration","module","exports","RateLimiterCluster"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterCluster.js"],"sourcesContent":["/**\n * Implements rate limiting in cluster using built-in IPC\n *\n * Two classes are described here: master and worker\n * Master have to be create in the master process without any options.\n * Any number of rate limiters can be created in workers, but each rate limiter must be with unique keyPrefix\n *\n * Workflow:\n * 1. master rate limiter created in master process\n * 2. worker rate limiter sends 'init' message with necessary options during creating\n * 3. master receives options and adds new rate limiter by keyPrefix if it isn't created yet\n * 4. master sends 'init' back to worker's rate limiter\n * 5. worker can process requests immediately,\n *    but they will be postponed by 'workerWaitInit' until master sends 'init' to worker\n * 6. every request to worker rate limiter creates a promise\n * 7. if master doesn't response for 'timeout', promise is rejected\n * 8. master sends 'resolve' or 'reject' command to worker\n * 9. worker resolves or rejects promise depending on message from master\n *\n */\n\nconst cluster = require('cluster');\nconst crypto = require('crypto');\nconst RateLimiterAbstract = require('./RateLimiterAbstract');\nconst RateLimiterMemory = require('./RateLimiterMemory');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nconst channel = 'rate_limiter_flexible';\nlet masterInstance = null;\n\nconst masterSendToWorker = function (worker, msg, type, res) {\n  let data;\n  if (res === null || res === true || res === false) {\n    data = res;\n  } else {\n    data = {\n      remainingPoints: res.remainingPoints,\n      msBeforeNext: res.msBeforeNext,\n      consumedPoints: res.consumedPoints,\n      isFirstInDuration: res.isFirstInDuration,\n    };\n  }\n  worker.send({\n    channel,\n    keyPrefix: msg.keyPrefix, // which rate limiter exactly\n    promiseId: msg.promiseId,\n    type,\n    data,\n  });\n};\n\nconst workerWaitInit = function (payload) {\n  setTimeout(() => {\n    if (this._initiated) {\n      process.send(payload);\n      // Promise will be removed by timeout if too long\n    } else if (typeof this._promises[payload.promiseId] !== 'undefined') {\n      workerWaitInit.call(this, payload);\n    }\n  }, 30);\n};\n\nconst workerSendToMaster = function (func, promiseId, key, arg, opts) {\n  const payload = {\n    channel,\n    keyPrefix: this.keyPrefix,\n    func,\n    promiseId,\n    data: {\n      key,\n      arg,\n      opts,\n    },\n  };\n\n  if (!this._initiated) {\n    // Wait init before sending messages to master\n    workerWaitInit.call(this, payload);\n  } else {\n    process.send(payload);\n  }\n};\n\nconst masterProcessMsg = function (worker, msg) {\n  if (!msg || msg.channel !== channel || typeof this._rateLimiters[msg.keyPrefix] === 'undefined') {\n    return false;\n  }\n\n  let promise;\n\n  switch (msg.func) {\n    case 'consume':\n      promise = this._rateLimiters[msg.keyPrefix].consume(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'penalty':\n      promise = this._rateLimiters[msg.keyPrefix].penalty(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'reward':\n      promise = this._rateLimiters[msg.keyPrefix].reward(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'block':\n      promise = this._rateLimiters[msg.keyPrefix].block(msg.data.key, msg.data.arg, msg.data.opts);\n      break;\n    case 'get':\n      promise = this._rateLimiters[msg.keyPrefix].get(msg.data.key, msg.data.opts);\n      break;\n    case 'delete':\n      promise = this._rateLimiters[msg.keyPrefix].delete(msg.data.key, msg.data.opts);\n      break;\n    default:\n      return false;\n  }\n\n  if (promise) {\n    promise\n      .then((res) => {\n        masterSendToWorker(worker, msg, 'resolve', res);\n      })\n      .catch((rejRes) => {\n        masterSendToWorker(worker, msg, 'reject', rejRes);\n      });\n  }\n};\n\nconst workerProcessMsg = function (msg) {\n  if (!msg || msg.channel !== channel || msg.keyPrefix !== this.keyPrefix) {\n    return false;\n  }\n\n  if (this._promises[msg.promiseId]) {\n    clearTimeout(this._promises[msg.promiseId].timeoutId);\n    let res;\n    if (msg.data === null || msg.data === true || msg.data === false) {\n      res = msg.data;\n    } else {\n      res = new RateLimiterRes(\n        msg.data.remainingPoints,\n        msg.data.msBeforeNext,\n        msg.data.consumedPoints,\n        msg.data.isFirstInDuration // eslint-disable-line comma-dangle\n      );\n    }\n\n    switch (msg.type) {\n      case 'resolve':\n        this._promises[msg.promiseId].resolve(res);\n        break;\n      case 'reject':\n        this._promises[msg.promiseId].reject(res);\n        break;\n      default:\n        throw new Error(`RateLimiterCluster: no such message type '${msg.type}'`);\n    }\n\n    delete this._promises[msg.promiseId];\n  }\n};\n/**\n * Prepare options to send to master\n * Master will create rate limiter depending on options\n *\n * @returns {{points: *, duration: *, blockDuration: *, execEvenly: *, execEvenlyMinDelayMs: *, keyPrefix: *}}\n */\nconst getOpts = function () {\n  return {\n    points: this.points,\n    duration: this.duration,\n    blockDuration: this.blockDuration,\n    execEvenly: this.execEvenly,\n    execEvenlyMinDelayMs: this.execEvenlyMinDelayMs,\n    keyPrefix: this.keyPrefix,\n  };\n};\n\nconst savePromise = function (resolve, reject) {\n  const hrtime = process.hrtime();\n  let promiseId = hrtime[0].toString() + hrtime[1].toString();\n\n  if (typeof this._promises[promiseId] !== 'undefined') {\n    promiseId += crypto.randomBytes(12).toString('base64');\n  }\n\n  this._promises[promiseId] = {\n    resolve,\n    reject,\n    timeoutId: setTimeout(() => {\n      delete this._promises[promiseId];\n      reject(new Error('RateLimiterCluster timeout: no answer from master in time'));\n    }, this.timeoutMs),\n  };\n\n  return promiseId;\n};\n\nclass RateLimiterClusterMaster {\n  constructor() {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    cluster.setMaxListeners(0);\n\n    cluster.on('message', (worker, msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init') {\n        // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n        if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n          this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n        }\n\n        worker.send({\n          channel,\n          type: 'init',\n          keyPrefix: msg.opts.keyPrefix,\n        });\n      } else {\n        masterProcessMsg.call(this, worker, msg);\n      }\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterMasterPM2 {\n  constructor(pm2) {\n    if (masterInstance) {\n      return masterInstance;\n    }\n\n    this._rateLimiters = {};\n\n    pm2.launchBus((err, pm2Bus) => {\n      pm2Bus.on('process:msg', (packet) => {\n        const msg = packet.raw;\n        if (msg && msg.channel === channel && msg.type === 'init') {\n          // If init request, check or create rate limiter by key prefix and send 'init' back to worker\n          if (typeof this._rateLimiters[msg.opts.keyPrefix] === 'undefined') {\n            this._rateLimiters[msg.opts.keyPrefix] = new RateLimiterMemory(msg.opts);\n          }\n\n          pm2.sendDataToProcessId(packet.process.pm_id, {\n            data: {},\n            topic: channel,\n            channel,\n            type: 'init',\n            keyPrefix: msg.opts.keyPrefix,\n          }, (sendErr, res) => {\n            if (sendErr) {\n              console.log(sendErr, res);\n            }\n          });\n        } else {\n          const worker = {\n            send: (msgData) => {\n              const pm2Message = msgData;\n              pm2Message.topic = channel;\n              if (typeof pm2Message.data === 'undefined') {\n                pm2Message.data = {};\n              }\n              pm2.sendDataToProcessId(packet.process.pm_id, pm2Message, (sendErr, res) => {\n                if (sendErr) {\n                  console.log(sendErr, res);\n                }\n              });\n            },\n          };\n          masterProcessMsg.call(this, worker, msg);\n        }\n      });\n    });\n\n    masterInstance = this;\n  }\n}\n\nclass RateLimiterClusterWorker extends RateLimiterAbstract {\n  get timeoutMs() {\n    return this._timeoutMs;\n  }\n\n  set timeoutMs(value) {\n    this._timeoutMs = typeof value === 'undefined' ? 5000 : Math.abs(parseInt(value));\n  }\n\n  constructor(opts = {}) {\n    super(opts);\n\n    process.setMaxListeners(0);\n\n    this.timeoutMs = opts.timeoutMs;\n\n    this._initiated = false;\n\n    process.on('message', (msg) => {\n      if (msg && msg.channel === channel && msg.type === 'init' && msg.keyPrefix === this.keyPrefix) {\n        this._initiated = true;\n      } else {\n        workerProcessMsg.call(this, msg);\n      }\n    });\n\n    // Create limiter on master with specific options\n    process.send({\n      channel,\n      type: 'init',\n      opts: getOpts.call(this),\n    });\n\n    this._promises = {};\n  }\n\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'consume', promiseId, key, pointsToConsume, options);\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'penalty', promiseId, key, points, options);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'reward', promiseId, key, points, options);\n    });\n  }\n\n  block(key, secDuration, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'block', promiseId, key, secDuration, options);\n    });\n  }\n\n  get(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'get', promiseId, key, options);\n    });\n  }\n\n  delete(key, options = {}) {\n    return new Promise((resolve, reject) => {\n      const promiseId = savePromise.call(this, resolve, reject);\n\n      workerSendToMaster.call(this, 'delete', promiseId, key, options);\n    });\n  }\n}\n\nmodule.exports = {\n  RateLimiterClusterMaster,\n  RateLimiterClusterMasterPM2,\n  RateLimiterCluster: RateLimiterClusterWorker,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}