{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 0xfa;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 0xfb;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 0x7f800000) >> 23;\n    const mantissa = valu32 & 0x7fffff;\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false);\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, (inp & 0x80000000) >> 16 | mantissa >> 13, false);\n    } else {\n      // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127;\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, (valu32 & 0x80000000) >> 16 | /* sign bit */1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 0x80000000) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 0x7c00) {\n    return Infinity;\n  }\n  if (half === 0xfc00) {\n    return -Infinity;\n  }\n  if (half === 0x7e00) {\n    return NaN;\n  }\n  const exp = half >> 10 & 0x1f;\n  const mant = half & 0x3ff;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n    /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 0x8000 ? -val : val;\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens;\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/","map":{"version":3,"names":["Token","Type","decodeErrPrefix","encodeUint","MINOR_FALSE","MINOR_TRUE","MINOR_NULL","MINOR_UNDEFINED","decodeUndefined","_data","_pos","_minor","options","allowUndefined","Error","coerceUndefinedToNull","null","undefined","decodeBreak","allowIndefinite","break","createToken","value","bytes","allowNaN","Number","isNaN","allowInfinity","Infinity","float","decodeFloat16","data","pos","readFloat16","decodeFloat32","readFloat32","decodeFloat64","readFloat64","encodeFloat","buf","token","push","majorEncoded","decoded","success","float64","encodeFloat16","ui8a","slice","encodeFloat32","encodeFloat64","encodedSize","buffer","ArrayBuffer","dataView","DataView","Uint8Array","inp","setUint16","setFloat32","valu32","getUint32","exponent","mantissa","logicalExponent","length","half","NaN","exp","mant","val","offset","byteOffset","getFloat32","setFloat64","getFloat64","compareTokens"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/7float.js"],"sourcesContent":["// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n"],"mappings":";;;;AAAA;AACA;;AAEA,SAASA,KAAK,EAAEC,IAAI,QAAQ,YAAY;AACxC,SAASC,eAAe,QAAQ,aAAa;AAC7C,SAASC,UAAU,QAAQ,YAAY;;AAEvC;AACA;AACA;AACA;AACA;;AAEA,MAAMC,WAAW,GAAG,EAAE;AACtB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,UAAU,GAAG,EAAE;AACrB,MAAMC,eAAe,GAAG,EAAE;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAAEC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAE;EAC7D,IAAIA,OAAO,CAACC,cAAc,KAAK,KAAK,EAAE;IACpC,MAAM,IAAIC,KAAK,CAAE,GAAEZ,eAAgB,qCAAoC,CAAC;EAC1E,CAAC,MAAM,IAAIU,OAAO,CAACG,qBAAqB,KAAK,IAAI,EAAE;IACjD,OAAO,IAAIf,KAAK,CAACC,IAAI,CAACe,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;EACtC;EACA,OAAO,IAAIhB,KAAK,CAACC,IAAI,CAACgB,SAAS,EAAEA,SAAS,EAAE,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAAET,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAE;EACzD,IAAIA,OAAO,CAACO,eAAe,KAAK,KAAK,EAAE;IACrC,MAAM,IAAIL,KAAK,CAAE,GAAEZ,eAAgB,sCAAqC,CAAC;EAC3E;EACA,OAAO,IAAIF,KAAK,CAACC,IAAI,CAACmB,KAAK,EAAEH,SAAS,EAAE,CAAC,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,WAAWA,CAAEC,KAAK,EAAEC,KAAK,EAAEX,OAAO,EAAE;EAC3C,IAAIA,OAAO,EAAE;IACX,IAAIA,OAAO,CAACY,QAAQ,KAAK,KAAK,IAAIC,MAAM,CAACC,KAAK,CAACJ,KAAK,CAAC,EAAE;MACrD,MAAM,IAAIR,KAAK,CAAE,GAAEZ,eAAgB,+BAA8B,CAAC;IACpE;IACA,IAAIU,OAAO,CAACe,aAAa,KAAK,KAAK,KAAKL,KAAK,KAAKM,QAAQ,IAAIN,KAAK,KAAK,CAACM,QAAQ,CAAC,EAAE;MAClF,MAAM,IAAId,KAAK,CAAE,GAAEZ,eAAgB,oCAAmC,CAAC;IACzE;EACF;EACA,OAAO,IAAIF,KAAK,CAACC,IAAI,CAAC4B,KAAK,EAAEP,KAAK,EAAEC,KAAK,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,aAAaA,CAAEC,IAAI,EAAEC,GAAG,EAAErB,MAAM,EAAEC,OAAO,EAAE;EACzD,OAAOS,WAAW,CAACY,WAAW,CAACF,IAAI,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEpB,OAAO,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsB,aAAaA,CAAEH,IAAI,EAAEC,GAAG,EAAErB,MAAM,EAAEC,OAAO,EAAE;EACzD,OAAOS,WAAW,CAACc,WAAW,CAACJ,IAAI,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEpB,OAAO,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASwB,aAAaA,CAAEL,IAAI,EAAEC,GAAG,EAAErB,MAAM,EAAEC,OAAO,EAAE;EACzD,OAAOS,WAAW,CAACgB,WAAW,CAACN,IAAI,EAAEC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEpB,OAAO,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0B,WAAWA,CAAEC,GAAG,EAAEC,KAAK,EAAE5B,OAAO,EAAE;EAChD,MAAMiB,KAAK,GAAGW,KAAK,CAAClB,KAAK;EAEzB,IAAIO,KAAK,KAAK,KAAK,EAAE;IACnBU,GAAG,CAACE,IAAI,CAAC,CAACxC,IAAI,CAAC4B,KAAK,CAACa,YAAY,GAAGtC,WAAW,CAAC,CAAC;EACnD,CAAC,MAAM,IAAIyB,KAAK,KAAK,IAAI,EAAE;IACzBU,GAAG,CAACE,IAAI,CAAC,CAACxC,IAAI,CAAC4B,KAAK,CAACa,YAAY,GAAGrC,UAAU,CAAC,CAAC;EAClD,CAAC,MAAM,IAAIwB,KAAK,KAAK,IAAI,EAAE;IACzBU,GAAG,CAACE,IAAI,CAAC,CAACxC,IAAI,CAAC4B,KAAK,CAACa,YAAY,GAAGpC,UAAU,CAAC,CAAC;EAClD,CAAC,MAAM,IAAIuB,KAAK,KAAKZ,SAAS,EAAE;IAC9BsB,GAAG,CAACE,IAAI,CAAC,CAACxC,IAAI,CAAC4B,KAAK,CAACa,YAAY,GAAGnC,eAAe,CAAC,CAAC;EACvD,CAAC,MAAM;IACL,IAAIoC,OAAO;IACX,IAAIC,OAAO,GAAG,KAAK;IACnB,IAAI,CAAChC,OAAO,IAAIA,OAAO,CAACiC,OAAO,KAAK,IAAI,EAAE;MACxCC,aAAa,CAACjB,KAAK,CAAC;MACpBc,OAAO,GAAGV,WAAW,CAACc,IAAI,EAAE,CAAC,CAAC;MAC9B,IAAIlB,KAAK,KAAKc,OAAO,IAAIlB,MAAM,CAACC,KAAK,CAACG,KAAK,CAAC,EAAE;QAC5CkB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;QACdR,GAAG,CAACE,IAAI,CAACM,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC1BJ,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM;QACLK,aAAa,CAACpB,KAAK,CAAC;QACpBc,OAAO,GAAGR,WAAW,CAACY,IAAI,EAAE,CAAC,CAAC;QAC9B,IAAIlB,KAAK,KAAKc,OAAO,EAAE;UACrBI,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;UACdR,GAAG,CAACE,IAAI,CAACM,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAC1BJ,OAAO,GAAG,IAAI;QAChB;MACF;IACF;IACA,IAAI,CAACA,OAAO,EAAE;MACZM,aAAa,CAACrB,KAAK,CAAC;MACpBc,OAAO,GAAGN,WAAW,CAACU,IAAI,EAAE,CAAC,CAAC;MAC9BA,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;MACdR,GAAG,CAACE,IAAI,CAACM,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5B;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACAV,WAAW,CAACa,WAAW,GAAG,SAASA,WAAWA,CAAEX,KAAK,EAAE5B,OAAO,EAAE;EAC9D,MAAMiB,KAAK,GAAGW,KAAK,CAAClB,KAAK;EAEzB,IAAIO,KAAK,KAAK,KAAK,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKZ,SAAS,EAAE;IAC9E,OAAO,CAAC;EACV;EAEA,IAAI,CAACL,OAAO,IAAIA,OAAO,CAACiC,OAAO,KAAK,IAAI,EAAE;IACxCC,aAAa,CAACjB,KAAK,CAAC;IACpB,IAAIc,OAAO,GAAGV,WAAW,CAACc,IAAI,EAAE,CAAC,CAAC;IAClC,IAAIlB,KAAK,KAAKc,OAAO,IAAIlB,MAAM,CAACC,KAAK,CAACG,KAAK,CAAC,EAAE;MAC5C,OAAO,CAAC;IACV;IACAoB,aAAa,CAACpB,KAAK,CAAC;IACpBc,OAAO,GAAGR,WAAW,CAACY,IAAI,EAAE,CAAC,CAAC;IAC9B,IAAIlB,KAAK,KAAKc,OAAO,EAAE;MACrB,OAAO,CAAC;IACV;EACF;EACA,OAAO,CAAC;AACV,CAAC;AAED,MAAMS,MAAM,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;AACjC,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAACH,MAAM,EAAE,CAAC,CAAC;AACxC,MAAML,IAAI,GAAG,IAAIS,UAAU,CAACJ,MAAM,EAAE,CAAC,CAAC;;AAEtC;AACA;AACA;AACA,SAASN,aAAaA,CAAEW,GAAG,EAAE;EAC3B,IAAIA,GAAG,KAAK7B,QAAQ,EAAE;IACpB0B,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC;EACtC,CAAC,MAAM,IAAID,GAAG,KAAK,CAAC7B,QAAQ,EAAE;IAC5B0B,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC;EACtC,CAAC,MAAM,IAAIjC,MAAM,CAACC,KAAK,CAAC+B,GAAG,CAAC,EAAE;IAC5BH,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC;EACtC,CAAC,MAAM;IACLJ,QAAQ,CAACK,UAAU,CAAC,CAAC,EAAEF,GAAG,CAAC;IAC3B,MAAMG,MAAM,GAAGN,QAAQ,CAACO,SAAS,CAAC,CAAC,CAAC;IACpC,MAAMC,QAAQ,GAAG,CAACF,MAAM,GAAG,UAAU,KAAK,EAAE;IAC5C,MAAMG,QAAQ,GAAGH,MAAM,GAAG,QAAQ;;IAElC;IACA,IAAIE,QAAQ,KAAK,IAAI,EAAE;MACrB;MACAR,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC;IACtC,CAAC,MAAM,IAAII,QAAQ,KAAK,IAAI,EAAE;MAC5B;MACAR,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAG,CAACD,GAAG,GAAG,UAAU,KAAK,EAAE,GAAKM,QAAQ,IAAI,EAAG,EAAE,KAAK,CAAC;IAC7E,CAAC,MAAM;MAAE;MACP;MACA,MAAMC,eAAe,GAAGF,QAAQ,GAAG,GAAG;MACtC;MACA;MACA,IAAIE,eAAe,GAAG,CAAC,EAAE,EAAE;QACzB;AACR;AACA;QACQ;QACAV,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MAC1B,CAAC,MAAM,IAAIM,eAAe,GAAG,CAAC,EAAE,EAAE;QAChC;AACR;AACA;QACQV,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAG,CAACE,MAAM,GAAG,UAAU,KAAK,EAAE,GAAI,cAAgB,CAAC,IAAK,EAAE,GAAGI,eAAiB,EAAE,KAAK,CAAC;MAC5G,CAAC,MAAM;QACLV,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAG,CAACE,MAAM,GAAG,UAAU,KAAK,EAAE,GAAMI,eAAe,GAAG,EAAE,IAAK,EAAG,GAAID,QAAQ,IAAI,EAAG,EAAE,KAAK,CAAC;MACjH;IACF;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS9B,WAAWA,CAAEc,IAAI,EAAEf,GAAG,EAAE;EAC/B,IAAIe,IAAI,CAACkB,MAAM,GAAGjC,GAAG,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIlB,KAAK,CAAE,GAAEZ,eAAgB,8BAA6B,CAAC;EACnE;EAEA,MAAMgE,IAAI,GAAG,CAACnB,IAAI,CAACf,GAAG,CAAC,IAAI,CAAC,IAAIe,IAAI,CAACf,GAAG,GAAG,CAAC,CAAC;EAC7C,IAAIkC,IAAI,KAAK,MAAM,EAAE;IACnB,OAAOtC,QAAQ;EACjB;EACA,IAAIsC,IAAI,KAAK,MAAM,EAAE;IACnB,OAAO,CAACtC,QAAQ;EAClB;EACA,IAAIsC,IAAI,KAAK,MAAM,EAAE;IACnB,OAAOC,GAAG;EACZ;EACA,MAAMC,GAAG,GAAIF,IAAI,IAAI,EAAE,GAAI,IAAI;EAC/B,MAAMG,IAAI,GAAGH,IAAI,GAAG,KAAK;EACzB,IAAII,GAAG;EACP,IAAIF,GAAG,KAAK,CAAC,EAAE;IACbE,GAAG,GAAGD,IAAI,GAAI,CAAC,IAAI,CAAC,EAAG;EACzB,CAAC,MAAM,IAAID,GAAG,KAAK,EAAE,EAAE;IACrBE,GAAG,GAAG,CAACD,IAAI,GAAG,IAAI,IAAK,CAAC,KAAKD,GAAG,GAAG,EAAE,CAAE;IACzC;EACA,CAAC,MAAM;IACL;IACAE,GAAG,GAAGD,IAAI,KAAK,CAAC,GAAGzC,QAAQ,GAAGuC,GAAG;EACnC;EACA,OAAQD,IAAI,GAAG,MAAM,GAAI,CAACI,GAAG,GAAGA,GAAG;AACrC;;AAEA;AACA;AACA;AACA,SAASrB,aAAaA,CAAEQ,GAAG,EAAE;EAC3BH,QAAQ,CAACK,UAAU,CAAC,CAAC,EAAEF,GAAG,EAAE,KAAK,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAStB,WAAWA,CAAEY,IAAI,EAAEf,GAAG,EAAE;EAC/B,IAAIe,IAAI,CAACkB,MAAM,GAAGjC,GAAG,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIlB,KAAK,CAAE,GAAEZ,eAAgB,8BAA6B,CAAC;EACnE;EACA,MAAMqE,MAAM,GAAG,CAACxB,IAAI,CAACyB,UAAU,IAAI,CAAC,IAAIxC,GAAG;EAC3C,OAAO,IAAIuB,QAAQ,CAACR,IAAI,CAACK,MAAM,EAAEmB,MAAM,EAAE,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC;AAClE;;AAEA;AACA;AACA;AACA,SAASvB,aAAaA,CAAEO,GAAG,EAAE;EAC3BH,QAAQ,CAACoB,UAAU,CAAC,CAAC,EAAEjB,GAAG,EAAE,KAAK,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASpB,WAAWA,CAAEU,IAAI,EAAEf,GAAG,EAAE;EAC/B,IAAIe,IAAI,CAACkB,MAAM,GAAGjC,GAAG,GAAG,CAAC,EAAE;IACzB,MAAM,IAAIlB,KAAK,CAAE,GAAEZ,eAAgB,8BAA6B,CAAC;EACnE;EACA,MAAMqE,MAAM,GAAG,CAACxB,IAAI,CAACyB,UAAU,IAAI,CAAC,IAAIxC,GAAG;EAC3C,OAAO,IAAIuB,QAAQ,CAACR,IAAI,CAACK,MAAM,EAAEmB,MAAM,EAAE,CAAC,CAAC,CAACI,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACArC,WAAW,CAACsC,aAAa,GAAGzE,UAAU,CAACyE,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}