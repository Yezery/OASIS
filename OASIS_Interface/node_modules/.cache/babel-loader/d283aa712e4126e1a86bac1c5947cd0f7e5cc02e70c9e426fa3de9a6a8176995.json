{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'EuclideanNorm':\n      return [tfOps.euclideanNorm(getParamValue('x', node, tensorMap, context), getParamValue('axis', node, tensorMap, context), getParamValue('keepDims', node, tensorMap, context))];\n    case 'FusedBatchNorm':\n    case 'FusedBatchNormV2':\n      {\n        return [tfOps.batchNorm(getParamValue('x', node, tensorMap, context), getParamValue('mean', node, tensorMap, context), getParamValue('variance', node, tensorMap, context), getParamValue('offset', node, tensorMap, context), getParamValue('scale', node, tensorMap, context), getParamValue('epsilon', node, tensorMap, context))];\n      }\n    case 'FusedBatchNormV3':\n      {\n        return [tfOps.batchNorm(getParamValue('x', node, tensorMap, context), getParamValue('mean', node, tensorMap, context), getParamValue('variance', node, tensorMap, context), getParamValue('offset', node, tensorMap, context), getParamValue('scale', node, tensorMap, context), getParamValue('epsilon', node, tensorMap, context))];\n      }\n    case 'LRN':\n      {\n        return [tfOps.localResponseNormalization(getParamValue('x', node, tensorMap, context), getParamValue('radius', node, tensorMap, context), getParamValue('bias', node, tensorMap, context), getParamValue('alpha', node, tensorMap, context), getParamValue('beta', node, tensorMap, context))];\n      }\n    case 'Softmax':\n      {\n        return [tfOps.softmax(getParamValue('x', node, tensorMap, context))];\n      }\n    case 'LogSoftmax':\n      {\n        return [tfOps.logSoftmax(getParamValue('x', node, tensorMap, context))];\n      }\n    case 'SparseToDense':\n      {\n        return [tfOps.sparseToDense(getParamValue('sparseIndices', node, tensorMap, context), getParamValue('outputShape', node, tensorMap, context), getParamValue('sparseValues', node, tensorMap, context), getParamValue('defaultValue', node, tensorMap, context))];\n      }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'normalization';","map":{"version":3,"names":["tfOps","getParamValue","executeOp","node","tensorMap","context","op","euclideanNorm","batchNorm","localResponseNormalization","softmax","logSoftmax","sparseToDense","TypeError","CATEGORY"],"sources":["../../../../../../../tfjs-converter/src/operations/executors/normalization_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor3D, Tensor4D} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext): Tensor[] => {\n      switch (node.op) {\n        case 'EuclideanNorm':\n          return [tfOps.euclideanNorm(\n              getParamValue('x', node, tensorMap, context) as Tensor,\n              getParamValue('axis', node, tensorMap, context) as number[],\n              getParamValue('keepDims', node, tensorMap, context) as boolean)];\n        case 'FusedBatchNorm':\n        case 'FusedBatchNormV2': {\n          return [tfOps.batchNorm(\n              getParamValue('x', node, tensorMap, context) as Tensor,\n              getParamValue('mean', node, tensorMap, context) as Tensor,\n              getParamValue('variance', node, tensorMap, context) as Tensor,\n              getParamValue('offset', node, tensorMap, context) as Tensor,\n              getParamValue('scale', node, tensorMap, context) as Tensor,\n              getParamValue('epsilon', node, tensorMap, context) as number)];\n        }\n        case 'FusedBatchNormV3': {\n          return [tfOps.batchNorm(\n              getParamValue('x', node, tensorMap, context) as Tensor,\n              getParamValue('mean', node, tensorMap, context) as Tensor,\n              getParamValue('variance', node, tensorMap, context) as Tensor,\n              getParamValue('offset', node, tensorMap, context) as Tensor,\n              getParamValue('scale', node, tensorMap, context) as Tensor,\n              getParamValue('epsilon', node, tensorMap, context) as number)];\n        }\n        case 'LRN': {\n          return [tfOps.localResponseNormalization(\n              getParamValue('x', node, tensorMap, context) as Tensor3D |\n                  Tensor4D,\n              getParamValue('radius', node, tensorMap, context) as number,\n              getParamValue('bias', node, tensorMap, context) as number,\n              getParamValue('alpha', node, tensorMap, context) as number,\n              getParamValue('beta', node, tensorMap, context) as number)];\n        }\n        case 'Softmax': {\n          return [tfOps.softmax(\n              getParamValue('x', node, tensorMap, context) as Tensor)];\n        }\n        case 'LogSoftmax': {\n          return [tfOps.logSoftmax(\n              getParamValue('x', node, tensorMap, context) as Tensor)];\n        }\n        case 'SparseToDense': {\n          return [tfOps.sparseToDense(\n              getParamValue('sparseIndices', node, tensorMap, context) as\n                  Tensor,\n              getParamValue('outputShape', node, tensorMap, context) as Tensor,\n              getParamValue('sparseValues', node, tensorMap, context) as\n                  number[],\n              getParamValue('defaultValue', node, tensorMap, context) as\n                  Scalar)];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'normalization';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}