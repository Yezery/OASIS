{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport { asU8A, fromString } from '../byte-utils.js';\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = [];\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          // >first\n          buf.push([44]); // ','\n        }\n      }\n\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          // >first\n          if (recurs.elements % 2 === 1) {\n            // key\n            buf.push([44]); // ','\n          } else {\n            buf.push([58]); // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major](buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token);\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]); // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]); // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major](_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]); // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]); // '}'\n          /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]); // 'true'\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]); // 'false'\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]); // 'null'\n      return;\n    }\n\n    // number\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        // '[.eE]'\n        dp = true;\n      }\n    }\n    if (!dp) {\n      // need a decimal point for floats\n      isa.push(46); // '.'\n      isa.push(48); // '0'\n    }\n\n    buf.push(isa);\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport { encode };","map":{"version":3,"names":["Type","encodeCustom","encodeErrPrefix","asU8A","fromString","JSONEncoder","Array","constructor","inRecursive","prefix","buf","recurs","length","type","array","elements","push","map","uint","major","token","is","String","value","isa","i","charCodeAt","negint","bytes","_buf","_token","Error","string","byts","JSON","stringify","tag","float","name","pop","undefined","dp","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","Object","assign"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/json/encode.js"],"sourcesContent":["import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}