{"ast":null,"code":"/*! multi-integer-range (c) 2015 Soichiro Miki */\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar MultiRange = function () {\n  /**\n   * Creates a new MultiRange object.\n   */\n  function MultiRange(data) {\n    function isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    }\n    this.ranges = [];\n    if (typeof data === 'string') {\n      this.parseString(data);\n    } else if (typeof data === 'number') {\n      this.appendRange(data, data);\n    } else if (data instanceof MultiRange) {\n      this.ranges = data.getRanges();\n    } else if (isArray(data)) {\n      for (var _i = 0, _a = data; _i < _a.length; _i++) {\n        var item = _a[_i];\n        if (isArray(item)) {\n          if (item.length === 2) {\n            this.appendRange(item[0], item[1]);\n          } else {\n            throw new TypeError('Invalid array initializer');\n          }\n        } else if (typeof item === 'number') {\n          this.append(item);\n        } else {\n          throw new TypeError('Invalid array initialzer');\n        }\n      }\n    } else if (data !== undefined) {\n      throw new TypeError('Invalid input');\n    }\n  }\n  /**\n   * Parses the initialize string and build the range data.\n   * Override this if you need to customize the parsing strategy.\n   */\n  MultiRange.prototype.parseString = function (data) {\n    function toInt(str) {\n      var m = str.match(/^\\(?(\\-?\\d+)/);\n      return parseInt(m[1], 10);\n    }\n    var s = data.replace(/\\s/g, '');\n    if (!s.length) return;\n    var match;\n    for (var _i = 0, _a = s.split(','); _i < _a.length; _i++) {\n      var r = _a[_i];\n      if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))$/)) {\n        var val = toInt(match[1]);\n        this.appendRange(val, val);\n      } else if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))?\\-(\\d+|\\(\\-?\\d+\\))?$/)) {\n        var min = match[1] === undefined ? -Infinity : toInt(match[1]);\n        var max = match[2] === undefined ? +Infinity : toInt(match[2]);\n        this.appendRange(min, max);\n      } else {\n        throw new SyntaxError('Invalid input');\n      }\n    }\n    ;\n  };\n  /**\n   * Clones this instance.\n   */\n  MultiRange.prototype.clone = function () {\n    return new MultiRange(this);\n  };\n  /**\n   * Appends to this instance.\n   * @parasm value The data to append.\n   */\n  MultiRange.prototype.append = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.appendRange(r[0], r[1]);\n      }\n      return this;\n    } else {\n      return this.append(new MultiRange(value));\n    }\n  };\n  /**\n   * Appends a specified range of integers to this isntance.\n   * @param min The minimum value of the range to append.\n   * @param max The minimum value of the range to append.\n   */\n  MultiRange.prototype.appendRange = function (min, max) {\n    var newRange = [min, max];\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n    if (newRange[0] === Infinity && newRange[1] === Infinity || newRange[0] === -Infinity && newRange[1] === -Infinity) {\n      throw new RangeError('Infinity can be used only within an unbounded range segment');\n    }\n    var overlap = this.findOverlap(newRange);\n    this.ranges.splice(overlap.lo, overlap.count, overlap.union);\n    return this;\n  };\n  /**\n   * Subtracts from this instance.\n   * @param value The data to subtract.\n   */\n  MultiRange.prototype.subtract = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var r = _a[_i];\n        this.subtractRange(r[0], r[1]);\n      }\n      return this;\n    } else {\n      return this.subtract(new MultiRange(value));\n    }\n  };\n  /**\n   * Subtracts a specified range of integers from this instance.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   */\n  MultiRange.prototype.subtractRange = function (min, max) {\n    var newRange = [min, max];\n    if (newRange[0] > newRange[1]) {\n      newRange = [newRange[1], newRange[0]];\n    }\n    var overlap = this.findOverlap(newRange);\n    if (overlap.count > 0) {\n      var remain = [];\n      if (this.ranges[overlap.lo][0] < newRange[0]) {\n        remain.push([this.ranges[overlap.lo][0], newRange[0] - 1]);\n      }\n      if (newRange[1] < this.ranges[overlap.lo + overlap.count - 1][1]) {\n        remain.push([newRange[1] + 1, this.ranges[overlap.lo + overlap.count - 1][1]]);\n      }\n      this.ranges.splice.apply(this.ranges, [overlap.lo, overlap.count].concat(remain));\n    }\n    return this;\n  };\n  /**\n   * Remove integers which are not included in the given ranges (aka intersection).\n   * @param value The data to calculate the intersetion.\n   */\n  MultiRange.prototype.intersect = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var result = [];\n      var jstart = 0; // used for optimization\n      for (var i = 0; i < this.ranges.length; i++) {\n        var r1 = this.ranges[i];\n        for (var j = jstart; j < value.ranges.length; j++) {\n          var r2 = value.ranges[j];\n          if (r1[0] <= r2[1] && r1[1] >= r2[0]) {\n            jstart = j;\n            var min = Math.max(r1[0], r2[0]);\n            var max = Math.min(r1[1], r2[1]);\n            result.push([min, max]);\n          } else if (r1[1] < r2[0]) {\n            break;\n          }\n        }\n      }\n      this.ranges = result;\n      return this;\n    } else {\n      return this.intersect(new MultiRange(value));\n    }\n  };\n  /**\n   * Determines how the given range overlaps or touches the existing ranges.\n   * This is a helper method that calculates how an append/subtract operation\n   * affects the existing range members.\n   * @param target The range array to test.\n   * @return An object containing information about how the given range\n   * overlaps or touches this instance.\n   */\n  MultiRange.prototype.findOverlap = function (target) {\n    //   a        b  c     d         e  f       g h i   j k  l       m\n    //--------------------------------------------------------------------\n    //   |----(0)----|     |---(1)---|  |---(2)---|          |--(3)--|\n    //            |------------(A)--------------|\n    //                                            |-(B)-|\n    //                                              |-(C)-|\n    //\n    // (0)-(3) represent the existing ranges (this.ranges),\n    // and (A)-(C) are the ranges being passed to this function.\n    //\n    // A pseudocode findOverlap(A) returns { lo: 0, count: 3, union: <a-h> },\n    // meaning (A) overlaps the 3 existing ranges from index 0.\n    //\n    // findOverlap(B) returns { lo: 2, count: 1, union: <f-j> },\n    // meaning (B) \"touches\" one range element, (2).\n    //\n    // findOverlap(C) returns { lo: 3, count: 0, union: <i-k> }\n    // meaning (C) is between (2) and (3) but overlaps/touches neither of them.\n    for (var hi = this.ranges.length - 1; hi >= 0; hi--) {\n      var r = this.ranges[hi];\n      var union = void 0;\n      if (union = this.calcUnion(r, target)) {\n        var count = 1;\n        var tmp = void 0;\n        while (hi - count >= 0 && (tmp = this.calcUnion(union, this.ranges[hi - count]))) {\n          union = tmp;\n          count++;\n        }\n        // The given target touches or overlaps one or more of the existing ranges\n        return {\n          lo: hi + 1 - count,\n          count: count,\n          union: union\n        };\n      } else if (r[1] < target[0]) {\n        // The given target does not touch nor overlap the existing ranges\n        return {\n          lo: hi + 1,\n          count: 0,\n          union: target\n        };\n      }\n    }\n    // The given target is smaller than the smallest existing range\n    return {\n      lo: 0,\n      count: 0,\n      union: target\n    };\n  };\n  /**\n   * Calculates the union of two specified ranges.\n   * @param a Range A\n   * @param b Range B\n   * @return Union of a and b. Null if a and b do not touch nor intersect.\n   */\n  MultiRange.prototype.calcUnion = function (a, b) {\n    if (a[1] + 1 < b[0] || a[0] - 1 > b[1]) {\n      return null; // cannot make union\n    }\n\n    return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\n  };\n  /**\n   * Exports the whole range data as an array of arrays.\n   */\n  MultiRange.prototype.getRanges = function () {\n    var result = [];\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result.push([r[0], r[1]]);\n    }\n    return result;\n  };\n  /**\n   * Checks if the instance contains the specified value.\n   * @param value Value to be checked\n   * @return True if the specified value is included in the instance.\n   */\n  MultiRange.prototype.has = function (value) {\n    if (value === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (value instanceof MultiRange) {\n      var s = 0;\n      var len = this.ranges.length;\n      for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n        var tr = _a[_i];\n        var i = void 0;\n        for (i = s; i < len; i++) {\n          var my = this.ranges[i];\n          if (tr[0] >= my[0] && tr[1] <= my[1] && tr[1] >= my[0] && tr[1] <= my[1]) break;\n        }\n        if (i === len) return false;\n      }\n      return true;\n    } else {\n      return this.has(new MultiRange(value));\n    }\n  };\n  /**\n   * Checks if the instance contains the range specified by the two parameters.\n   * @param min The minimum value of the range to subtract.\n   * @param max The minimum value of the range to subtract.\n   * @return True if the specified value is included in the instance.\n   */\n  MultiRange.prototype.hasRange = function (min, max) {\n    return this.has(new MultiRange([[min, max]]));\n  };\n  /**\n   * Returns the number of range segments.\n   * For example, the segmentLength of `2-5,7,9-11' is 3.\n   * Returns 0 for an empty instance.\n   * @return The number of segments.\n   */\n  MultiRange.prototype.segmentLength = function () {\n    return this.ranges.length;\n  };\n  /**\n   * Calculates how many numbers are effectively included in this instance.\n   * (i.e. '1-10,51-60,90' returns 21)\n   * @return The number of integer values in this instance.\n   *    Returns `Infinity` for unbounded ranges.\n   */\n  MultiRange.prototype.length = function () {\n    if (this.isUnbounded()) return Infinity;\n    var result = 0;\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      result += r[1] - r[0] + 1;\n    }\n    return result;\n  };\n  /**\n   * Checks if two instances of MultiRange are identical.\n   * @param cmp The data to compare.\n   * @return True if cmp is exactly the same as this instance.\n   */\n  MultiRange.prototype.equals = function (cmp) {\n    if (cmp === undefined) {\n      throw new TypeError('Invalid input');\n    } else if (cmp instanceof MultiRange) {\n      if (cmp === this) return true;\n      if (this.ranges.length !== cmp.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (this.ranges[i][0] !== cmp.ranges[i][0] || this.ranges[i][1] !== cmp.ranges[i][1]) return false;\n      }\n      return true;\n    } else {\n      return this.equals(new MultiRange(cmp));\n    }\n  };\n  /**\n   * Checks if the current instance is unbounded (i.e., infinite).\n   */\n  MultiRange.prototype.isUnbounded = function () {\n    return this.ranges.length > 0 && (this.ranges[0][0] === -Infinity || this.ranges[this.ranges.length - 1][1] === Infinity);\n  };\n  /**\n   * Returns the minimum number contained in this insntance. Can be -Infinity or undefined.\n   */\n  MultiRange.prototype.min = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[0][0];\n  };\n  /**\n   * Returns the maximum number contained in this insntance. Can be +Infinity or undefined.\n   */\n  MultiRange.prototype.max = function () {\n    if (this.ranges.length === 0) return undefined;\n    return this.ranges[this.ranges.length - 1][1];\n  };\n  /**\n   * Removes the smallest integer from this instance and returns that integer.\n   */\n  MultiRange.prototype.shift = function () {\n    var min = this.min();\n    if (min === -Infinity) throw new RangeError('shift() was invoked on an unbounded MultiRange which contains -Infinity');\n    if (min !== undefined) this.subtract(min);\n    return min;\n  };\n  /**\n   * Removes the largest integer from this instance and returns that integer.\n   */\n  MultiRange.prototype.pop = function () {\n    var max = this.max();\n    if (max === Infinity) throw new RangeError('pop() was invoked on an unbounded MultiRange which contains +Infinity');\n    if (max !== undefined) this.subtract(max);\n    return max;\n  };\n  /**\n   * Returns the string respresentation of this MultiRange.\n   */\n  MultiRange.prototype.toString = function () {\n    function wrap(i) {\n      return i >= 0 ? String(i) : \"(\" + i + \")\";\n    }\n    var ranges = [];\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      if (r[0] === -Infinity) {\n        if (r[1] === Infinity) {\n          ranges.push('-');\n        } else {\n          ranges.push(\"-\" + wrap(r[1]));\n        }\n      } else if (r[1] === Infinity) {\n        ranges.push(wrap(r[0]) + \"-\");\n      } else if (r[0] == r[1]) {\n        ranges.push(wrap(r[0]));\n      } else {\n        ranges.push(wrap(r[0]) + \"-\" + wrap(r[1]));\n      }\n    }\n    return ranges.join(',');\n  };\n  /**\n   * Builds an array of integer which holds all elements in this MultiRange.\n   * Note that this may be slow and memory-consuming for large ranges such as '1-10000'.\n   */\n  MultiRange.prototype.toArray = function () {\n    if (this.isUnbounded()) {\n      throw new RangeError('You cannot build an array from an unbounded range');\n    }\n    var result = new Array(this.length());\n    var idx = 0;\n    for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n      var r = _a[_i];\n      for (var n = r[0]; n <= r[1]; n++) {\n        result[idx++] = n;\n      }\n    }\n    return result;\n  };\n  /**\n   * Returns ES6-compatible iterator.\n   */\n  MultiRange.prototype.getIterator = function () {\n    var _this = this;\n    if (this.isUnbounded()) {\n      throw new RangeError('Unbounded ranges cannot be iterated over');\n    }\n    var i = 0,\n      curRange = this.ranges[i],\n      j = curRange ? curRange[0] : undefined;\n    return {\n      next: function () {\n        if (!curRange) return {\n          done: true\n        };\n        var ret = j;\n        if (++j > curRange[1]) {\n          curRange = _this.ranges[++i];\n          j = curRange ? curRange[0] : undefined;\n        }\n        return {\n          value: ret\n        };\n      }\n    };\n  };\n  return MultiRange;\n}();\nexports.MultiRange = MultiRange;\n// Set ES6 iterator, if Symbol.iterator is defined\n/* istanbul ignore else */\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  MultiRange.prototype[Symbol.iterator] = MultiRange.prototype.getIterator;\n}\n// A shorthand function to get a new MultiRange instance\nfunction multirange(data) {\n  return new MultiRange(data);\n}\nexports.multirange = multirange;","map":{"version":3,"names":["require","MultiRange","data","isArray","x","Object","prototype","toString","call","ranges","parseString","appendRange","getRanges","_i","_a","length","item","TypeError","append","undefined","toInt","str","m","match","parseInt","s","replace","split","r","val","min","Infinity","max","SyntaxError","clone","value","newRange","RangeError","overlap","findOverlap","splice","lo","count","union","subtract","subtractRange","remain","push","apply","concat","intersect","result","jstart","i","r1","j","r2","Math","target","hi","calcUnion","tmp","a","b","has","len","tr","my","hasRange","segmentLength","isUnbounded","equals","cmp","shift","pop","wrap","String","join","toArray","Array","idx","n","getIterator","_this","curRange","next","done","ret","exports","Symbol","iterator","multirange"],"sources":["/Users/yezery/Documents/大学素材/毕业设计/OASIS/OASIS_Interface/node_modules/.store/multi-integer-range@3.0.0/node_modules/multi-integer-range/lib/multi-integer-range.js"],"sourcesContent":["/*! multi-integer-range (c) 2015 Soichiro Miki */\n\"use strict\";\nvar MultiRange = (function () {\n    /**\n     * Creates a new MultiRange object.\n     */\n    function MultiRange(data) {\n        function isArray(x) {\n            return Object.prototype.toString.call(x) === '[object Array]';\n        }\n        this.ranges = [];\n        if (typeof data === 'string') {\n            this.parseString(data);\n        }\n        else if (typeof data === 'number') {\n            this.appendRange(data, data);\n        }\n        else if (data instanceof MultiRange) {\n            this.ranges = data.getRanges();\n        }\n        else if (isArray(data)) {\n            for (var _i = 0, _a = data; _i < _a.length; _i++) {\n                var item = _a[_i];\n                if (isArray(item)) {\n                    if (item.length === 2) {\n                        this.appendRange(item[0], item[1]);\n                    }\n                    else {\n                        throw new TypeError('Invalid array initializer');\n                    }\n                }\n                else if (typeof item === 'number') {\n                    this.append(item);\n                }\n                else {\n                    throw new TypeError('Invalid array initialzer');\n                }\n            }\n        }\n        else if (data !== undefined) {\n            throw new TypeError('Invalid input');\n        }\n    }\n    /**\n     * Parses the initialize string and build the range data.\n     * Override this if you need to customize the parsing strategy.\n     */\n    MultiRange.prototype.parseString = function (data) {\n        function toInt(str) {\n            var m = str.match(/^\\(?(\\-?\\d+)/);\n            return parseInt(m[1], 10);\n        }\n        var s = data.replace(/\\s/g, '');\n        if (!s.length)\n            return;\n        var match;\n        for (var _i = 0, _a = s.split(','); _i < _a.length; _i++) {\n            var r = _a[_i];\n            if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))$/)) {\n                var val = toInt(match[1]);\n                this.appendRange(val, val);\n            }\n            else if (match = r.match(/^(\\d+|\\(\\-?\\d+\\))?\\-(\\d+|\\(\\-?\\d+\\))?$/)) {\n                var min = match[1] === undefined ? -Infinity : toInt(match[1]);\n                var max = match[2] === undefined ? +Infinity : toInt(match[2]);\n                this.appendRange(min, max);\n            }\n            else {\n                throw new SyntaxError('Invalid input');\n            }\n        }\n        ;\n    };\n    /**\n     * Clones this instance.\n     */\n    MultiRange.prototype.clone = function () {\n        return new MultiRange(this);\n    };\n    /**\n     * Appends to this instance.\n     * @parasm value The data to append.\n     */\n    MultiRange.prototype.append = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var r = _a[_i];\n                this.appendRange(r[0], r[1]);\n            }\n            return this;\n        }\n        else {\n            return this.append(new MultiRange(value));\n        }\n    };\n    /**\n     * Appends a specified range of integers to this isntance.\n     * @param min The minimum value of the range to append.\n     * @param max The minimum value of the range to append.\n     */\n    MultiRange.prototype.appendRange = function (min, max) {\n        var newRange = [min, max];\n        if (newRange[0] > newRange[1]) {\n            newRange = [newRange[1], newRange[0]];\n        }\n        if (newRange[0] === Infinity && newRange[1] === Infinity ||\n            newRange[0] === -Infinity && newRange[1] === -Infinity) {\n            throw new RangeError('Infinity can be used only within an unbounded range segment');\n        }\n        var overlap = this.findOverlap(newRange);\n        this.ranges.splice(overlap.lo, overlap.count, overlap.union);\n        return this;\n    };\n    /**\n     * Subtracts from this instance.\n     * @param value The data to subtract.\n     */\n    MultiRange.prototype.subtract = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var r = _a[_i];\n                this.subtractRange(r[0], r[1]);\n            }\n            return this;\n        }\n        else {\n            return this.subtract(new MultiRange(value));\n        }\n    };\n    /**\n     * Subtracts a specified range of integers from this instance.\n     * @param min The minimum value of the range to subtract.\n     * @param max The minimum value of the range to subtract.\n     */\n    MultiRange.prototype.subtractRange = function (min, max) {\n        var newRange = [min, max];\n        if (newRange[0] > newRange[1]) {\n            newRange = [newRange[1], newRange[0]];\n        }\n        var overlap = this.findOverlap(newRange);\n        if (overlap.count > 0) {\n            var remain = [];\n            if (this.ranges[overlap.lo][0] < newRange[0]) {\n                remain.push([this.ranges[overlap.lo][0], newRange[0] - 1]);\n            }\n            if (newRange[1] < this.ranges[overlap.lo + overlap.count - 1][1]) {\n                remain.push([newRange[1] + 1, this.ranges[overlap.lo + overlap.count - 1][1]]);\n            }\n            this.ranges.splice.apply(this.ranges, [overlap.lo, overlap.count].concat(remain));\n        }\n        return this;\n    };\n    /**\n     * Remove integers which are not included in the given ranges (aka intersection).\n     * @param value The data to calculate the intersetion.\n     */\n    MultiRange.prototype.intersect = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            var result = [];\n            var jstart = 0; // used for optimization\n            for (var i = 0; i < this.ranges.length; i++) {\n                var r1 = this.ranges[i];\n                for (var j = jstart; j < value.ranges.length; j++) {\n                    var r2 = value.ranges[j];\n                    if (r1[0] <= r2[1] && r1[1] >= r2[0]) {\n                        jstart = j;\n                        var min = Math.max(r1[0], r2[0]);\n                        var max = Math.min(r1[1], r2[1]);\n                        result.push([min, max]);\n                    }\n                    else if (r1[1] < r2[0]) {\n                        break;\n                    }\n                }\n            }\n            this.ranges = result;\n            return this;\n        }\n        else {\n            return this.intersect(new MultiRange(value));\n        }\n    };\n    /**\n     * Determines how the given range overlaps or touches the existing ranges.\n     * This is a helper method that calculates how an append/subtract operation\n     * affects the existing range members.\n     * @param target The range array to test.\n     * @return An object containing information about how the given range\n     * overlaps or touches this instance.\n     */\n    MultiRange.prototype.findOverlap = function (target) {\n        //   a        b  c     d         e  f       g h i   j k  l       m\n        //--------------------------------------------------------------------\n        //   |----(0)----|     |---(1)---|  |---(2)---|          |--(3)--|\n        //            |------------(A)--------------|\n        //                                            |-(B)-|\n        //                                              |-(C)-|\n        //\n        // (0)-(3) represent the existing ranges (this.ranges),\n        // and (A)-(C) are the ranges being passed to this function.\n        //\n        // A pseudocode findOverlap(A) returns { lo: 0, count: 3, union: <a-h> },\n        // meaning (A) overlaps the 3 existing ranges from index 0.\n        //\n        // findOverlap(B) returns { lo: 2, count: 1, union: <f-j> },\n        // meaning (B) \"touches\" one range element, (2).\n        //\n        // findOverlap(C) returns { lo: 3, count: 0, union: <i-k> }\n        // meaning (C) is between (2) and (3) but overlaps/touches neither of them.\n        for (var hi = this.ranges.length - 1; hi >= 0; hi--) {\n            var r = this.ranges[hi];\n            var union = void 0;\n            if (union = this.calcUnion(r, target)) {\n                var count = 1;\n                var tmp = void 0;\n                while ((hi - count >= 0) && (tmp = this.calcUnion(union, this.ranges[hi - count]))) {\n                    union = tmp;\n                    count++;\n                }\n                // The given target touches or overlaps one or more of the existing ranges\n                return { lo: hi + 1 - count, count: count, union: union };\n            }\n            else if (r[1] < target[0]) {\n                // The given target does not touch nor overlap the existing ranges\n                return { lo: hi + 1, count: 0, union: target };\n            }\n        }\n        // The given target is smaller than the smallest existing range\n        return { lo: 0, count: 0, union: target };\n    };\n    /**\n     * Calculates the union of two specified ranges.\n     * @param a Range A\n     * @param b Range B\n     * @return Union of a and b. Null if a and b do not touch nor intersect.\n     */\n    MultiRange.prototype.calcUnion = function (a, b) {\n        if (a[1] + 1 < b[0] || a[0] - 1 > b[1]) {\n            return null; // cannot make union\n        }\n        return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\n    };\n    /**\n     * Exports the whole range data as an array of arrays.\n     */\n    MultiRange.prototype.getRanges = function () {\n        var result = [];\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            result.push([r[0], r[1]]);\n        }\n        return result;\n    };\n    /**\n     * Checks if the instance contains the specified value.\n     * @param value Value to be checked\n     * @return True if the specified value is included in the instance.\n     */\n    MultiRange.prototype.has = function (value) {\n        if (value === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (value instanceof MultiRange) {\n            var s = 0;\n            var len = this.ranges.length;\n            for (var _i = 0, _a = value.ranges; _i < _a.length; _i++) {\n                var tr = _a[_i];\n                var i = void 0;\n                for (i = s; i < len; i++) {\n                    var my = this.ranges[i];\n                    if (tr[0] >= my[0] && tr[1] <= my[1] && tr[1] >= my[0] && tr[1] <= my[1])\n                        break;\n                }\n                if (i === len)\n                    return false;\n            }\n            return true;\n        }\n        else {\n            return this.has(new MultiRange(value));\n        }\n    };\n    /**\n     * Checks if the instance contains the range specified by the two parameters.\n     * @param min The minimum value of the range to subtract.\n     * @param max The minimum value of the range to subtract.\n     * @return True if the specified value is included in the instance.\n     */\n    MultiRange.prototype.hasRange = function (min, max) {\n        return this.has(new MultiRange([[min, max]]));\n    };\n    /**\n     * Returns the number of range segments.\n     * For example, the segmentLength of `2-5,7,9-11' is 3.\n     * Returns 0 for an empty instance.\n     * @return The number of segments.\n     */\n    MultiRange.prototype.segmentLength = function () {\n        return this.ranges.length;\n    };\n    /**\n     * Calculates how many numbers are effectively included in this instance.\n     * (i.e. '1-10,51-60,90' returns 21)\n     * @return The number of integer values in this instance.\n     *    Returns `Infinity` for unbounded ranges.\n     */\n    MultiRange.prototype.length = function () {\n        if (this.isUnbounded())\n            return Infinity;\n        var result = 0;\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            result += r[1] - r[0] + 1;\n        }\n        return result;\n    };\n    /**\n     * Checks if two instances of MultiRange are identical.\n     * @param cmp The data to compare.\n     * @return True if cmp is exactly the same as this instance.\n     */\n    MultiRange.prototype.equals = function (cmp) {\n        if (cmp === undefined) {\n            throw new TypeError('Invalid input');\n        }\n        else if (cmp instanceof MultiRange) {\n            if (cmp === this)\n                return true;\n            if (this.ranges.length !== cmp.ranges.length)\n                return false;\n            for (var i = 0; i < this.ranges.length; i++) {\n                if (this.ranges[i][0] !== cmp.ranges[i][0] || this.ranges[i][1] !== cmp.ranges[i][1])\n                    return false;\n            }\n            return true;\n        }\n        else {\n            return this.equals(new MultiRange(cmp));\n        }\n    };\n    /**\n     * Checks if the current instance is unbounded (i.e., infinite).\n     */\n    MultiRange.prototype.isUnbounded = function () {\n        return (this.ranges.length > 0\n            && (this.ranges[0][0] === -Infinity ||\n                this.ranges[this.ranges.length - 1][1] === Infinity));\n    };\n    /**\n     * Returns the minimum number contained in this insntance. Can be -Infinity or undefined.\n     */\n    MultiRange.prototype.min = function () {\n        if (this.ranges.length === 0)\n            return undefined;\n        return this.ranges[0][0];\n    };\n    /**\n     * Returns the maximum number contained in this insntance. Can be +Infinity or undefined.\n     */\n    MultiRange.prototype.max = function () {\n        if (this.ranges.length === 0)\n            return undefined;\n        return this.ranges[this.ranges.length - 1][1];\n    };\n    /**\n     * Removes the smallest integer from this instance and returns that integer.\n     */\n    MultiRange.prototype.shift = function () {\n        var min = this.min();\n        if (min === -Infinity)\n            throw new RangeError('shift() was invoked on an unbounded MultiRange which contains -Infinity');\n        if (min !== undefined)\n            this.subtract(min);\n        return min;\n    };\n    /**\n     * Removes the largest integer from this instance and returns that integer.\n     */\n    MultiRange.prototype.pop = function () {\n        var max = this.max();\n        if (max === Infinity)\n            throw new RangeError('pop() was invoked on an unbounded MultiRange which contains +Infinity');\n        if (max !== undefined)\n            this.subtract(max);\n        return max;\n    };\n    /**\n     * Returns the string respresentation of this MultiRange.\n     */\n    MultiRange.prototype.toString = function () {\n        function wrap(i) {\n            return (i >= 0 ? String(i) : \"(\" + i + \")\");\n        }\n        var ranges = [];\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            if (r[0] === -Infinity) {\n                if (r[1] === Infinity) {\n                    ranges.push('-');\n                }\n                else {\n                    ranges.push(\"-\" + wrap(r[1]));\n                }\n            }\n            else if (r[1] === Infinity) {\n                ranges.push(wrap(r[0]) + \"-\");\n            }\n            else if (r[0] == r[1]) {\n                ranges.push(wrap(r[0]));\n            }\n            else {\n                ranges.push(wrap(r[0]) + \"-\" + wrap(r[1]));\n            }\n        }\n        return ranges.join(',');\n    };\n    /**\n     * Builds an array of integer which holds all elements in this MultiRange.\n     * Note that this may be slow and memory-consuming for large ranges such as '1-10000'.\n     */\n    MultiRange.prototype.toArray = function () {\n        if (this.isUnbounded()) {\n            throw new RangeError('You cannot build an array from an unbounded range');\n        }\n        var result = new Array(this.length());\n        var idx = 0;\n        for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n            var r = _a[_i];\n            for (var n = r[0]; n <= r[1]; n++) {\n                result[idx++] = n;\n            }\n        }\n        return result;\n    };\n    /**\n     * Returns ES6-compatible iterator.\n     */\n    MultiRange.prototype.getIterator = function () {\n        var _this = this;\n        if (this.isUnbounded()) {\n            throw new RangeError('Unbounded ranges cannot be iterated over');\n        }\n        var i = 0, curRange = this.ranges[i], j = curRange ? curRange[0] : undefined;\n        return {\n            next: function () {\n                if (!curRange)\n                    return { done: true };\n                var ret = j;\n                if (++j > curRange[1]) {\n                    curRange = _this.ranges[++i];\n                    j = curRange ? curRange[0] : undefined;\n                }\n                return { value: ret };\n            }\n        };\n    };\n    return MultiRange;\n}());\nexports.MultiRange = MultiRange;\n// Set ES6 iterator, if Symbol.iterator is defined\n/* istanbul ignore else */\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n    MultiRange.prototype[Symbol.iterator] = MultiRange.prototype.getIterator;\n}\n// A shorthand function to get a new MultiRange instance\nfunction multirange(data) {\n    return new MultiRange(data);\n}\nexports.multirange = multirange;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}