{"ast":null,"code":"import DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\n\n/**\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {(source: AsyncIterable<InProgressImportResult>, blockstore: Blockstore, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder\n */\n\n/**\n * @param {InProgressImportResult} elem\n * @param {Dir} tree\n * @param {ImporterOptions} options\n */\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n  return tree;\n}\n\n/**\n * @param {Dir | InProgressImportResult} tree\n * @param {Blockstore} blockstore\n */\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n    return;\n  }\n  yield* tree.flush(blockstore);\n}\n\n/**\n * @type {TreeBuilder}\n */\nasync function* treeBuilder(source, block, options) {\n  /** @type {Dir} */\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n    tree = await addToTree(entry, tree, options);\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\nexport default treeBuilder;","map":{"version":3,"names":["DirFlat","flatToShard","Dir","toPathComponents","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","undefined","size","put","shardSplitThreshold","dir","get","root","parentKey","flat","mtime","unixfs","mode","flushAndYield","blockstore","isDirectory","flush","treeBuilder","source","block","entry","wrapWithDirectory","unwrapped","eachChildSeries","child"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-importer@12.0.1/node_modules/ipfs-unixfs-importer/src/tree-builder.js"],"sourcesContent":["import DirFlat from './dir-flat.js'\nimport flatToShard from './flat-to-shard.js'\nimport Dir from './dir.js'\nimport toPathComponents from './utils/to-path-components.js'\n\n/**\n * @typedef {import('./types').ImportResult} ImportResult\n * @typedef {import('./types').InProgressImportResult} InProgressImportResult\n * @typedef {import('./types').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {(source: AsyncIterable<InProgressImportResult>, blockstore: Blockstore, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder\n */\n\n/**\n * @param {InProgressImportResult} elem\n * @param {Dir} tree\n * @param {ImporterOptions} options\n */\nasync function addToTree (elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = undefined\n    parent.size = undefined\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\n/**\n * @param {Dir | InProgressImportResult} tree\n * @param {Blockstore} blockstore\n */\nasync function * flushAndYield (tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(blockstore)\n}\n\n/**\n * @type {TreeBuilder}\n */\nasync function * treeBuilder (source, block, options) {\n  /** @type {Dir} */\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options)\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue\n    }\n\n    tree = await addToTree(entry, tree, options)\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry\n    }\n  }\n\n  if (options.wrapWithDirectory) {\n    yield * flushAndYield(tree, block)\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue\n      }\n\n      yield * flushAndYield(unwrapped.child, block)\n    }\n  }\n}\n\nexport default treeBuilder\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}