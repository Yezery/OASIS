{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set();\n  const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n  let initNodeNames = [];\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const frontier = [];\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n  const seen = new Set();\n  const orderedNodes = [];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n  return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nconst DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nconst HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"names":["parseNodeName","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","map","name","initNodeNames","node","frontier","length","pop","isControlFlow","isDynamicShape","isHashTable","children","child","filter","has","add","indexOf","push","forEach","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","weights","weight","orderedNodes","every","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"sources":["../../../../../../tfjs-converter/src/executor/model_analysis.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      Object.keys(inputs).map(name => parseNodeName(name)[0]);\n\n  let initNodeNames: string[] = [];\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, weightMap: NamedTensorsMap,\n    executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const frontier: Node[] = [];\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n  const seen = new Set<string>();\n  const orderedNodes: Node[] = [];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) &&\n          child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n  return orderedNodes;\n}\n\nconst CONTROL_FLOW_OPS = [\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nconst HASH_TABLE_OPS = [\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n];\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}