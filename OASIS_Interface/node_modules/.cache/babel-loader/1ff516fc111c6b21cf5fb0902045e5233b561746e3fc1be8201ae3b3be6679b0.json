{"ast":null,"code":"/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign';\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign';\nexport var TopicValidatorResult;\n(function (TopicValidatorResult) {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  TopicValidatorResult[\"Accept\"] = \"accept\";\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  TopicValidatorResult[\"Ignore\"] = \"ignore\";\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  TopicValidatorResult[\"Reject\"] = \"reject\";\n})(TopicValidatorResult || (TopicValidatorResult = {}));","map":{"version":3,"names":["StrictSign","StrictNoSign","TopicValidatorResult"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"AAMA;;;;;;;;AAQA,OAAO,MAAMA,UAAU,GAAG,YAAY;AAEtC;;;;;;;;;;AAUA,OAAO,MAAMC,YAAY,GAAG,cAAc;AA6G1C,WAAYC,oBAaX;AAbD,WAAYA,oBAAoB;EAC9B;;;EAGAA,oBAAA,qBAAiB;EACjB;;;EAGAA,oBAAA,qBAAiB;EACjB;;;EAGAA,oBAAA,qBAAiB;AACnB,CAAC,EAbWA,oBAAoB,KAApBA,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}