{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js';\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256;\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    /** @type {number} */\n    this.cursor = 0;\n    /** @type {number} */\n    this.maxCursor = -1;\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = [];\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos);\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0);\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}","map":{"version":3,"names":["alloc","concat","slice","defaultChunkSize","Bl","constructor","chunkSize","cursor","maxCursor","chunks","_initReuseChunk","reset","length","push","bytes","topChunk","newMax","chunkPos","set","subarray","toBytes","byts","chunk"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/cborg@4.0.3/node_modules/cborg/lib/bl.js"],"sourcesContent":["/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}