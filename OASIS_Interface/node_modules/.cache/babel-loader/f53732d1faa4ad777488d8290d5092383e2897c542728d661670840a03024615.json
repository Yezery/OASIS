{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\nexport const Addresses = $root.Addresses = (() => {\n  /**\n   * Properties of an Addresses.\n   * @exports IAddresses\n   * @interface IAddresses\n   * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs\n   * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord\n   */\n\n  /**\n   * Constructs a new Addresses.\n   * @exports Addresses\n   * @classdesc Represents an Addresses.\n   * @implements IAddresses\n   * @constructor\n   * @param {IAddresses=} [p] Properties to set\n   */\n  function Addresses(p) {\n    this.addrs = [];\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n\n  /**\n   * Addresses addrs.\n   * @member {Array.<Addresses.IAddress>} addrs\n   * @memberof Addresses\n   * @instance\n   */\n  Addresses.prototype.addrs = $util.emptyArray;\n\n  /**\n   * Addresses certifiedRecord.\n   * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord\n   * @memberof Addresses\n   * @instance\n   */\n  Addresses.prototype.certifiedRecord = null;\n\n  /**\n   * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.\n   * @function encode\n   * @memberof Addresses\n   * @static\n   * @param {IAddresses} m Addresses message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Addresses.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    if (m.addrs != null && m.addrs.length) {\n      for (var i = 0; i < m.addrs.length; ++i) $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();\n    }\n    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, \"certifiedRecord\")) $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();\n    return w;\n  };\n\n  /**\n   * Decodes an Addresses message from the specified reader or buffer.\n   * @function decode\n   * @memberof Addresses\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {Addresses} Addresses\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Addresses.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n      m = new $root.Addresses();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n        case 1:\n          if (!(m.addrs && m.addrs.length)) m.addrs = [];\n          m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));\n          break;\n        case 2:\n          m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());\n          break;\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n    return m;\n  };\n\n  /**\n   * Creates an Addresses message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Addresses\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {Addresses} Addresses\n   */\n  Addresses.fromObject = function fromObject(d) {\n    if (d instanceof $root.Addresses) return d;\n    var m = new $root.Addresses();\n    if (d.addrs) {\n      if (!Array.isArray(d.addrs)) throw TypeError(\".Addresses.addrs: array expected\");\n      m.addrs = [];\n      for (var i = 0; i < d.addrs.length; ++i) {\n        if (typeof d.addrs[i] !== \"object\") throw TypeError(\".Addresses.addrs: object expected\");\n        m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);\n      }\n    }\n    if (d.certifiedRecord != null) {\n      if (typeof d.certifiedRecord !== \"object\") throw TypeError(\".Addresses.certifiedRecord: object expected\");\n      m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);\n    }\n    return m;\n  };\n\n  /**\n   * Creates a plain object from an Addresses message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Addresses\n   * @static\n   * @param {Addresses} m Addresses\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Addresses.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n    if (o.arrays || o.defaults) {\n      d.addrs = [];\n    }\n    if (o.defaults) {\n      d.certifiedRecord = null;\n    }\n    if (m.addrs && m.addrs.length) {\n      d.addrs = [];\n      for (var j = 0; j < m.addrs.length; ++j) {\n        d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);\n      }\n    }\n    if (m.certifiedRecord != null && m.hasOwnProperty(\"certifiedRecord\")) {\n      d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);\n    }\n    return d;\n  };\n\n  /**\n   * Converts this Addresses to JSON.\n   * @function toJSON\n   * @memberof Addresses\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Addresses.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  Addresses.Address = function () {\n    /**\n     * Properties of an Address.\n     * @memberof Addresses\n     * @interface IAddress\n     * @property {Uint8Array|null} [multiaddr] Address multiaddr\n     * @property {boolean|null} [isCertified] Address isCertified\n     */\n\n    /**\n     * Constructs a new Address.\n     * @memberof Addresses\n     * @classdesc Represents an Address.\n     * @implements IAddress\n     * @constructor\n     * @param {Addresses.IAddress=} [p] Properties to set\n     */\n    function Address(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Address multiaddr.\n     * @member {Uint8Array} multiaddr\n     * @memberof Addresses.Address\n     * @instance\n     */\n    Address.prototype.multiaddr = $util.newBuffer([]);\n\n    /**\n     * Address isCertified.\n     * @member {boolean|null|undefined} isCertified\n     * @memberof Addresses.Address\n     * @instance\n     */\n    Address.prototype.isCertified = null;\n\n    // OneOf field names bound to virtual getters and setters\n    let $oneOfFields;\n\n    /**\n     * Address _isCertified.\n     * @member {\"isCertified\"|undefined} _isCertified\n     * @memberof Addresses.Address\n     * @instance\n     */\n    Object.defineProperty(Address.prototype, \"_isCertified\", {\n      get: $util.oneOfGetter($oneOfFields = [\"isCertified\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n\n    /**\n     * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.IAddress} m Address message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Address.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\")) w.uint32(10).bytes(m.multiaddr);\n      if (m.isCertified != null && Object.hasOwnProperty.call(m, \"isCertified\")) w.uint32(16).bool(m.isCertified);\n      return w;\n    };\n\n    /**\n     * Decodes an Address message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.Address\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.Address} Address\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Address.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Addresses.Address();\n      while (r.pos < c) {\n        var t = r.uint32();\n        switch (t >>> 3) {\n          case 1:\n            m.multiaddr = r.bytes();\n            break;\n          case 2:\n            m.isCertified = r.bool();\n            break;\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n      return m;\n    };\n\n    /**\n     * Creates an Address message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.Address} Address\n     */\n    Address.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.Address) return d;\n      var m = new $root.Addresses.Address();\n      if (d.multiaddr != null) {\n        if (typeof d.multiaddr === \"string\") $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);else if (d.multiaddr.length) m.multiaddr = d.multiaddr;\n      }\n      if (d.isCertified != null) {\n        m.isCertified = Boolean(d.isCertified);\n      }\n      return m;\n    };\n\n    /**\n     * Creates a plain object from an Address message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.Address\n     * @static\n     * @param {Addresses.Address} m Address\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Address.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n      if (o.defaults) {\n        if (o.bytes === String) d.multiaddr = \"\";else {\n          d.multiaddr = [];\n          if (o.bytes !== Array) d.multiaddr = $util.newBuffer(d.multiaddr);\n        }\n      }\n      if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n      }\n      if (m.isCertified != null && m.hasOwnProperty(\"isCertified\")) {\n        d.isCertified = m.isCertified;\n        if (o.oneofs) d._isCertified = \"isCertified\";\n      }\n      return d;\n    };\n\n    /**\n     * Converts this Address to JSON.\n     * @function toJSON\n     * @memberof Addresses.Address\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Address.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return Address;\n  }();\n  Addresses.CertifiedRecord = function () {\n    /**\n     * Properties of a CertifiedRecord.\n     * @memberof Addresses\n     * @interface ICertifiedRecord\n     * @property {number|null} [seq] CertifiedRecord seq\n     * @property {Uint8Array|null} [raw] CertifiedRecord raw\n     */\n\n    /**\n     * Constructs a new CertifiedRecord.\n     * @memberof Addresses\n     * @classdesc Represents a CertifiedRecord.\n     * @implements ICertifiedRecord\n     * @constructor\n     * @param {Addresses.ICertifiedRecord=} [p] Properties to set\n     */\n    function CertifiedRecord(p) {\n      if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * CertifiedRecord seq.\n     * @member {number} seq\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n    CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n\n    /**\n     * CertifiedRecord raw.\n     * @member {Uint8Array} raw\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     */\n    CertifiedRecord.prototype.raw = $util.newBuffer([]);\n\n    /**\n     * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    CertifiedRecord.encode = function encode(m, w) {\n      if (!w) w = $Writer.create();\n      if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\")) w.uint32(8).uint64(m.seq);\n      if (m.raw != null && Object.hasOwnProperty.call(m, \"raw\")) w.uint32(18).bytes(m.raw);\n      return w;\n    };\n\n    /**\n     * Decodes a CertifiedRecord message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CertifiedRecord.decode = function decode(r, l) {\n      if (!(r instanceof $Reader)) r = $Reader.create(r);\n      var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.Addresses.CertifiedRecord();\n      while (r.pos < c) {\n        var t = r.uint32();\n        switch (t >>> 3) {\n          case 1:\n            m.seq = r.uint64();\n            break;\n          case 2:\n            m.raw = r.bytes();\n            break;\n          default:\n            r.skipType(t & 7);\n            break;\n        }\n      }\n      return m;\n    };\n\n    /**\n     * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses.CertifiedRecord} CertifiedRecord\n     */\n    CertifiedRecord.fromObject = function fromObject(d) {\n      if (d instanceof $root.Addresses.CertifiedRecord) return d;\n      var m = new $root.Addresses.CertifiedRecord();\n      if (d.seq != null) {\n        if ($util.Long) (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;else if (typeof d.seq === \"string\") m.seq = parseInt(d.seq, 10);else if (typeof d.seq === \"number\") m.seq = d.seq;else if (typeof d.seq === \"object\") m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n      }\n      if (d.raw != null) {\n        if (typeof d.raw === \"string\") $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);else if (d.raw.length) m.raw = d.raw;\n      }\n      return m;\n    };\n\n    /**\n     * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses.CertifiedRecord\n     * @static\n     * @param {Addresses.CertifiedRecord} m CertifiedRecord\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    CertifiedRecord.toObject = function toObject(m, o) {\n      if (!o) o = {};\n      var d = {};\n      if (o.defaults) {\n        if ($util.Long) {\n          var n = new $util.Long(0, 0, true);\n          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n        } else d.seq = o.longs === String ? \"0\" : 0;\n        if (o.bytes === String) d.raw = \"\";else {\n          d.raw = [];\n          if (o.bytes !== Array) d.raw = $util.newBuffer(d.raw);\n        }\n      }\n      if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n        if (typeof m.seq === \"number\") d.seq = o.longs === String ? String(m.seq) : m.seq;else d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n      }\n      if (m.raw != null && m.hasOwnProperty(\"raw\")) {\n        d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;\n      }\n      return d;\n    };\n\n    /**\n     * Converts this CertifiedRecord to JSON.\n     * @function toJSON\n     * @memberof Addresses.CertifiedRecord\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    CertifiedRecord.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return CertifiedRecord;\n  }();\n  return Addresses;\n})();\nexport { $root as default };","map":{"version":3,"names":["$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Addresses","p","addrs","ks","Object","keys","i","length","prototype","emptyArray","certifiedRecord","encode","m","w","create","Address","uint32","fork","ldelim","hasOwnProperty","call","CertifiedRecord","decode","r","l","c","undefined","len","pos","t","push","skipType","fromObject","d","Array","isArray","TypeError","toObject","o","arrays","defaults","j","toJSON","constructor","toJSONOptions","multiaddr","newBuffer","isCertified","$oneOfFields","defineProperty","get","oneOfGetter","set","oneOfSetter","bytes","bool","base64","Boolean","String","slice","oneofs","_isCertified","seq","Long","fromBits","raw","uint64","fromValue","unsigned","parseInt","LongBits","low","high","toNumber","n","longs","toString","Number","default"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/migrations/migration-12/pb/address-book.js"],"sourcesContent":["/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const Addresses = $root.Addresses = (() => {\n\n    /**\n     * Properties of an Addresses.\n     * @exports IAddresses\n     * @interface IAddresses\n     * @property {Array.<Addresses.IAddress>|null} [addrs] Addresses addrs\n     * @property {Addresses.ICertifiedRecord|null} [certifiedRecord] Addresses certifiedRecord\n     */\n\n    /**\n     * Constructs a new Addresses.\n     * @exports Addresses\n     * @classdesc Represents an Addresses.\n     * @implements IAddresses\n     * @constructor\n     * @param {IAddresses=} [p] Properties to set\n     */\n    function Addresses(p) {\n        this.addrs = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Addresses addrs.\n     * @member {Array.<Addresses.IAddress>} addrs\n     * @memberof Addresses\n     * @instance\n     */\n    Addresses.prototype.addrs = $util.emptyArray;\n\n    /**\n     * Addresses certifiedRecord.\n     * @member {Addresses.ICertifiedRecord|null|undefined} certifiedRecord\n     * @memberof Addresses\n     * @instance\n     */\n    Addresses.prototype.certifiedRecord = null;\n\n    /**\n     * Encodes the specified Addresses message. Does not implicitly {@link Addresses.verify|verify} messages.\n     * @function encode\n     * @memberof Addresses\n     * @static\n     * @param {IAddresses} m Addresses message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Addresses.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.addrs != null && m.addrs.length) {\n            for (var i = 0; i < m.addrs.length; ++i)\n                $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();\n        }\n        if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, \"certifiedRecord\"))\n            $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes an Addresses message from the specified reader or buffer.\n     * @function decode\n     * @memberof Addresses\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Addresses} Addresses\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Addresses.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                if (!(m.addrs && m.addrs.length))\n                    m.addrs = [];\n                m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));\n                break;\n            case 2:\n                m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates an Addresses message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Addresses\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Addresses} Addresses\n     */\n    Addresses.fromObject = function fromObject(d) {\n        if (d instanceof $root.Addresses)\n            return d;\n        var m = new $root.Addresses();\n        if (d.addrs) {\n            if (!Array.isArray(d.addrs))\n                throw TypeError(\".Addresses.addrs: array expected\");\n            m.addrs = [];\n            for (var i = 0; i < d.addrs.length; ++i) {\n                if (typeof d.addrs[i] !== \"object\")\n                    throw TypeError(\".Addresses.addrs: object expected\");\n                m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);\n            }\n        }\n        if (d.certifiedRecord != null) {\n            if (typeof d.certifiedRecord !== \"object\")\n                throw TypeError(\".Addresses.certifiedRecord: object expected\");\n            m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an Addresses message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Addresses\n     * @static\n     * @param {Addresses} m Addresses\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Addresses.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.addrs = [];\n        }\n        if (o.defaults) {\n            d.certifiedRecord = null;\n        }\n        if (m.addrs && m.addrs.length) {\n            d.addrs = [];\n            for (var j = 0; j < m.addrs.length; ++j) {\n                d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);\n            }\n        }\n        if (m.certifiedRecord != null && m.hasOwnProperty(\"certifiedRecord\")) {\n            d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Addresses to JSON.\n     * @function toJSON\n     * @memberof Addresses\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Addresses.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    Addresses.Address = (function() {\n\n        /**\n         * Properties of an Address.\n         * @memberof Addresses\n         * @interface IAddress\n         * @property {Uint8Array|null} [multiaddr] Address multiaddr\n         * @property {boolean|null} [isCertified] Address isCertified\n         */\n\n        /**\n         * Constructs a new Address.\n         * @memberof Addresses\n         * @classdesc Represents an Address.\n         * @implements IAddress\n         * @constructor\n         * @param {Addresses.IAddress=} [p] Properties to set\n         */\n        function Address(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * Address multiaddr.\n         * @member {Uint8Array} multiaddr\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Address.prototype.multiaddr = $util.newBuffer([]);\n\n        /**\n         * Address isCertified.\n         * @member {boolean|null|undefined} isCertified\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Address.prototype.isCertified = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * Address _isCertified.\n         * @member {\"isCertified\"|undefined} _isCertified\n         * @memberof Addresses.Address\n         * @instance\n         */\n        Object.defineProperty(Address.prototype, \"_isCertified\", {\n            get: $util.oneOfGetter($oneOfFields = [\"isCertified\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified Address message. Does not implicitly {@link Addresses.Address.verify|verify} messages.\n         * @function encode\n         * @memberof Addresses.Address\n         * @static\n         * @param {Addresses.IAddress} m Address message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Address.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.multiaddr != null && Object.hasOwnProperty.call(m, \"multiaddr\"))\n                w.uint32(10).bytes(m.multiaddr);\n            if (m.isCertified != null && Object.hasOwnProperty.call(m, \"isCertified\"))\n                w.uint32(16).bool(m.isCertified);\n            return w;\n        };\n\n        /**\n         * Decodes an Address message from the specified reader or buffer.\n         * @function decode\n         * @memberof Addresses.Address\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {Addresses.Address} Address\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Address.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.Address();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.multiaddr = r.bytes();\n                    break;\n                case 2:\n                    m.isCertified = r.bool();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates an Address message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Addresses.Address\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {Addresses.Address} Address\n         */\n        Address.fromObject = function fromObject(d) {\n            if (d instanceof $root.Addresses.Address)\n                return d;\n            var m = new $root.Addresses.Address();\n            if (d.multiaddr != null) {\n                if (typeof d.multiaddr === \"string\")\n                    $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);\n                else if (d.multiaddr.length)\n                    m.multiaddr = d.multiaddr;\n            }\n            if (d.isCertified != null) {\n                m.isCertified = Boolean(d.isCertified);\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from an Address message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Addresses.Address\n         * @static\n         * @param {Addresses.Address} m Address\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Address.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.defaults) {\n                if (o.bytes === String)\n                    d.multiaddr = \"\";\n                else {\n                    d.multiaddr = [];\n                    if (o.bytes !== Array)\n                        d.multiaddr = $util.newBuffer(d.multiaddr);\n                }\n            }\n            if (m.multiaddr != null && m.hasOwnProperty(\"multiaddr\")) {\n                d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;\n            }\n            if (m.isCertified != null && m.hasOwnProperty(\"isCertified\")) {\n                d.isCertified = m.isCertified;\n                if (o.oneofs)\n                    d._isCertified = \"isCertified\";\n            }\n            return d;\n        };\n\n        /**\n         * Converts this Address to JSON.\n         * @function toJSON\n         * @memberof Addresses.Address\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Address.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Address;\n    })();\n\n    Addresses.CertifiedRecord = (function() {\n\n        /**\n         * Properties of a CertifiedRecord.\n         * @memberof Addresses\n         * @interface ICertifiedRecord\n         * @property {number|null} [seq] CertifiedRecord seq\n         * @property {Uint8Array|null} [raw] CertifiedRecord raw\n         */\n\n        /**\n         * Constructs a new CertifiedRecord.\n         * @memberof Addresses\n         * @classdesc Represents a CertifiedRecord.\n         * @implements ICertifiedRecord\n         * @constructor\n         * @param {Addresses.ICertifiedRecord=} [p] Properties to set\n         */\n        function CertifiedRecord(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * CertifiedRecord seq.\n         * @member {number} seq\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         */\n        CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * CertifiedRecord raw.\n         * @member {Uint8Array} raw\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         */\n        CertifiedRecord.prototype.raw = $util.newBuffer([]);\n\n        /**\n         * Encodes the specified CertifiedRecord message. Does not implicitly {@link Addresses.CertifiedRecord.verify|verify} messages.\n         * @function encode\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Addresses.ICertifiedRecord} m CertifiedRecord message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CertifiedRecord.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.seq != null && Object.hasOwnProperty.call(m, \"seq\"))\n                w.uint32(8).uint64(m.seq);\n            if (m.raw != null && Object.hasOwnProperty.call(m, \"raw\"))\n                w.uint32(18).bytes(m.raw);\n            return w;\n        };\n\n        /**\n         * Decodes a CertifiedRecord message from the specified reader or buffer.\n         * @function decode\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {Addresses.CertifiedRecord} CertifiedRecord\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CertifiedRecord.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.CertifiedRecord();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.seq = r.uint64();\n                    break;\n                case 2:\n                    m.raw = r.bytes();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates a CertifiedRecord message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {Addresses.CertifiedRecord} CertifiedRecord\n         */\n        CertifiedRecord.fromObject = function fromObject(d) {\n            if (d instanceof $root.Addresses.CertifiedRecord)\n                return d;\n            var m = new $root.Addresses.CertifiedRecord();\n            if (d.seq != null) {\n                if ($util.Long)\n                    (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;\n                else if (typeof d.seq === \"string\")\n                    m.seq = parseInt(d.seq, 10);\n                else if (typeof d.seq === \"number\")\n                    m.seq = d.seq;\n                else if (typeof d.seq === \"object\")\n                    m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);\n            }\n            if (d.raw != null) {\n                if (typeof d.raw === \"string\")\n                    $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);\n                else if (d.raw.length)\n                    m.raw = d.raw;\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from a CertifiedRecord message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Addresses.CertifiedRecord\n         * @static\n         * @param {Addresses.CertifiedRecord} m CertifiedRecord\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CertifiedRecord.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.defaults) {\n                if ($util.Long) {\n                    var n = new $util.Long(0, 0, true);\n                    d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n                } else\n                    d.seq = o.longs === String ? \"0\" : 0;\n                if (o.bytes === String)\n                    d.raw = \"\";\n                else {\n                    d.raw = [];\n                    if (o.bytes !== Array)\n                        d.raw = $util.newBuffer(d.raw);\n                }\n            }\n            if (m.seq != null && m.hasOwnProperty(\"seq\")) {\n                if (typeof m.seq === \"number\")\n                    d.seq = o.longs === String ? String(m.seq) : m.seq;\n                else\n                    d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;\n            }\n            if (m.raw != null && m.hasOwnProperty(\"raw\")) {\n                d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;\n            }\n            return d;\n        };\n\n        /**\n         * Converts this CertifiedRecord to JSON.\n         * @function toJSON\n         * @memberof Addresses.CertifiedRecord\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CertifiedRecord.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CertifiedRecord;\n    })();\n\n    return Addresses;\n})();\n\nexport { $root as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}