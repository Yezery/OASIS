{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport batch from 'it-batch';\n\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('../../types').ImporterOptions} ImporterOptions\n * @typedef {import('../../types').InProgressImportResult} InProgressImportResult\n * @typedef {import('../../types').TrickleDagNode} TrickleDagNode\n * @typedef {import('../../types').Reducer} Reducer\n * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder\n */\n\n/**\n * @type {FileDAGBuilder}\n */\nasync function trickleStream(source, reduce, options) {\n  const root = new Root(options.layerRepeat);\n  let iteration = 0;\n  let maxDepth = 1;\n\n  /** @type {SubTree} */\n  let subTree = root;\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce));\n      }\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++;\n      }\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n      iteration++;\n    }\n    subTree.append(layer);\n  }\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce));\n  }\n  return root.reduce(reduce);\n}\nexport default trickleStream;\nclass SubTree {\n  /**\n   * @param {number} maxDepth\n   * @param {number} layerRepeat\n   * @param {number} [iteration=0]\n   */\n  constructor(maxDepth, layerRepeat, iteration = 0) {\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n\n    /** @type {TrickleDagNode} */\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node);\n      return false;\n    }\n\n    // try to find new node from node.parent\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {TrickleDagNode} parent\n   */\n  _addNextNodeToParent(parent) {\n    this.parent = parent;\n\n    // find site for new node\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    };\n\n    // @ts-ignore\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n\n  /**\n   *\n   * @param {InProgressImportResult[]} layer\n   */\n  append(layer) {\n    this.node.data = layer;\n  }\n\n  /**\n   * @param {Reducer} reduce\n   */\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n\n  /**\n   * @param {TrickleDagNode} node\n   * @param {Reducer} reduce\n   * @returns {Promise<InProgressImportResult>}\n   */\n  async _reduce(node, reduce) {\n    /** @type {InProgressImportResult[]} */\n    let children = [];\n    if (node.children.length) {\n      children = await Promise.all(node.children\n      // @ts-ignore\n      .filter(child => child.data)\n      // @ts-ignore\n      .map(child => this._reduce(child, reduce)));\n    }\n    return reduce((node.data || []).concat(children));\n  }\n\n  /**\n   * @param {TrickleDagNode} node\n   * @param {number} depth\n   * @returns {TrickleDagNode | undefined}\n   */\n  _findParent(node, depth) {\n    const parent = node.parent;\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth);\n    }\n    return parent;\n  }\n}\nclass Root extends SubTree {\n  /**\n   * @param {number} layerRepeat\n   */\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n\n  /**\n   * @param {InProgressImportResult} child\n   */\n  addChild(child) {\n    this.root.children.push(child);\n  }\n\n  /**\n   * @param {Reducer} reduce\n   */\n  reduce(reduce) {\n    return reduce((this.root.data || []).concat(this.root.children));\n  }\n}","map":{"version":3,"names":["batch","trickleStream","source","reduce","options","root","Root","layerRepeat","iteration","maxDepth","subTree","layer","maxChildrenPerNode","isFull","addChild","SubTree","append","constructor","currentDepth","node","parent","children","depth","maxChildren","data","_addNextNodeToParent","distantRelative","_findParent","nextNode","Math","floor","length","push","_reduce","Promise","all","filter","child","map","concat"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-unixfs-importer@12.0.1/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js"],"sourcesContent":["import batch from 'it-batch'\n\n/**\n * @typedef {import('ipfs-unixfs').UnixFS} UnixFS\n * @typedef {import('../../types').ImporterOptions} ImporterOptions\n * @typedef {import('../../types').InProgressImportResult} InProgressImportResult\n * @typedef {import('../../types').TrickleDagNode} TrickleDagNode\n * @typedef {import('../../types').Reducer} Reducer\n * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder\n */\n\n/**\n * @type {FileDAGBuilder}\n */\nasync function trickleStream (source, reduce, options) {\n  const root = new Root(options.layerRepeat)\n  let iteration = 0\n  let maxDepth = 1\n\n  /** @type {SubTree} */\n  let subTree = root\n\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce))\n      }\n\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++\n      }\n\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration)\n\n      iteration++\n    }\n\n    subTree.append(layer)\n  }\n\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce))\n  }\n\n  return root.reduce(reduce)\n}\n\nexport default trickleStream\n\nclass SubTree {\n  /**\n   * @param {number} maxDepth\n   * @param {number} layerRepeat\n   * @param {number} [iteration=0]\n   */\n  constructor (maxDepth, layerRepeat, iteration = 0) {\n    this.maxDepth = maxDepth\n    this.layerRepeat = layerRepeat\n    this.currentDepth = 1\n    this.iteration = iteration\n\n    /** @type {TrickleDagNode} */\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    }\n  }\n\n  isFull () {\n    if (!this.root.data) {\n      return false\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node)\n\n      return false\n    }\n\n    // try to find new node from node.parent\n    const distantRelative = this._findParent(this.node, this.currentDepth)\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative)\n\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * @param {TrickleDagNode} parent\n   */\n  _addNextNodeToParent (parent) {\n    this.parent = parent\n\n    // find site for new node\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    }\n\n    // @ts-ignore\n    parent.children.push(nextNode)\n\n    this.currentDepth = nextNode.depth\n    this.node = nextNode\n  }\n\n  /**\n   *\n   * @param {InProgressImportResult[]} layer\n   */\n  append (layer) {\n    this.node.data = layer\n  }\n\n  /**\n   * @param {Reducer} reduce\n   */\n  reduce (reduce) {\n    return this._reduce(this.root, reduce)\n  }\n\n  /**\n   * @param {TrickleDagNode} node\n   * @param {Reducer} reduce\n   * @returns {Promise<InProgressImportResult>}\n   */\n  async _reduce (node, reduce) {\n    /** @type {InProgressImportResult[]} */\n    let children = []\n\n    if (node.children.length) {\n      children = await Promise.all(\n        node.children\n          // @ts-ignore\n          .filter(child => child.data)\n          // @ts-ignore\n          .map(child => this._reduce(child, reduce))\n      )\n    }\n\n    return reduce((node.data || []).concat(children))\n  }\n\n  /**\n   * @param {TrickleDagNode} node\n   * @param {number} depth\n   * @returns {TrickleDagNode | undefined}\n   */\n  _findParent (node, depth) {\n    const parent = node.parent\n\n    if (!parent || parent.depth === 0) {\n      return\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth)\n    }\n\n    return parent\n  }\n}\n\nclass Root extends SubTree {\n  /**\n   * @param {number} layerRepeat\n   */\n  constructor (layerRepeat) {\n    super(0, layerRepeat)\n\n    this.root.depth = 0\n    this.currentDepth = 1\n  }\n\n  /**\n   * @param {InProgressImportResult} child\n   */\n  addChild (child) {\n    this.root.children.push(child)\n  }\n\n  /**\n   * @param {Reducer} reduce\n   */\n  reduce (reduce) {\n    return reduce((this.root.data || []).concat(this.root.children))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}