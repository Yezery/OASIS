{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */function () {\n  /**\n   * Create a new HKDF instance for the given hash function\n   * with the master key, optional salt, and info.\n   *\n   * - Master key is a high-entropy secret key (not a password).\n   * - Salt is a non-secret random value.\n   * - Info is application- and/or context-specific information.\n   */\n  function HKDF(hash, key, salt, info) {\n    if (salt === void 0) {\n      salt = new Uint8Array(0);\n    }\n    this._counter = new Uint8Array(1); // starts with zero\n    this._hash = hash;\n    this._info = info;\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac_1.hmac(this._hash, salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    this._hmac = new hmac_1.HMAC(hash, okm);\n    // Allocate buffer.\n    this._buffer = new Uint8Array(this._hmac.digestLength);\n    this._bufpos = this._buffer.length;\n  }\n  // Fill buffer with new block of HKDF-Extract output.\n  HKDF.prototype._fillBuffer = function () {\n    // Increment counter.\n    this._counter[0]++;\n    var ctr = this._counter[0];\n    // Check if counter overflowed.\n    if (ctr === 0) {\n      throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    this._hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (ctr > 1) {\n      this._hmac.update(this._buffer);\n    }\n    // Hash in info if it exists.\n    if (this._info) {\n      this._hmac.update(this._info);\n    }\n    // Hash in the counter.\n    this._hmac.update(this._counter);\n    // Output result to buffer and clean HMAC instance.\n    this._hmac.finish(this._buffer);\n    // Reset buffer position.\n    this._bufpos = 0;\n  };\n  /**\n   * Expand returns next key material of the given length.\n   *\n   * It throws if expansion limit is reached (which is\n   * 254 digests of the underlying HMAC function).\n   */\n  HKDF.prototype.expand = function (length) {\n    var out = new Uint8Array(length);\n    for (var i = 0; i < out.length; i++) {\n      if (this._bufpos === this._buffer.length) {\n        this._fillBuffer();\n      }\n      out[i] = this._buffer[this._bufpos++];\n    }\n    return out;\n  };\n  HKDF.prototype.clean = function () {\n    this._hmac.clean();\n    wipe_1.wipe(this._buffer);\n    wipe_1.wipe(this._counter);\n    this._bufpos = 0;\n  };\n  return HKDF;\n}();\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?","map":{"version":3,"names":["require","hmac_1","wipe_1","HKDF","hash","key","salt","info","Uint8Array","_counter","_hash","_info","okm","hmac","_hmac","HMAC","_buffer","digestLength","_bufpos","length","prototype","_fillBuffer","ctr","Error","reset","update","finish","expand","out","i","clean","wipe","exports"],"sources":["../hkdf.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}