{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { exporter, recursive } from 'ipfs-unixfs-exporter';\nimport errCode from 'err-code';\nimport { normalizeCidPath } from '../utils.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport { CID } from 'multiformats/cid';\nimport { pack } from 'it-tar';\nimport { pipe } from 'it-pipe';\nimport Pako from 'pako';\nimport toBuffer from 'it-to-buffer';\n\n// https://www.gnu.org/software/gzip/manual/gzip.html\nconst DEFAULT_COMPRESSION_LEVEL = 6;\n\n/**\n * @typedef {object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\nexport function createGet({\n  repo,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"get\"]}\n   */\n  async function* get(ipfsPath, options = {}) {\n    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {\n      throw errCode(new Error('Compression level must be between -1 and 9'), 'ERR_INVALID_PARAMS');\n    }\n    if (options.preload !== false) {\n      let pathComponents;\n      try {\n        pathComponents = normalizeCidPath(ipfsPath).split('/');\n      } catch ( /** @type {any} */err) {\n        throw errCode(err, 'ERR_INVALID_PATH');\n      }\n      preload(CID.parse(pathComponents[0]));\n    }\n    const ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath;\n    const file = await exporter(ipfsPathOrCid, repo.blocks, options);\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = [];\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }], pack());\n      } else {\n        args.push(file.content);\n      }\n      if (options.compress) {\n        args.push(\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        async function* (source) {\n          const buf = await toBuffer(source);\n          yield Pako.gzip(buf, {\n            level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n          });\n        });\n      }\n\n      // @ts-expect-error cannot derive type\n      yield* pipe(...args);\n      return;\n    }\n    if (file.type === 'directory') {\n      /** @type {any[]} */\n      const args = [recursive(ipfsPathOrCid, repo.blocks, options),\n      /**\n       * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n       */\n      async function* (source) {\n        for await (const entry of source) {\n          /** @type {import('it-tar').TarImportCandidate} */\n          const output = {\n            header: {\n              name: entry.path,\n              size: entry.size\n            }\n          };\n          if (entry.type === 'file') {\n            output.header.type = 'file';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n            output.body = entry.content();\n          } else if (entry.type === 'raw') {\n            output.header.type = 'file';\n            output.body = entry.content();\n          } else if (entry.type === 'directory') {\n            output.header.type = 'directory';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n          } else {\n            throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n          }\n          yield output;\n        }\n      }, pack()];\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH');\n        }\n        if (options.compress) {\n          args.push(\n          /**\n           * @param {AsyncIterable<Uint8Array>} source\n           */\n          async function* (source) {\n            const buf = await toBuffer(source);\n            yield Pako.gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            });\n          });\n        }\n      }\n\n      // @ts-expect-error cannot derive type\n      yield* pipe(...args);\n      return;\n    }\n    throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n  }\n  return withTimeoutOption(get);\n}","map":{"version":3,"names":["exporter","recursive","errCode","normalizeCidPath","withTimeoutOption","CID","pack","pipe","Pako","toBuffer","DEFAULT_COMPRESSION_LEVEL","createGet","repo","preload","get","ipfsPath","options","compressionLevel","Error","pathComponents","split","err","parse","ipfsPathOrCid","asCID","file","blocks","type","args","compress","archive","push","header","name","path","mode","unixfs","mtime","Date","secs","undefined","size","body","content","source","buf","gzip","level","entry","output"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/get.js"],"sourcesContent":["import { exporter, recursive } from 'ipfs-unixfs-exporter'\nimport errCode from 'err-code'\nimport { normalizeCidPath } from '../utils.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport { CID } from 'multiformats/cid'\nimport { pack } from 'it-tar'\nimport { pipe } from 'it-pipe'\nimport Pako from 'pako'\nimport toBuffer from 'it-to-buffer'\n\n// https://www.gnu.org/software/gzip/manual/gzip.html\nconst DEFAULT_COMPRESSION_LEVEL = 6\n\n/**\n * @typedef {object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\nexport function createGet ({ repo, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API<{}>[\"get\"]}\n   */\n  async function * get (ipfsPath, options = {}) {\n    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {\n      throw errCode(new Error('Compression level must be between -1 and 9'), 'ERR_INVALID_PARAMS')\n    }\n\n    if (options.preload !== false) {\n      let pathComponents\n\n      try {\n        pathComponents = normalizeCidPath(ipfsPath).split('/')\n      } catch (/** @type {any} */ err) {\n        throw errCode(err, 'ERR_INVALID_PATH')\n      }\n\n      preload(CID.parse(pathComponents[0]))\n    }\n\n    const ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath\n    const file = await exporter(ipfsPathOrCid, repo.blocks, options)\n\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = []\n\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }],\n        pack()\n        )\n      } else {\n        args.push(\n          file.content\n        )\n      }\n\n      if (options.compress) {\n        args.push(\n          /**\n           * @param {AsyncIterable<Uint8Array>} source\n           */\n          async function * (source) {\n            const buf = await toBuffer(source)\n\n            yield Pako.gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            })\n          }\n        )\n      }\n\n      // @ts-expect-error cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    if (file.type === 'directory') {\n      /** @type {any[]} */\n      const args = [\n        recursive(ipfsPathOrCid, repo.blocks, options),\n        /**\n         * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n         */\n        async function * (source) {\n          for await (const entry of source) {\n            /** @type {import('it-tar').TarImportCandidate} */\n            const output = {\n              header: {\n                name: entry.path,\n                size: entry.size\n              }\n            }\n\n            if (entry.type === 'file') {\n              output.header.type = 'file'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n              output.body = entry.content()\n            } else if (entry.type === 'raw') {\n              output.header.type = 'file'\n              output.body = entry.content()\n            } else if (entry.type === 'directory') {\n              output.header.type = 'directory'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n            } else {\n              throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n            }\n\n            yield output\n          }\n        },\n        pack()\n      ]\n\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH')\n        }\n\n        if (options.compress) {\n          args.push(\n            /**\n             * @param {AsyncIterable<Uint8Array>} source\n             */\n            async function * (source) {\n              const buf = await toBuffer(source)\n\n              yield Pako.gzip(buf, {\n                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n              })\n            }\n          )\n        }\n      }\n\n      // @ts-expect-error cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n  }\n\n  return withTimeoutOption(get)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}