{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport get from 'dlv';\nimport mergeOpts from 'merge-options';\nimport errCode from 'err-code';\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers';\nimport { delegatedPeerRouting } from '@libp2p/delegated-peer-routing';\nimport { delegatedContentRouting } from '@libp2p/delegated-content-routing';\nimport { create as ipfsHttpClient } from 'ipfs-http-client';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { ipfsCore as pkgversion } from '../version.js';\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p';\nimport { createLibp2p as createNode } from 'libp2p';\nimport { kadDHT } from '@libp2p/kad-dht';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { ipnsValidator } from 'ipns/validator';\nimport { ipnsSelector } from 'ipns/selector';\nimport { webSockets } from '@libp2p/websockets';\nimport { mplex } from '@libp2p/mplex';\nimport { noise } from '@chainsafe/libp2p-noise';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true,\n  concatArrays: true\n});\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nexport function createLibp2p({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) {\n  const {\n    datastore\n  } = repo;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  }\n\n  // do not start by default\n  libp2pOptions.start = false;\n  return createNode(libp2pOptions);\n}\n\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions({\n  options,\n  config,\n  datastore,\n  keychainConfig,\n  peerId,\n  multiaddrs\n}) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub';\n    const availableRouters = routers();\n    if (!availableRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    }\n    return availableRouters[router];\n  };\n\n  /** @type {Libp2pOptions} */\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId\n  };\n\n  /** @type {Libp2pOptions} */\n  const libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: `js-ipfs/${pkgversion}`\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [mplex({\n      maxInboundStreams: 256,\n      maxOutboundStreams: 1024\n    })],\n    connectionEncryption: [noise()],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  };\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter();\n  }\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = kadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    });\n  }\n  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []));\n  if (boostrapNodes.length > 0) {\n    libp2pOptions.peerDiscovery?.push(bootstrap({\n      list: boostrapNodes\n    }));\n  }\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined);\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  /** @type {Libp2pOptions} */\n  const libp2pFinalConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = multiaddr(delegateString).toOptions();\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient));\n    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient));\n  }\n\n  // TODO: fixme\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {\n      try {\n        if (typeof d === 'function') {\n          // @ts-expect-error not components\n          return d({})[Symbol.toStringTag] !== '@libp2p/mdns';\n        }\n      } catch {}\n      return true;\n    });\n  }\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = [];\n  }\n\n  // add WebSocket transport if not overridden by user config\n  if (libp2pFinalConfig.transports.find(t => {\n    try {\n      if (typeof t === 'function') {\n        return t({})[Symbol.toStringTag] === '@libp2p/websockets';\n      }\n    } catch {}\n    return false;\n  }) == null) {\n    libp2pFinalConfig.transports.push(webSockets());\n  }\n  return libp2pFinalConfig;\n}","map":{"version":3,"names":["get","mergeOpts","errCode","routers","delegatedPeerRouting","delegatedContentRouting","create","ipfsHttpClient","multiaddr","ipfsCore","pkgversion","libp2pConfig","getEnvLibp2pOptions","createLibp2p","createNode","kadDHT","bootstrap","ipnsValidator","ipnsSelector","webSockets","mplex","noise","mergeOptions","bind","ignoreUndefined","concatArrays","options","peerId","multiaddrs","repo","keychainConfig","config","datastore","libp2pOptions","getLibp2pOptions","libp2p","start","getPubsubRouter","router","availableRouters","Error","libp2pDefaults","addresses","listen","map","ma","toString","announce","noAnnounce","connectionManager","maxConnections","minConnections","keychain","identify","host","agentVersion","contentRouters","peerRouters","peerDiscovery","transports","streamMuxers","maxInboundStreams","maxOutboundStreams","connectionEncryption","relay","enabled","hop","active","nat","pubsub","dht","clientMode","kBucketSize","validators","ipns","selectors","boostrapNodes","length","push","list","constructorOptions","undefined","libp2pFinalConfig","delegateHosts","delegateString","Math","floor","random","delegateAddr","toOptions","delegateApiOptions","protocol","parseInt","port","delegateHttpClient","filter","d","Symbol","toStringTag","find","t"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/libp2p.js"],"sourcesContent":["import get from 'dlv'\nimport mergeOpts from 'merge-options'\nimport errCode from 'err-code'\nimport { routers } from 'ipfs-core-config/libp2p-pubsub-routers'\nimport { delegatedPeerRouting } from '@libp2p/delegated-peer-routing'\nimport { delegatedContentRouting } from '@libp2p/delegated-content-routing'\nimport { create as ipfsHttpClient } from 'ipfs-http-client'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { ipfsCore as pkgversion } from '../version.js'\nimport { libp2pConfig as getEnvLibp2pOptions } from 'ipfs-core-config/libp2p'\nimport { createLibp2p as createNode } from 'libp2p'\nimport { kadDHT } from '@libp2p/kad-dht'\nimport { bootstrap } from '@libp2p/bootstrap'\nimport { ipnsValidator } from 'ipns/validator'\nimport { ipnsSelector } from 'ipns/selector'\nimport { webSockets } from '@libp2p/websockets'\nimport { mplex } from '@libp2p/mplex'\nimport { noise } from '@chainsafe/libp2p-noise'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true, concatArrays: true })\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p').Libp2p} LibP2P\n * @typedef {import('libp2p').Libp2pOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nexport function createLibp2p ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) {\n  const { datastore } = repo\n\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  })\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })\n  }\n\n  // do not start by default\n  libp2pOptions.start = false\n\n  return createNode(libp2pOptions)\n}\n\n/**\n * @param {object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions ({ options, config, datastore, keychainConfig, peerId, multiaddrs }) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'\n\n    const availableRouters = routers()\n\n    if (!availableRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    return availableRouters[router]\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId\n  }\n\n  /** @type {Libp2pOptions} */\n  const libp2pOptions = {\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: keychainConfig,\n    identify: {\n      host: {\n        agentVersion: `js-ipfs/${pkgversion}`\n      }\n    },\n    contentRouters: [],\n    peerRouters: [],\n    peerDiscovery: [],\n    transports: [],\n    streamMuxers: [\n      mplex({\n        maxInboundStreams: 256,\n        maxOutboundStreams: 1024\n      })\n    ],\n    connectionEncryption: [\n      noise()\n    ],\n    relay: {\n      enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n      hop: {\n        enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n        active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n      }\n    },\n    nat: {\n      enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n    }\n  }\n\n  if (get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))) {\n    libp2pOptions.pubsub = getPubsubRouter()\n  }\n\n  if (get(config, 'Routing.Type', 'dhtclient') !== 'none') {\n    libp2pOptions.dht = kadDHT({\n      clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n      kBucketSize: get(options, 'dht.kBucketSize', 20),\n      validators: {\n        ipns: ipnsValidator\n      },\n      selectors: {\n        ipns: ipnsSelector\n      }\n    })\n  }\n\n  const boostrapNodes = get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n\n  if (boostrapNodes.length > 0) {\n    libp2pOptions.peerDiscovery?.push(\n      bootstrap({\n        list: boostrapNodes\n      })\n    )\n  }\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined)\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  /** @type {Libp2pOptions} */\n  const libp2pFinalConfig = mergeOptions(\n    libp2pDefaults,\n    getEnvLibp2pOptions(),\n    libp2pOptions,\n    constructorOptions\n  )\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = multiaddr(delegateString).toOptions()\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-expect-error - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)\n\n    libp2pFinalConfig.contentRouters?.push(delegatedContentRouting(delegateHttpClient))\n    libp2pFinalConfig.peerRouters?.push(delegatedPeerRouting(delegateHttpClient))\n  }\n\n  // TODO: fixme\n  if (!get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))) {\n    libp2pFinalConfig.peerDiscovery = libp2pFinalConfig.peerDiscovery?.filter(d => {\n      try {\n        if (typeof d === 'function') {\n          // @ts-expect-error not components\n          return d({})[Symbol.toStringTag] !== '@libp2p/mdns'\n        }\n      } catch {}\n      return true\n    })\n  }\n\n  if (libp2pFinalConfig.transports == null) {\n    libp2pFinalConfig.transports = []\n  }\n\n  // add WebSocket transport if not overridden by user config\n  if (libp2pFinalConfig.transports.find(t => {\n    try {\n      if (typeof t === 'function') {\n        return t({})[Symbol.toStringTag] === '@libp2p/websockets'\n      }\n    } catch {}\n    return false\n  }) == null) {\n    libp2pFinalConfig.transports.push(webSockets())\n  }\n\n  return libp2pFinalConfig\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}