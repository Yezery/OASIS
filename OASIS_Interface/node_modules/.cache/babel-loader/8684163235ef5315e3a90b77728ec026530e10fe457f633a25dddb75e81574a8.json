{"ast":null,"code":"import mergeOpts from 'merge-options';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport { toTrail } from './utils/to-trail.js';\nimport { addLink } from './utils/add-link.js';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport * as dagPB from '@ipld/dag-pb';\nimport { CID } from 'multiformats/cid';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\nconst log = logger('ipfs:mfs:touch');\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createTouch(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"touch\"]}\n   */\n  async function mfsTouch(path, options = {}) {\n    /** @type {DefaultOptions} */\n    const settings = mergeOptions(defaultOptions, options);\n    settings.mtime = settings.mtime || new Date();\n    log(`Touching ${path} mtime: ${settings.mtime}`);\n    const {\n      cid,\n      mfsDirectory,\n      name,\n      exists\n    } = await toMfsPath(context, path, settings);\n    const hashAlg = options.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    let updatedBlock;\n    let updatedCid;\n    let cidVersion = settings.cidVersion;\n    if (!exists) {\n      const metadata = new UnixFS({\n        type: 'file',\n        mtime: settings.mtime\n      });\n      updatedBlock = dagPB.encode({\n        Data: metadata.marshal(),\n        Links: []\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = CID.create(settings.cidVersion, dagPB.code, hash);\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    } else {\n      if (cid.code !== dagPB.code) {\n        throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n      }\n      cidVersion = cid.version;\n      const block = await context.repo.blocks.get(cid);\n      const node = dagPB.decode(block);\n      if (!node.Data) {\n        throw errCode(new Error(`${path} had no data`), 'ERR_INVALID_NODE');\n      }\n      const metadata = UnixFS.unmarshal(node.Data);\n\n      // @ts-expect-error TODO: restore setting all date types as mtime - it's in the code, just not the signature\n      metadata.mtime = settings.mtime;\n      updatedBlock = dagPB.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      });\n      const hash = await hasher.digest(updatedBlock);\n      updatedCid = CID.create(settings.cidVersion, dagPB.code, hash);\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock);\n      }\n    }\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = parent.cid;\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPB.decode(parentBlock);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: settings.flush,\n      shardSplitThreshold: settings.shardSplitThreshold,\n      hashAlg: settings.hashAlg,\n      cidVersion\n    });\n    parent.cid = result.cid;\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, settings);\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, settings);\n  }\n  return withTimeoutOption(mfsTouch);\n}","map":{"version":3,"names":["mergeOpts","toMfsPath","logger","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPB","CID","withTimeoutOption","mergeOptions","bind","ignoreUndefined","log","defaultOptions","flush","shardSplitThreshold","cidVersion","hashAlg","createTouch","context","mfsTouch","path","options","settings","mtime","Date","cid","mfsDirectory","name","exists","hasher","hashers","getHasher","updatedBlock","updatedCid","metadata","type","encode","Data","marshal","Links","hash","digest","create","code","repo","blocks","put","Error","version","block","get","node","decode","unmarshal","trail","parent","length","parentCid","parentBlock","parentNode","result","size","newRootCid"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/touch.js"],"sourcesContent":["import mergeOpts from 'merge-options'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { logger } from '@libp2p/logger'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { toTrail } from './utils/to-trail.js'\nimport { addLink } from './utils/add-link.js'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport * as dagPB from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('ipfs:mfs:touch')\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createTouch (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"touch\"]}\n   */\n  async function mfsTouch (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const settings = mergeOptions(defaultOptions, options)\n    settings.mtime = settings.mtime || new Date()\n\n    log(`Touching ${path} mtime: ${settings.mtime}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name,\n      exists\n    } = await toMfsPath(context, path, settings)\n\n    const hashAlg = options.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n\n    let updatedBlock\n    let updatedCid\n\n    let cidVersion = settings.cidVersion\n\n    if (!exists) {\n      const metadata = new UnixFS({\n        type: 'file',\n        mtime: settings.mtime\n      })\n      updatedBlock = dagPB.encode({ Data: metadata.marshal(), Links: [] })\n\n      const hash = await hasher.digest(updatedBlock)\n\n      updatedCid = CID.create(settings.cidVersion, dagPB.code, hash)\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock)\n      }\n    } else {\n      if (cid.code !== dagPB.code) {\n        throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n      }\n\n      cidVersion = cid.version\n\n      const block = await context.repo.blocks.get(cid)\n      const node = dagPB.decode(block)\n\n      if (!node.Data) {\n        throw errCode(new Error(`${path} had no data`), 'ERR_INVALID_NODE')\n      }\n\n      const metadata = UnixFS.unmarshal(node.Data)\n\n      // @ts-expect-error TODO: restore setting all date types as mtime - it's in the code, just not the signature\n      metadata.mtime = settings.mtime\n\n      updatedBlock = dagPB.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      })\n\n      const hash = await hasher.digest(updatedBlock)\n      updatedCid = CID.create(settings.cidVersion, dagPB.code, hash)\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock)\n      }\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = parent.cid\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPB.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: settings.flush,\n      shardSplitThreshold: settings.shardSplitThreshold,\n      hashAlg: settings.hashAlg,\n      cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, settings)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, settings)\n  }\n\n  return withTimeoutOption(mfsTouch)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}