{"ast":null,"code":"/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\nexport const TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo(task, tasksWithTopic) {\n    let haveBlock = false;\n    let isWantBlock = false;\n    for (const existing of tasksWithTopic) {\n      if (existing.data.haveBlock) {\n        haveBlock = true;\n      }\n      if (existing.data.isWantBlock) {\n        isWantBlock = true;\n      }\n    }\n\n    // If there is no active want-block and the new task is a want-block,\n    // the new task is better\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true;\n    }\n\n    // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n    if (!haveBlock && task.data.haveBlock) {\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge(newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    const taskData = newTask.data;\n    const existingData = existingTask.data;\n\n    // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock;\n      existingData.blockSize = taskData.blockSize;\n    }\n\n    // If replacing a want-have with a want-block\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true;\n      // If the want-have was a DONT_HAVE, or the want-block has a size\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock;\n        existingTask.size = newTask.size;\n      }\n    }\n\n    // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize;\n    }\n  }\n};","map":{"version":3,"names":["TaskMerger","hasNewInfo","task","tasksWithTopic","haveBlock","isWantBlock","existing","data","merge","newTask","existingTask","taskData","existingData","blockSize","size"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/decision-engine/task-merger.js"],"sourcesContent":["/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\nexport const TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo (task, tasksWithTopic) {\n    let haveBlock = false\n    let isWantBlock = false\n    for (const existing of tasksWithTopic) {\n      if (existing.data.haveBlock) {\n        haveBlock = true\n      }\n\n      if (existing.data.isWantBlock) {\n        isWantBlock = true\n      }\n    }\n\n    // If there is no active want-block and the new task is a want-block,\n    // the new task is better\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true\n    }\n\n    // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n    if (!haveBlock && task.data.haveBlock) {\n      return true\n    }\n\n    return false\n  },\n\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge (newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    const taskData = newTask.data\n    const existingData = existingTask.data\n\n    // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock\n      existingData.blockSize = taskData.blockSize\n    }\n\n    // If replacing a want-have with a want-block\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true\n      // If the want-have was a DONT_HAVE, or the want-block has a size\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock\n        existingTask.size = newTask.size\n      }\n    }\n\n    // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,OAAO,MAAMA,UAAU,GAAG;EACxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAAEC,IAAI,EAAEC,cAAc,EAAE;IAChC,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,WAAW,GAAG,KAAK;IACvB,KAAK,MAAMC,QAAQ,IAAIH,cAAc,EAAE;MACrC,IAAIG,QAAQ,CAACC,IAAI,CAACH,SAAS,EAAE;QAC3BA,SAAS,GAAG,IAAI;MAClB;MAEA,IAAIE,QAAQ,CAACC,IAAI,CAACF,WAAW,EAAE;QAC7BA,WAAW,GAAG,IAAI;MACpB;IACF;;IAEA;IACA;IACA,IAAI,CAACA,WAAW,IAAIH,IAAI,CAACK,IAAI,CAACF,WAAW,EAAE;MACzC,OAAO,IAAI;IACb;;IAEA;IACA;IACA;IACA,IAAI,CAACD,SAAS,IAAIF,IAAI,CAACK,IAAI,CAACH,SAAS,EAAE;MACrC,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,KAAKA,CAAEC,OAAO,EAAEC,YAAY,EAAE;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,QAAQ,GAAGF,OAAO,CAACF,IAAI;IAC7B,MAAMK,YAAY,GAAGF,YAAY,CAACH,IAAI;;IAEtC;IACA;IACA;IACA,IAAI,CAACK,YAAY,CAACR,SAAS,IAAIO,QAAQ,CAACP,SAAS,EAAE;MACjDQ,YAAY,CAACR,SAAS,GAAGO,QAAQ,CAACP,SAAS;MAC3CQ,YAAY,CAACC,SAAS,GAAGF,QAAQ,CAACE,SAAS;IAC7C;;IAEA;IACA,IAAI,CAACD,YAAY,CAACP,WAAW,IAAIM,QAAQ,CAACN,WAAW,EAAE;MACrD;MACAO,YAAY,CAACP,WAAW,GAAG,IAAI;MAC/B;MACA,IAAI,CAACO,YAAY,CAACR,SAAS,IAAIO,QAAQ,CAACP,SAAS,EAAE;QACjD;QACAQ,YAAY,CAACR,SAAS,GAAGO,QAAQ,CAACP,SAAS;QAC3CM,YAAY,CAACI,IAAI,GAAGL,OAAO,CAACK,IAAI;MAClC;IACF;;IAEA;IACA;IACA,IAAIF,YAAY,CAACP,WAAW,IAAIO,YAAY,CAACR,SAAS,EAAE;MACtDM,YAAY,CAACI,IAAI,GAAGF,YAAY,CAACC,SAAS;IAC5C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}