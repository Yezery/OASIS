{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Buffer } from 'node:buffer';\nimport { ChildProcess } from 'node:child_process';\nconst normalizeArgs = (file, args = []) => {\n  if (!Array.isArray(args)) {\n    return [file];\n  }\n  return [file, ...args];\n};\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\nconst escapeArg = arg => {\n  if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n    return arg;\n  }\n  return `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\nexport const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');\nexport const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execaCommand()`\nexport const parseCommand = command => {\n  const tokens = [];\n  for (const token of command.trim().split(SPACES_REGEXP)) {\n    // Allow spaces to be escaped by a backslash if not meant as a delimiter\n    const previousToken = tokens[tokens.length - 1];\n    if (previousToken && previousToken.endsWith('\\\\')) {\n      // Merge previous token with current one\n      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n    } else {\n      tokens.push(token);\n    }\n  }\n  return tokens;\n};\nconst parseExpression = expression => {\n  const typeOfExpression = typeof expression;\n  if (typeOfExpression === 'string') {\n    return expression;\n  }\n  if (typeOfExpression === 'number') {\n    return String(expression);\n  }\n  if (typeOfExpression === 'object' && expression !== null && !(expression instanceof ChildProcess) && 'stdout' in expression) {\n    const typeOfStdout = typeof expression.stdout;\n    if (typeOfStdout === 'string') {\n      return expression.stdout;\n    }\n    if (Buffer.isBuffer(expression.stdout)) {\n      return expression.stdout.toString();\n    }\n    throw new TypeError(`Unexpected \"${typeOfStdout}\" stdout in template expression`);\n  }\n  throw new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\nconst concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [...tokens.slice(0, -1), `${tokens[tokens.length - 1]}${nextTokens[0]}`, ...nextTokens.slice(1)];\nconst parseTemplate = ({\n  templates,\n  expressions,\n  tokens,\n  index,\n  template\n}) => {\n  const templateString = template ?? templates.raw[index];\n  const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);\n  const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(' '));\n  if (index === expressions.length) {\n    return newTokens;\n  }\n  const expression = expressions[index];\n  const expressionTokens = Array.isArray(expression) ? expression.map(expression => parseExpression(expression)) : [parseExpression(expression)];\n  return concatTokens(newTokens, expressionTokens, templateString.endsWith(' '));\n};\nexport const parseTemplates = (templates, expressions) => {\n  let tokens = [];\n  for (const [index, template] of templates.entries()) {\n    tokens = parseTemplate({\n      templates,\n      expressions,\n      tokens,\n      index,\n      template\n    });\n  }\n  return tokens;\n};","map":{"version":3,"names":["Buffer","ChildProcess","normalizeArgs","file","args","Array","isArray","NO_ESCAPE_REGEXP","DOUBLE_QUOTES_REGEXP","escapeArg","arg","test","replace","joinCommand","join","getEscapedCommand","map","SPACES_REGEXP","parseCommand","command","tokens","token","trim","split","previousToken","length","endsWith","slice","push","parseExpression","expression","typeOfExpression","String","typeOfStdout","stdout","isBuffer","toString","TypeError","concatTokens","nextTokens","isNew","parseTemplate","templates","expressions","index","template","templateString","raw","templateTokens","filter","Boolean","newTokens","startsWith","expressionTokens","parseTemplates","entries"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/execa@7.2.0/node_modules/execa/lib/command.js"],"sourcesContent":["import {Buffer} from 'node:buffer';\nimport {ChildProcess} from 'node:child_process';\n\nconst normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nexport const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');\n\nexport const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execaCommand()`\nexport const parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (\n\t\ttypeOfExpression === 'object'\n\t\t&& expression !== null\n\t\t&& !(expression instanceof ChildProcess)\n\t\t&& 'stdout' in expression\n\t) {\n\t\tconst typeOfStdout = typeof expression.stdout;\n\n\t\tif (typeOfStdout === 'string') {\n\t\t\treturn expression.stdout;\n\t\t}\n\n\t\tif (Buffer.isBuffer(expression.stdout)) {\n\t\t\treturn expression.stdout.toString();\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected \"${typeOfStdout}\" stdout in template expression`);\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens[tokens.length - 1]}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tconst templateString = template ?? templates.raw[index];\n\tconst templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);\n\tconst newTokens = concatTokens(\n\t\ttokens,\n\t\ttemplateTokens,\n\t\ttemplateString.startsWith(' '),\n\t);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(\n\t\tnewTokens,\n\t\texpressionTokens,\n\t\ttemplateString.endsWith(' '),\n\t);\n};\n\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({templates, expressions, tokens, index, template});\n\t}\n\n\treturn tokens;\n};\n\n"],"mappings":";AAAA,SAAQA,MAAM,QAAO,aAAa;AAClC,SAAQC,YAAY,QAAO,oBAAoB;AAE/C,MAAMC,aAAa,GAAGA,CAACC,IAAI,EAAEC,IAAI,GAAG,EAAE,KAAK;EAC1C,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IACzB,OAAO,CAACD,IAAI,CAAC;EACd;EAEA,OAAO,CAACA,IAAI,EAAE,GAAGC,IAAI,CAAC;AACvB,CAAC;AAED,MAAMG,gBAAgB,GAAG,WAAW;AACpC,MAAMC,oBAAoB,GAAG,IAAI;AAEjC,MAAMC,SAAS,GAAGC,GAAG,IAAI;EACxB,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIH,gBAAgB,CAACI,IAAI,CAACD,GAAG,CAAC,EAAE;IAC1D,OAAOA,GAAG;EACX;EAEA,OAAQ,IAAGA,GAAG,CAACE,OAAO,CAACJ,oBAAoB,EAAE,KAAK,CAAE,GAAE;AACvD,CAAC;AAED,OAAO,MAAMK,WAAW,GAAGA,CAACV,IAAI,EAAEC,IAAI,KAAKF,aAAa,CAACC,IAAI,EAAEC,IAAI,CAAC,CAACU,IAAI,CAAC,GAAG,CAAC;AAE9E,OAAO,MAAMC,iBAAiB,GAAGA,CAACZ,IAAI,EAAEC,IAAI,KAAKF,aAAa,CAACC,IAAI,EAAEC,IAAI,CAAC,CAACY,GAAG,CAACN,GAAG,IAAID,SAAS,CAACC,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;AAE/G,MAAMG,aAAa,GAAG,KAAK;;AAE3B;AACA,OAAO,MAAMC,YAAY,GAAGC,OAAO,IAAI;EACtC,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMC,KAAK,IAAIF,OAAO,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAACN,aAAa,CAAC,EAAE;IACxD;IACA,MAAMO,aAAa,GAAGJ,MAAM,CAACA,MAAM,CAACK,MAAM,GAAG,CAAC,CAAC;IAC/C,IAAID,aAAa,IAAIA,aAAa,CAACE,QAAQ,CAAC,IAAI,CAAC,EAAE;MAClD;MACAN,MAAM,CAACA,MAAM,CAACK,MAAM,GAAG,CAAC,CAAC,GAAI,GAAED,aAAa,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAE,IAAGN,KAAM,EAAC;IACrE,CAAC,MAAM;MACND,MAAM,CAACQ,IAAI,CAACP,KAAK,CAAC;IACnB;EACD;EAEA,OAAOD,MAAM;AACd,CAAC;AAED,MAAMS,eAAe,GAAGC,UAAU,IAAI;EACrC,MAAMC,gBAAgB,GAAG,OAAOD,UAAU;EAE1C,IAAIC,gBAAgB,KAAK,QAAQ,EAAE;IAClC,OAAOD,UAAU;EAClB;EAEA,IAAIC,gBAAgB,KAAK,QAAQ,EAAE;IAClC,OAAOC,MAAM,CAACF,UAAU,CAAC;EAC1B;EAEA,IACCC,gBAAgB,KAAK,QAAQ,IAC1BD,UAAU,KAAK,IAAI,IACnB,EAAEA,UAAU,YAAY7B,YAAY,CAAC,IACrC,QAAQ,IAAI6B,UAAU,EACxB;IACD,MAAMG,YAAY,GAAG,OAAOH,UAAU,CAACI,MAAM;IAE7C,IAAID,YAAY,KAAK,QAAQ,EAAE;MAC9B,OAAOH,UAAU,CAACI,MAAM;IACzB;IAEA,IAAIlC,MAAM,CAACmC,QAAQ,CAACL,UAAU,CAACI,MAAM,CAAC,EAAE;MACvC,OAAOJ,UAAU,CAACI,MAAM,CAACE,QAAQ,CAAC,CAAC;IACpC;IAEA,MAAM,IAAIC,SAAS,CAAE,eAAcJ,YAAa,iCAAgC,CAAC;EAClF;EAEA,MAAM,IAAII,SAAS,CAAE,eAAcN,gBAAiB,0BAAyB,CAAC;AAC/E,CAAC;AAED,MAAMO,YAAY,GAAGA,CAAClB,MAAM,EAAEmB,UAAU,EAAEC,KAAK,KAAKA,KAAK,IAAIpB,MAAM,CAACK,MAAM,KAAK,CAAC,IAAIc,UAAU,CAACd,MAAM,KAAK,CAAC,GACxG,CAAC,GAAGL,MAAM,EAAE,GAAGmB,UAAU,CAAC,GAC1B,CACD,GAAGnB,MAAM,CAACO,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EACrB,GAAEP,MAAM,CAACA,MAAM,CAACK,MAAM,GAAG,CAAC,CAAE,GAAEc,UAAU,CAAC,CAAC,CAAE,EAAC,EAC9C,GAAGA,UAAU,CAACZ,KAAK,CAAC,CAAC,CAAC,CACtB;AAEF,MAAMc,aAAa,GAAGA,CAAC;EAACC,SAAS;EAAEC,WAAW;EAAEvB,MAAM;EAAEwB,KAAK;EAAEC;AAAQ,CAAC,KAAK;EAC5E,MAAMC,cAAc,GAAGD,QAAQ,IAAIH,SAAS,CAACK,GAAG,CAACH,KAAK,CAAC;EACvD,MAAMI,cAAc,GAAGF,cAAc,CAACvB,KAAK,CAACN,aAAa,CAAC,CAACgC,MAAM,CAACC,OAAO,CAAC;EAC1E,MAAMC,SAAS,GAAGb,YAAY,CAC7BlB,MAAM,EACN4B,cAAc,EACdF,cAAc,CAACM,UAAU,CAAC,GAAG,CAC9B,CAAC;EAED,IAAIR,KAAK,KAAKD,WAAW,CAAClB,MAAM,EAAE;IACjC,OAAO0B,SAAS;EACjB;EAEA,MAAMrB,UAAU,GAAGa,WAAW,CAACC,KAAK,CAAC;EACrC,MAAMS,gBAAgB,GAAGhD,KAAK,CAACC,OAAO,CAACwB,UAAU,CAAC,GAC/CA,UAAU,CAACd,GAAG,CAACc,UAAU,IAAID,eAAe,CAACC,UAAU,CAAC,CAAC,GACzD,CAACD,eAAe,CAACC,UAAU,CAAC,CAAC;EAChC,OAAOQ,YAAY,CAClBa,SAAS,EACTE,gBAAgB,EAChBP,cAAc,CAACpB,QAAQ,CAAC,GAAG,CAC5B,CAAC;AACF,CAAC;AAED,OAAO,MAAM4B,cAAc,GAAGA,CAACZ,SAAS,EAAEC,WAAW,KAAK;EACzD,IAAIvB,MAAM,GAAG,EAAE;EAEf,KAAK,MAAM,CAACwB,KAAK,EAAEC,QAAQ,CAAC,IAAIH,SAAS,CAACa,OAAO,CAAC,CAAC,EAAE;IACpDnC,MAAM,GAAGqB,aAAa,CAAC;MAACC,SAAS;MAAEC,WAAW;MAAEvB,MAAM;MAAEwB,KAAK;MAAEC;IAAQ,CAAC,CAAC;EAC1E;EAEA,OAAOzB,MAAM;AACd,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}