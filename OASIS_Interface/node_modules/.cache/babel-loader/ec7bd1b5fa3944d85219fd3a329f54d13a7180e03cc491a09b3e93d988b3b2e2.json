{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { multiaddr } from '@multiformats/multiaddr';\nexport function createListener(options) {\n  const listeningAddrs = new Map();\n  /**\n   * Add swarm handler and listen for incoming connections\n   */\n  async function listen(addr) {\n    const addrString = addr.toString().split('/p2p-circuit').find(a => a !== '');\n    const ma = multiaddr(addrString);\n    const relayPeerStr = ma.getPeerId();\n    if (relayPeerStr == null) {\n      throw new Error('Could not determine relay peer from multiaddr');\n    }\n    const relayPeerId = peerIdFromString(relayPeerStr);\n    await options.peerStore.addressBook.add(relayPeerId, [ma]);\n    const relayConn = await options.connectionManager.openConnection(relayPeerId);\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');\n    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);\n    listener.dispatchEvent(new CustomEvent('listening'));\n  }\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n  function getAddrs() {\n    const addrs = [];\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr);\n    }\n    return addrs;\n  }\n  const listener = Object.assign(new EventEmitter(), {\n    close: async () => await Promise.resolve(),\n    listen,\n    getAddrs\n  });\n  // Remove listeningAddrs when a peer disconnects\n  options.connectionManager.addEventListener('peer:disconnect', evt => {\n    const {\n      detail: connection\n    } = evt;\n    const deleted = listeningAddrs.delete(connection.remotePeer.toString());\n    if (deleted) {\n      // Announce listen addresses change\n      listener.dispatchEvent(new CustomEvent('close'));\n    }\n  });\n  return listener;\n}","map":{"version":3,"names":["CustomEvent","EventEmitter","peerIdFromString","multiaddr","createListener","options","listeningAddrs","Map","listen","addr","addrString","toString","split","find","a","ma","relayPeerStr","getPeerId","Error","relayPeerId","peerStore","addressBook","add","relayConn","connectionManager","openConnection","relayedAddr","remoteAddr","encapsulate","set","remotePeer","listener","dispatchEvent","getAddrs","addrs","values","push","Object","assign","close","Promise","resolve","addEventListener","evt","detail","connection","deleted","delete"],"sources":["../../../src/circuit/listener.ts"],"sourcesContent":[null],"mappings":";AAAA,SAASA,WAAW,EAAEC,YAAY,QAAQ,2BAA2B;AAIrE,SAASC,gBAAgB,QAAQ,iBAAiB;AAElD,SAASC,SAAS,QAAQ,yBAAyB;AAOnD,OAAM,SAAUC,cAAcA,CAAEC,OAAwB;EACtD,MAAMC,cAAc,GAAG,IAAIC,GAAG,EAAE;EAEhC;;;EAGA,eAAeC,MAAMA,CAAEC,IAAe;IACpC,MAAMC,UAAU,GAAGD,IAAI,CAACE,QAAQ,EAAE,CAACC,KAAK,CAAC,cAAc,CAAC,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,KAAK,EAAE,CAAC;IAC5E,MAAMC,EAAE,GAAGZ,SAAS,CAACO,UAAU,CAAC;IAEhC,MAAMM,YAAY,GAAGD,EAAE,CAACE,SAAS,EAAE;IAEnC,IAAID,YAAY,IAAI,IAAI,EAAE;MACxB,MAAM,IAAIE,KAAK,CAAC,+CAA+C,CAAC;;IAGlE,MAAMC,WAAW,GAAGjB,gBAAgB,CAACc,YAAY,CAAC;IAElD,MAAMX,OAAO,CAACe,SAAS,CAACC,WAAW,CAACC,GAAG,CAACH,WAAW,EAAE,CAACJ,EAAE,CAAC,CAAC;IAE1D,MAAMQ,SAAS,GAAG,MAAMlB,OAAO,CAACmB,iBAAiB,CAACC,cAAc,CAACN,WAAW,CAAC;IAC7E,MAAMO,WAAW,GAAGH,SAAS,CAACI,UAAU,CAACC,WAAW,CAAC,cAAc,CAAC;IAEpEtB,cAAc,CAACuB,GAAG,CAACN,SAAS,CAACO,UAAU,CAACnB,QAAQ,EAAE,EAAEe,WAAW,CAAC;IAChEK,QAAQ,CAACC,aAAa,CAAC,IAAIhC,WAAW,CAAC,WAAW,CAAC,CAAC;EACtD;EAEA;;;;;;;;;;;;;;;;EAgBA,SAASiC,QAAQA,CAAA;IACf,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,MAAMzB,IAAI,IAAIH,cAAc,CAAC6B,MAAM,EAAE,EAAE;MAC1CD,KAAK,CAACE,IAAI,CAAC3B,IAAI,CAAC;;IAElB,OAAOyB,KAAK;EACd;EAEA,MAAMH,QAAQ,GAAaM,MAAM,CAACC,MAAM,CAAC,IAAIrC,YAAY,EAAE,EAAE;IAC3DsC,KAAK,EAAE,MAAAA,CAAA,KAAY,MAAMC,OAAO,CAACC,OAAO,EAAE;IAC1CjC,MAAM;IACNyB;GACD,CAAC;EAEF;EACA5B,OAAO,CAACmB,iBAAiB,CAACkB,gBAAgB,CAAC,iBAAiB,EAAGC,GAAG,IAAI;IACpE,MAAM;MAAEC,MAAM,EAAEC;IAAU,CAAE,GAAGF,GAAG;IAClC,MAAMG,OAAO,GAAGxC,cAAc,CAACyC,MAAM,CAACF,UAAU,CAACf,UAAU,CAACnB,QAAQ,EAAE,CAAC;IAEvE,IAAImC,OAAO,EAAE;MACX;MACAf,QAAQ,CAACC,aAAa,CAAC,IAAIhC,WAAW,CAAC,OAAO,CAAC,CAAC;;EAEpD,CAAC,CAAC;EAEF,OAAO+B,QAAQ;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}