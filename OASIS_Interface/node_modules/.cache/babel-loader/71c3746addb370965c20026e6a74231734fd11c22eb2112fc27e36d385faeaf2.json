{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { namespaceLength, namespace, peerIdToRoutingKey } from 'ipns';\nimport { ipnsValidator } from 'ipns/validator';\nimport { ipnsSelector } from 'ipns/selector';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { PubSubDatastore } from 'datastore-pubsub';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport errcode from 'err-code';\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromString } from '@libp2p/peer-id';\nconst log = logger('ipfs:ipns:pubsub');\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nexport class IpnsPubsubDatastore {\n  /**\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('@libp2p/interface-peer-id').PeerId} peerId\n   */\n  constructor(pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {};\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey);\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put(key, value, options) {\n    try {\n      await this._pubsubDs.put(key, value, options);\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get(key, options) {\n    let res;\n    let err;\n    try {\n      res = await this._pubsubDs.get(key, options);\n    } catch ( /** @type {any} */e) {\n      err = e;\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, namespaceLength);\n    if (uint8ArrayToString(ns) === namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1);\n      const id = base58btc.encode(key.slice(namespaceLength)).substring(1);\n      this._subscriptions[stringifiedTopic] = id;\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err;\n    }\n    return res;\n  }\n\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n  _handleSubscriptionKey(key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc');\n    }\n    const subscriber = this._subscriptions[key];\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY');\n    }\n    try {\n      const k = peerIdToRoutingKey(peerIdFromString(subscriber));\n      return k;\n    } catch ( /** @type {any} */err) {\n      log.error(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n  getSubscriptions() {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean);\n    return subscriptions.map(sub => `${namespace}${sub}`);\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n  async cancel(name) {\n    // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(namespace)) {\n      name = name.substring(namespaceLength);\n    }\n    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name);\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      };\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic);\n    this._pubsubDs.unsubscribe(bufTopic);\n    delete this._subscriptions[stringifiedTopic];\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);\n    return {\n      canceled: true\n    };\n  }\n}","map":{"version":3,"names":["namespaceLength","namespace","peerIdToRoutingKey","ipnsValidator","ipnsSelector","base58btc","PubSubDatastore","fromString","uint8ArrayFromString","toString","uint8ArrayToString","errcode","logger","peerIdFromString","log","IpnsPubsubDatastore","constructor","pubsub","localDatastore","peerId","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","put","key","value","options","err","error","get","res","e","ns","slice","stringifiedTopic","encode","substring","id","Uint8Array","subscriber","Error","k","getSubscriptions","subscriptions","Object","values","filter","Boolean","map","sub","cancel","name","startsWith","keys","find","canceled","bufTopic","unsubscribe"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js"],"sourcesContent":["import { namespaceLength, namespace, peerIdToRoutingKey } from 'ipns'\nimport { ipnsValidator } from 'ipns/validator'\nimport { ipnsSelector } from 'ipns/selector'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { PubSubDatastore } from 'datastore-pubsub'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport errcode from 'err-code'\nimport { logger } from '@libp2p/logger'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\nconst log = logger('ipfs:ipns:pubsub')\n\n/**\n * @typedef {import('@libp2p/interfaces').AbortOptions} AbortOptions\n */\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nexport class IpnsPubsubDatastore {\n  /**\n   * @param {import('@libp2p/interface-pubsub').PubSub} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('@libp2p/interface-peer-id').PeerId} peerId\n   */\n  constructor (pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n\n    this._pubsubDs = new PubSubDatastore(pubsub, localDatastore, peerId, ipnsValidator, ipnsSelector, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   * @param {AbortOptions} [options]\n   */\n  async put (key, value, options) {\n    try {\n      await this._pubsubDs.put(key, value, options)\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   * @param {AbortOptions} [options]\n   */\n  async get (key, options) {\n    let res\n    let err\n\n    try {\n      res = await this._pubsubDs.get(key, options)\n    } catch (/** @type {any} */ e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, namespaceLength)\n\n    if (uint8ArrayToString(ns) === namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1)\n      const id = base58btc.encode(key.slice(namespaceLength)).substring(1)\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n  _handleSubscriptionKey (key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc')\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    try {\n      const k = peerIdToRoutingKey(peerIdFromString(subscriber))\n      return k\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n      throw err\n    }\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(namespace)) {\n      name = name.substring(namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    delete this._subscriptions[stringifiedTopic]\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}