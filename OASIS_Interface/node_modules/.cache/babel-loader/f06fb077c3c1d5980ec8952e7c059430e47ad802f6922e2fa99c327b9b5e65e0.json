{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar MultiRange = require('multi-integer-range').MultiRange;\nvar getPixels = require('get-pixels-frame-info-update');\nvar savePixels = require('@nsfw-filter/save-pixels');\nfunction nopromises() {\n  throw new Error('Promises not supported in your environment. ' + 'Use the callback argument or a Promise polyfill.');\n}\nvar brokenPromise = {\n  then: nopromises,\n  catch: nopromises\n};\nfunction gifFrames(options, callback) {\n  options = options || {};\n  callback = callback || function () {};\n  var promise;\n  var resolve;\n  var reject;\n  if (typeof Promise === 'function') {\n    promise = new Promise(function (_resolve, _reject) {\n      resolve = function (res) {\n        callback(null, res);\n        _resolve(res);\n      };\n      reject = function (err) {\n        callback(err);\n        _reject(err);\n      };\n    });\n  } else {\n    promise = brokenPromise;\n    resolve = function (res) {\n      callback(null, res);\n    };\n    reject = callback;\n  }\n  var url = options.url;\n  if (!url) {\n    reject(new Error('\"url\" option is required.'));\n    return promise;\n  }\n  var frames = options.frames;\n  if (!frames && frames !== 0) {\n    reject(new Error('\"frames\" option is required.'));\n    return promise;\n  }\n  var outputType = options.outputType || 'jpg';\n  var quality = options.quality;\n  var cumulative = options.cumulative;\n  var acceptedFrames = frames === 'all' ? 'all' : new MultiRange(frames);\n\n  // Necessary to check if we're in Node or the browser until this is fixed:\n  // https://github.com/scijs/get-pixels/issues/33\n  var inputType = typeof window === 'undefined' ? 'image/gif' : '.GIF';\n  getPixels(url, inputType, function (err, pixels, framesInfo) {\n    if (err) {\n      reject(err);\n      return;\n    }\n    if (pixels.shape.length < 4) {\n      reject(new Error('\"url\" input should be multi-frame GIF.'));\n      return;\n    }\n    var frameData = [];\n    var maxAccumulatedFrame = 0;\n    for (var i = 0; i < pixels.shape[0]; i++) {\n      if (acceptedFrames !== 'all' && !acceptedFrames.has(i)) {\n        continue;\n      }\n      (function (frameIndex) {\n        frameData.push({\n          getImage: function () {\n            if (cumulative && frameIndex > maxAccumulatedFrame) {\n              // for each frame, replace any invisible pixel with\n              // the corresponding pixel from the previous frame (beginning\n              // with the second frame).\n              // to avoid doing too much work at once we only compute the\n              // frames up to and including the requested frame.\n              var lastFrame = pixels.pick(maxAccumulatedFrame);\n              for (var f = maxAccumulatedFrame + 1; f <= frameIndex; f++) {\n                var frame = pixels.pick(f);\n                for (var x = 0; x < frame.shape[0]; x++) {\n                  for (var y = 0; y < frame.shape[1]; y++) {\n                    if (frame.get(x, y, 3) === 0) {\n                      // if alpha is fully transparent, use the pixel\n                      // from the last frame\n                      frame.set(x, y, 0, lastFrame.get(x, y, 0));\n                      frame.set(x, y, 1, lastFrame.get(x, y, 1));\n                      frame.set(x, y, 2, lastFrame.get(x, y, 2));\n                      frame.set(x, y, 3, lastFrame.get(x, y, 3));\n                    }\n                  }\n                }\n                lastFrame = frame;\n              }\n              maxAccumulatedFrame = frameIndex;\n            }\n            return savePixels(pixels.pick(frameIndex), outputType, {\n              quality: quality\n            });\n          },\n          frameIndex: frameIndex,\n          frameInfo: framesInfo && framesInfo[frameIndex]\n        });\n      })(i);\n    }\n    resolve(frameData);\n  });\n  return promise;\n}\nmodule.exports = gifFrames;","map":{"version":3,"names":["MultiRange","require","getPixels","savePixels","nopromises","Error","brokenPromise","then","catch","gifFrames","options","callback","promise","resolve","reject","Promise","_resolve","_reject","res","err","url","frames","outputType","quality","cumulative","acceptedFrames","inputType","window","pixels","framesInfo","shape","length","frameData","maxAccumulatedFrame","i","has","frameIndex","push","getImage","lastFrame","pick","f","frame","x","y","get","set","frameInfo","module","exports"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/@nsfw-filter+gif-frames@1.0.2/node_modules/@nsfw-filter/gif-frames/gif-frames.js"],"sourcesContent":["var MultiRange = require('multi-integer-range').MultiRange;\nvar getPixels = require('get-pixels-frame-info-update');\nvar savePixels = require('@nsfw-filter/save-pixels');\n\nfunction nopromises () {\n  throw new Error(\n    'Promises not supported in your environment. ' +\n    'Use the callback argument or a Promise polyfill.'\n  );\n}\n\nvar brokenPromise = {\n  then: nopromises,\n  catch: nopromises\n};\n\nfunction gifFrames (options, callback) {\n  options = options || {};\n  callback = callback || function () {};\n\n  var promise;\n  var resolve;\n  var reject;\n  if (typeof Promise === 'function') {\n    promise = new Promise(function (_resolve, _reject) {\n      resolve = function (res) {\n        callback(null, res);\n        _resolve(res);\n      };\n      reject = function (err) {\n        callback(err);\n        _reject(err);\n      };\n    });\n  } else {\n    promise = brokenPromise;\n    resolve = function (res) {\n      callback(null, res);\n    };\n    reject = callback;\n  }\n\n  var url = options.url;\n  if (!url) {\n    reject(new Error('\"url\" option is required.'));\n    return promise;\n  }\n  var frames = options.frames;\n  if (!frames && frames !== 0) {\n    reject(new Error('\"frames\" option is required.'));\n    return promise;\n  }\n  var outputType = options.outputType || 'jpg';\n  var quality = options.quality;\n  var cumulative = options.cumulative;\n\n  var acceptedFrames = frames === 'all' ? 'all' : new MultiRange(frames);\n\n  // Necessary to check if we're in Node or the browser until this is fixed:\n  // https://github.com/scijs/get-pixels/issues/33\n  var inputType = typeof window === 'undefined' ? 'image/gif' : '.GIF';\n  getPixels(url, inputType, function (err, pixels, framesInfo) {\n    if (err) {\n      reject(err);\n      return;\n    }\n    if (pixels.shape.length < 4) {\n      reject(new Error('\"url\" input should be multi-frame GIF.'));\n      return;\n    }\n    var frameData = [];\n    var maxAccumulatedFrame = 0;\n    for (var i = 0; i < pixels.shape[0]; i++) {\n      if (acceptedFrames !== 'all' && !acceptedFrames.has(i)) {\n        continue;\n      }\n      (function (frameIndex) {\n        frameData.push({\n          getImage: function () {\n            if (cumulative && frameIndex > maxAccumulatedFrame) {\n              // for each frame, replace any invisible pixel with\n              // the corresponding pixel from the previous frame (beginning\n              // with the second frame).\n              // to avoid doing too much work at once we only compute the\n              // frames up to and including the requested frame.\n              var lastFrame = pixels.pick(maxAccumulatedFrame);\n              for (var f = maxAccumulatedFrame + 1; f <= frameIndex; f++) {\n                var frame = pixels.pick(f);\n                for (var x = 0; x < frame.shape[0]; x++) {\n                  for (var y = 0; y < frame.shape[1]; y++) {\n                    if (frame.get(x, y, 3) === 0) {\n                      // if alpha is fully transparent, use the pixel\n                      // from the last frame\n                      frame.set(x, y, 0, lastFrame.get(x, y, 0));\n                      frame.set(x, y, 1, lastFrame.get(x, y, 1));\n                      frame.set(x, y, 2, lastFrame.get(x, y, 2));\n                      frame.set(x, y, 3, lastFrame.get(x, y, 3));\n                    }\n                  }\n                }\n                lastFrame = frame;\n              }\n              maxAccumulatedFrame = frameIndex;\n            }\n            return savePixels(pixels.pick(frameIndex), outputType, {\n              quality: quality\n            });\n          },\n          frameIndex: frameIndex,\n          frameInfo: framesInfo && framesInfo[frameIndex]\n        });\n      })(i);\n    }\n    resolve(frameData);\n  });\n\n  return promise;\n}\n\nmodule.exports = gifFrames;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}