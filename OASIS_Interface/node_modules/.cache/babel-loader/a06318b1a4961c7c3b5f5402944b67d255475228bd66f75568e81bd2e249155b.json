{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { logger } from '@libp2p/logger';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { RELAY_CODEC } from './multicodec.js';\nimport { canHop } from './circuit/hop.js';\nimport { namespaceToCid } from './utils.js';\nimport { CIRCUIT_PROTO_CODE, HOP_METADATA_KEY, HOP_METADATA_VALUE, RELAY_RENDEZVOUS_NS } from './constants.js';\nimport sort from 'it-sort';\nimport all from 'it-all';\nimport { pipe } from 'it-pipe';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nconst log = logger('libp2p:auto-relay');\nconst noop = () => {};\nexport class AutoRelay {\n  constructor(components, init) {\n    this.components = components;\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst;\n    this.maxListeners = init.maxListeners ?? 1;\n    this.listenRelays = new Set();\n    this.onError = init.onError ?? noop;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n    this.components.peerStore.addEventListener('change:protocols', evt => {\n      void this._onProtocolChange(evt).catch(err => {\n        log.error(err);\n      });\n    });\n    this.components.connectionManager.addEventListener('peer:disconnect', this._onPeerDisconnected);\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   */\n  async _onProtocolChange(evt) {\n    const {\n      peerId,\n      protocols\n    } = evt.detail;\n    const id = peerId.toString();\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === RELAY_CODEC);\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (hasProtocol == null) {\n      if (this.listenRelays.has(id)) {\n        await this._removeListenRelay(id);\n      }\n      return;\n    }\n    if (this.listenRelays.has(id)) {\n      return;\n    }\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connections = this.components.connectionManager.getConnections(peerId);\n      if (connections.length === 0) {\n        return;\n      }\n      const connection = connections[0];\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`);\n        return;\n      }\n      const supportsHop = await canHop({\n        connection\n      });\n      if (supportsHop) {\n        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n        await this._addListenRelay(connection, id);\n      }\n    } catch (err) {\n      this.onError(err);\n    }\n  }\n  /**\n   * Peer disconnects\n   */\n  _onPeerDisconnected(evt) {\n    const connection = evt.detail;\n    const peerId = connection.remotePeer;\n    const id = peerId.toString();\n    // Not listening on this relay\n    if (!this.listenRelays.has(id)) {\n      return;\n    }\n    this._removeListenRelay(id).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Attempt to listen on the given relay connection\n   */\n  async _addListenRelay(connection, id) {\n    try {\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      }\n      // Get peer known addresses and sort them with public addresses first\n      const remoteAddrs = await pipe(await this.components.peerStore.addressBook.get(connection.remotePeer), source => sort(source, this.addressSorter), async source => await all(source));\n      // Attempt to listen on relay\n      const result = await Promise.all(remoteAddrs.map(async addr => {\n        try {\n          let multiaddr = addr.multiaddr;\n          if (multiaddr.getPeerId() == null) {\n            multiaddr = multiaddr.encapsulate(`/p2p/${connection.remotePeer.toString()}`);\n          }\n          multiaddr = multiaddr.encapsulate('/p2p-circuit');\n          // Announce multiaddrs will update on listen success by TransportManager event being triggered\n          await this.components.transportManager.listen([multiaddr]);\n          return true;\n        } catch (err) {\n          log.error('error listening on circuit address', err);\n          this.onError(err);\n        }\n        return false;\n      }));\n      if (result.includes(true)) {\n        this.listenRelays.add(id);\n      }\n    } catch (err) {\n      this.onError(err);\n      this.listenRelays.delete(id);\n    }\n  }\n  /**\n   * Remove listen relay\n   */\n  async _removeListenRelay(id) {\n    if (this.listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id]);\n    }\n  }\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   */\n  async _listenOnAvailableHopRelays(peersToIgnore = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this.listenRelays.size >= this.maxListeners) {\n      return;\n    }\n    const knownHopsToDial = [];\n    const peers = await this.components.peerStore.all();\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for (const {\n      id,\n      metadata\n    } of peers) {\n      const idStr = id.toString();\n      // Continue to next if listening on this or peer to ignore\n      if (this.listenRelays.has(idStr)) {\n        continue;\n      }\n      if (peersToIgnore.includes(idStr)) {\n        continue;\n      }\n      const supportsHop = metadata.get(HOP_METADATA_KEY);\n      // Continue to next if it does not support Hop\n      if (supportsHop == null || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue;\n      }\n      const connections = this.components.connectionManager.getConnections(id);\n      // If not connected, store for possible later use.\n      if (connections.length === 0) {\n        knownHopsToDial.push(id);\n        continue;\n      }\n      await this._addListenRelay(connections[0], idStr);\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    }\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId);\n      // Check if already listening on enough relays\n      if (this.listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    }\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);\n      for await (const provider of this.components.contentRouting.findProviders(cid)) {\n        if (provider.multiaddrs.length === 0) {\n          continue;\n        }\n        const peerId = provider.id;\n        if (peerId.equals(this.components.peerId)) {\n          // Skip the provider if it's us as dialing will fail\n          continue;\n        }\n        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs);\n        await this._tryToListenOnRelay(peerId);\n        // Check if already listening on enough relays\n        if (this.listenRelays.size >= this.maxListeners) {\n          return;\n        }\n      }\n    } catch (err) {\n      this.onError(err);\n    }\n  }\n  async _tryToListenOnRelay(peerId) {\n    try {\n      const connection = await this.components.connectionManager.openConnection(peerId);\n      await this._addListenRelay(connection, peerId.toString());\n    } catch (err) {\n      log.error('Could not use %p as relay', peerId, err);\n      this.onError(err, `could not connect and listen on known hop relay ${peerId.toString()}`);\n    }\n  }\n}","map":{"version":3,"names":["logger","fromString","uint8ArrayFromString","toString","uint8ArrayToString","RELAY_CODEC","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","sort","all","pipe","publicAddressesFirst","log","noop","AutoRelay","constructor","components","init","addressSorter","maxListeners","listenRelays","Set","onError","_onProtocolChange","bind","_onPeerDisconnected","peerStore","addEventListener","evt","catch","err","error","connectionManager","peerId","protocols","detail","id","hasProtocol","find","protocol","has","_removeListenRelay","connections","getConnections","length","connection","remoteAddr","protoCodes","includes","supportsHop","metadataBook","setValue","_addListenRelay","remotePeer","size","remoteAddrs","addressBook","get","source","result","Promise","map","addr","multiaddr","getPeerId","encapsulate","transportManager","listen","add","delete","_listenOnAvailableHopRelays","peersToIgnore","knownHopsToDial","peers","metadata","idStr","push","_tryToListenOnRelay","cid","provider","contentRouting","findProviders","multiaddrs","equals","openConnection"],"sources":["../../../src/circuit/auto-relay.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}