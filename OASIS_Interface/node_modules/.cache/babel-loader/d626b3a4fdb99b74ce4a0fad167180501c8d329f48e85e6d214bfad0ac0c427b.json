{"ast":null,"code":"import errCode from 'err-code';\nimport { updateTree } from './utils/update-tree.js';\nimport { updateMfsRoot } from './utils/update-mfs-root.js';\nimport { removeLink } from './utils/remove-link.js';\nimport { toMfsPath } from './utils/to-mfs-path.js';\nimport { toTrail } from './utils/to-trail.js';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport mergeOpts from 'merge-options';\nconst mergeOptions = mergeOpts.bind({\n  ignoreUndefined: true\n});\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n\n/**\n * @param {MfsContext} context\n */\nexport function createRm(context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"rm\"]}\n   */\n  async function mfsRm(paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts);\n    if (!Array.isArray(paths)) {\n      paths = [paths];\n    }\n    const sources = await Promise.all(paths.map(path => toMfsPath(context, path, options)));\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n  return withTimeoutOption(mfsRm);\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options);\n  const trail = await toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n  }\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n  }\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.cid = cid;\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options);\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options);\n};","map":{"version":3,"names":["errCode","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOpts","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","createRm","context","mfsRm","paths","opts","options","Array","isArray","sources","Promise","all","map","path","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","cid","parentCid","name","newRootCid"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/files/rm.js"],"sourcesContent":["import errCode from 'err-code'\nimport { updateTree } from './utils/update-tree.js'\nimport { updateMfsRoot } from './utils/update-mfs-root.js'\nimport { removeLink } from './utils/remove-link.js'\nimport { toMfsPath } from './utils/to-mfs-path.js'\nimport { toTrail } from './utils/to-trail.js'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport mergeOpts from 'merge-options'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').Version} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nexport function createRm (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API<{}>[\"rm\"]}\n   */\n  async function mfsRm (paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(paths)) {\n      paths = [paths]\n    }\n\n    const sources = await Promise.all(\n      paths.map(path => toMfsPath(context, path, options))\n    )\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')\n      }\n    })\n\n    for (const source of sources) {\n      await removePath(context, source.path, options)\n    }\n  }\n\n  return withTimeoutOption(mfsRm)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options)\n  const trail = await toTrail(context, mfsPath.mfsPath)\n  const child = trail[trail.length - 1]\n  trail.pop()\n  const parent = trail[trail.length - 1]\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.cid = cid\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,UAAU;AAC9B,SAASC,UAAU,QAAQ,wBAAwB;AACnD,SAASC,aAAa,QAAQ,4BAA4B;AAC1D,SAASC,UAAU,QAAQ,wBAAwB;AACnD,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,iBAAiB,QAAQ,qCAAqC;AACvE,OAAOC,SAAS,MAAM,eAAe;AAErC,MAAMC,YAAY,GAAGD,SAAS,CAACE,IAAI,CAAC;EAAEC,eAAe,EAAE;AAAK,CAAC,CAAC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,cAAc,GAAG;EACrBC,SAAS,EAAE,KAAK;EAChBC,UAAU,EAAE,CAAC;EACbC,OAAO,EAAE,UAAU;EACnBC,KAAK,EAAE,IAAI;EACXC,mBAAmB,EAAE;AACvB,CAAC;;AAED;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAAEC,OAAO,EAAE;EACjC;AACF;AACA;EACE,eAAeC,KAAKA,CAAEC,KAAK,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAE;IACtC;IACA,MAAMC,OAAO,GAAGd,YAAY,CAACG,cAAc,EAAEU,IAAI,CAAC;IAElD,IAAI,CAACE,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;MACzBA,KAAK,GAAG,CAACA,KAAK,CAAC;IACjB;IAEA,MAAMK,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAG,CAC/BP,KAAK,CAACQ,GAAG,CAACC,IAAI,IAAIzB,SAAS,CAACc,OAAO,EAAEW,IAAI,EAAEP,OAAO,CAAC,CACrD,CAAC;IAED,IAAI,CAACG,OAAO,CAACK,MAAM,EAAE;MACnB,MAAM9B,OAAO,CAAC,IAAI+B,KAAK,CAAC,2CAA2C,CAAC,EAAE,oBAAoB,CAAC;IAC7F;IAEAN,OAAO,CAACO,OAAO,CAACC,MAAM,IAAI;MACxB,IAAIA,MAAM,CAACJ,IAAI,KAAK,GAAG,EAAE;QACvB,MAAM7B,OAAO,CAAC,IAAI+B,KAAK,CAAC,oBAAoB,CAAC,EAAE,oBAAoB,CAAC;MACtE;IACF,CAAC,CAAC;IAEF,KAAK,MAAME,MAAM,IAAIR,OAAO,EAAE;MAC5B,MAAMS,UAAU,CAAChB,OAAO,EAAEe,MAAM,CAACJ,IAAI,EAAEP,OAAO,CAAC;IACjD;EACF;EAEA,OAAOhB,iBAAiB,CAACa,KAAK,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMe,UAAU,GAAG,MAAAA,CAAOhB,OAAO,EAAEW,IAAI,EAAEP,OAAO,KAAK;EACnD,MAAMa,OAAO,GAAG,MAAM/B,SAAS,CAACc,OAAO,EAAEW,IAAI,EAAEP,OAAO,CAAC;EACvD,MAAMc,KAAK,GAAG,MAAM/B,OAAO,CAACa,OAAO,EAAEiB,OAAO,CAACA,OAAO,CAAC;EACrD,MAAME,KAAK,GAAGD,KAAK,CAACA,KAAK,CAACN,MAAM,GAAG,CAAC,CAAC;EACrCM,KAAK,CAACE,GAAG,CAAC,CAAC;EACX,MAAMC,MAAM,GAAGH,KAAK,CAACA,KAAK,CAACN,MAAM,GAAG,CAAC,CAAC;EAEtC,IAAI,CAACS,MAAM,EAAE;IACX,MAAMvC,OAAO,CAAC,IAAI+B,KAAK,CAAE,GAAEF,IAAK,iBAAgB,CAAC,EAAE,eAAe,CAAC;EACrE;EAEA,IAAIQ,KAAK,CAACG,IAAI,KAAK,WAAW,IAAI,CAAClB,OAAO,CAACV,SAAS,EAAE;IACpD,MAAMZ,OAAO,CAAC,IAAI+B,KAAK,CAAE,GAAEF,IAAK,+CAA8C,CAAC,EAAE,aAAa,CAAC;EACjG;EAEA,MAAM;IACJY;EACF,CAAC,GAAG,MAAMtC,UAAU,CAACe,OAAO,EAAE;IAC5BwB,SAAS,EAAEH,MAAM,CAACE,GAAG;IACrBE,IAAI,EAAEN,KAAK,CAACM,IAAI;IAChB7B,OAAO,EAAEQ,OAAO,CAACR,OAAO;IACxBD,UAAU,EAAES,OAAO,CAACT,UAAU;IAC9BE,KAAK,EAAEO,OAAO,CAACP,KAAK;IACpBC,mBAAmB,EAAEM,OAAO,CAACN;EAC/B,CAAC,CAAC;EAEFuB,MAAM,CAACE,GAAG,GAAGA,GAAG;;EAEhB;EACA,MAAMG,UAAU,GAAG,MAAM3C,UAAU,CAACiB,OAAO,EAAEkB,KAAK,EAAEd,OAAO,CAAC;;EAE5D;EACA,MAAMpB,aAAa,CAACgB,OAAO,EAAE0B,UAAU,EAAEtB,OAAO,CAAC;AACnD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}