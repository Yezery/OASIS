{"ast":null,"code":"import { Key } from 'interface-datastore/key';\nimport { CID } from 'multiformats';\nimport * as raw from 'multiformats/codecs/raw';\nimport errCode from 'err-code';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as Digest from 'multiformats/hashes/digest';\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} c\n */\nexport function cidToKey(c) {\n  const cid = CID.asCID(c);\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n  const encoded = base32.encode(cid.multihash.bytes);\n  return new Key('/' + encoded.slice(1).toUpperCase(), false);\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n */\nexport function keyToCid(key) {\n  // Block key is of the form /<base32 encoded string>\n  return CID.createV1(raw.code, keyToMultihash(key));\n}\n\n/**\n * @param {Key | string} key\n */\nexport function keyToMultihash(key) {\n  return Digest.decode(base32.decode(`b${key.toString().toLowerCase().substring(1)}`));\n}","map":{"version":3,"names":["Key","CID","raw","errCode","base32","Digest","cidToKey","c","cid","asCID","Error","encoded","encode","multihash","bytes","slice","toUpperCase","keyToCid","key","createV1","code","keyToMultihash","decode","toString","toLowerCase","substring"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/utils/blockstore.js"],"sourcesContent":["import { Key } from 'interface-datastore/key'\nimport { CID } from 'multiformats'\nimport * as raw from 'multiformats/codecs/raw'\nimport errCode from 'err-code'\nimport { base32 } from 'multiformats/bases/base32'\nimport * as Digest from 'multiformats/hashes/digest'\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} c\n */\nexport function cidToKey (c) {\n  const cid = CID.asCID(c)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  const encoded = base32.encode(cid.multihash.bytes)\n\n  return new Key('/' + encoded.slice(1).toUpperCase(), false)\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n */\nexport function keyToCid (key) {\n  // Block key is of the form /<base32 encoded string>\n  return CID.createV1(raw.code, keyToMultihash(key))\n}\n\n/**\n * @param {Key | string} key\n */\nexport function keyToMultihash (key) {\n  return Digest.decode(base32.decode(`b${key.toString().toLowerCase().substring(1)}`))\n}\n"],"mappings":"AAAA,SAASA,GAAG,QAAQ,yBAAyB;AAC7C,SAASC,GAAG,QAAQ,cAAc;AAClC,OAAO,KAAKC,GAAG,MAAM,yBAAyB;AAC9C,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,MAAM,QAAQ,2BAA2B;AAClD,OAAO,KAAKC,MAAM,MAAM,4BAA4B;;AAEpD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAAEC,CAAC,EAAE;EAC3B,MAAMC,GAAG,GAAGP,GAAG,CAACQ,KAAK,CAACF,CAAC,CAAC;EAExB,IAAIC,GAAG,IAAI,IAAI,EAAE;IACf,MAAML,OAAO,CAAC,IAAIO,KAAK,CAAC,iBAAiB,CAAC,EAAE,iBAAiB,CAAC;EAChE;EAEA,MAAMC,OAAO,GAAGP,MAAM,CAACQ,MAAM,CAACJ,GAAG,CAACK,SAAS,CAACC,KAAK,CAAC;EAElD,OAAO,IAAId,GAAG,CAAC,GAAG,GAAGW,OAAO,CAACI,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EAAE,KAAK,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAAEC,GAAG,EAAE;EAC7B;EACA,OAAOjB,GAAG,CAACkB,QAAQ,CAACjB,GAAG,CAACkB,IAAI,EAAEC,cAAc,CAACH,GAAG,CAAC,CAAC;AACpD;;AAEA;AACA;AACA;AACA,OAAO,SAASG,cAAcA,CAAEH,GAAG,EAAE;EACnC,OAAOb,MAAM,CAACiB,MAAM,CAAClB,MAAM,CAACkB,MAAM,CAAE,IAAGJ,GAAG,CAACK,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,CAAE,EAAC,CAAC,CAAC;AACtF"},"metadata":{},"sourceType":"module","externalDependencies":[]}