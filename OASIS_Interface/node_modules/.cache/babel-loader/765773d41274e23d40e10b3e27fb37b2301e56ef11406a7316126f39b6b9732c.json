{"ast":null,"code":"import { logger } from '@libp2p/logger';\nconst log = logger('ipfs:mfs-preload');\n\n/**\n * @typedef {PreloadOptions & MFSPreloadOptions} Options\n * @typedef {object} MFSPreloadOptions\n * @property {number} [interval]\n * @typedef {import('./types').PreloadOptions} PreloadOptions\n */\n\n/**\n * @param {object} config\n * @param {import('./types').Preload} config.preload\n * @param {import('ipfs-core-types/src/files').API} config.files\n * @param {Options} [config.options]\n */\nexport function createMfsPreloader({\n  preload,\n  files,\n  options = {}\n}) {\n  options.interval = options.interval || 30 * 1000;\n  if (!options.enabled) {\n    log('MFS preload disabled');\n    const noop = async () => {};\n    return {\n      start: noop,\n      stop: noop\n    };\n  }\n  let rootCid = '';\n  /** @type {any} */\n  let timeoutId;\n  const preloadMfs = async () => {\n    try {\n      const stats = await files.stat('/');\n      const nextRootCid = stats.cid.toString();\n      if (rootCid !== nextRootCid) {\n        log(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);\n        await preload(stats.cid);\n        rootCid = nextRootCid;\n      }\n    } catch ( /** @type {any} */err) {\n      log.error('failed to preload MFS root', err);\n    } finally {\n      timeoutId = setTimeout(preloadMfs, options.interval);\n    }\n  };\n  return {\n    /**\n     * @returns {Promise<void>}\n     */\n    async start() {\n      const stats = await files.stat('/');\n      rootCid = stats.cid.toString();\n      log(`monitoring MFS root ${stats.cid}`);\n      timeoutId = setTimeout(preloadMfs, options.interval);\n    },\n    /**\n     * @returns {void}\n     */\n    stop() {\n      clearTimeout(timeoutId);\n    }\n  };\n}","map":{"version":3,"names":["logger","log","createMfsPreloader","preload","files","options","interval","enabled","noop","start","stop","rootCid","timeoutId","preloadMfs","stats","stat","nextRootCid","cid","toString","err","error","setTimeout","clearTimeout"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/mfs-preload.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\n\nconst log = logger('ipfs:mfs-preload')\n\n/**\n * @typedef {PreloadOptions & MFSPreloadOptions} Options\n * @typedef {object} MFSPreloadOptions\n * @property {number} [interval]\n * @typedef {import('./types').PreloadOptions} PreloadOptions\n */\n\n/**\n * @param {object} config\n * @param {import('./types').Preload} config.preload\n * @param {import('ipfs-core-types/src/files').API} config.files\n * @param {Options} [config.options]\n */\nexport function createMfsPreloader ({ preload, files, options = {} }) {\n  options.interval = options.interval || 30 * 1000\n\n  if (!options.enabled) {\n    log('MFS preload disabled')\n    const noop = async () => {}\n    return { start: noop, stop: noop }\n  }\n\n  let rootCid = ''\n  /** @type {any} */\n  let timeoutId\n\n  const preloadMfs = async () => {\n    try {\n      const stats = await files.stat('/')\n      const nextRootCid = stats.cid.toString()\n\n      if (rootCid !== nextRootCid) {\n        log(`preloading updated MFS root ${rootCid} -> ${stats.cid}`)\n        await preload(stats.cid)\n        rootCid = nextRootCid\n      }\n    } catch (/** @type {any} */ err) {\n      log.error('failed to preload MFS root', err)\n    } finally {\n      timeoutId = setTimeout(preloadMfs, options.interval)\n    }\n  }\n\n  return {\n    /**\n     * @returns {Promise<void>}\n     */\n    async start () {\n      const stats = await files.stat('/')\n      rootCid = stats.cid.toString()\n      log(`monitoring MFS root ${stats.cid}`)\n      timeoutId = setTimeout(preloadMfs, options.interval)\n    },\n    /**\n     * @returns {void}\n     */\n    stop () {\n      clearTimeout(timeoutId)\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,gBAAgB;AAEvC,MAAMC,GAAG,GAAGD,MAAM,CAAC,kBAAkB,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,kBAAkBA,CAAE;EAAEC,OAAO;EAAEC,KAAK;EAAEC,OAAO,GAAG,CAAC;AAAE,CAAC,EAAE;EACpEA,OAAO,CAACC,QAAQ,GAAGD,OAAO,CAACC,QAAQ,IAAI,EAAE,GAAG,IAAI;EAEhD,IAAI,CAACD,OAAO,CAACE,OAAO,EAAE;IACpBN,GAAG,CAAC,sBAAsB,CAAC;IAC3B,MAAMO,IAAI,GAAG,MAAAA,CAAA,KAAY,CAAC,CAAC;IAC3B,OAAO;MAAEC,KAAK,EAAED,IAAI;MAAEE,IAAI,EAAEF;IAAK,CAAC;EACpC;EAEA,IAAIG,OAAO,GAAG,EAAE;EAChB;EACA,IAAIC,SAAS;EAEb,MAAMC,UAAU,GAAG,MAAAA,CAAA,KAAY;IAC7B,IAAI;MACF,MAAMC,KAAK,GAAG,MAAMV,KAAK,CAACW,IAAI,CAAC,GAAG,CAAC;MACnC,MAAMC,WAAW,GAAGF,KAAK,CAACG,GAAG,CAACC,QAAQ,CAAC,CAAC;MAExC,IAAIP,OAAO,KAAKK,WAAW,EAAE;QAC3Bf,GAAG,CAAE,+BAA8BU,OAAQ,OAAMG,KAAK,CAACG,GAAI,EAAC,CAAC;QAC7D,MAAMd,OAAO,CAACW,KAAK,CAACG,GAAG,CAAC;QACxBN,OAAO,GAAGK,WAAW;MACvB;IACF,CAAC,CAAC,QAAO,kBAAmBG,GAAG,EAAE;MAC/BlB,GAAG,CAACmB,KAAK,CAAC,4BAA4B,EAAED,GAAG,CAAC;IAC9C,CAAC,SAAS;MACRP,SAAS,GAAGS,UAAU,CAACR,UAAU,EAAER,OAAO,CAACC,QAAQ,CAAC;IACtD;EACF,CAAC;EAED,OAAO;IACL;AACJ;AACA;IACI,MAAMG,KAAKA,CAAA,EAAI;MACb,MAAMK,KAAK,GAAG,MAAMV,KAAK,CAACW,IAAI,CAAC,GAAG,CAAC;MACnCJ,OAAO,GAAGG,KAAK,CAACG,GAAG,CAACC,QAAQ,CAAC,CAAC;MAC9BjB,GAAG,CAAE,uBAAsBa,KAAK,CAACG,GAAI,EAAC,CAAC;MACvCL,SAAS,GAAGS,UAAU,CAACR,UAAU,EAAER,OAAO,CAACC,QAAQ,CAAC;IACtD,CAAC;IACD;AACJ;AACA;IACII,IAAIA,CAAA,EAAI;MACNY,YAAY,CAACV,SAAS,CAAC;IACzB;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}