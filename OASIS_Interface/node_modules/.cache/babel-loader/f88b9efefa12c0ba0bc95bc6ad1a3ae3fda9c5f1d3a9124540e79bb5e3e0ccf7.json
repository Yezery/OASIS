{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/yezery/Oasis/OASIS/node_modules/.store/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/Users/yezery/Oasis/OASIS/node_modules/.store/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/Users/yezery/Oasis/OASIS/node_modules/.store/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _defineProperty from \"/Users/yezery/Oasis/OASIS/node_modules/.store/@babel+runtime@7.22.15/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nlet _Symbol$iterator;\n/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"next\", void 0);\n    this.value = value;\n  }\n}\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\n_Symbol$iterator = Symbol.iterator;\nexport default class Queue {\n  constructor() {\n    _classPrivateFieldInitSpec(this, _head, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tail, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: void 0\n    });\n    this.clear();\n  }\n  enqueue(value) {\n    var _this$size, _this$size2;\n    const node = new Node(value);\n    if (_classPrivateFieldGet(this, _head)) {\n      _classPrivateFieldGet(this, _tail).next = node;\n      _classPrivateFieldSet(this, _tail, node);\n    } else {\n      _classPrivateFieldSet(this, _head, node);\n      _classPrivateFieldSet(this, _tail, node);\n    }\n    _classPrivateFieldSet(this, _size, (_this$size = _classPrivateFieldGet(this, _size), _this$size2 = _this$size++, _this$size)), _this$size2;\n  }\n  dequeue() {\n    var _this$size3, _this$size4;\n    const current = _classPrivateFieldGet(this, _head);\n    if (!current) {\n      return;\n    }\n    _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _head).next);\n    _classPrivateFieldSet(this, _size, (_this$size3 = _classPrivateFieldGet(this, _size), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n    return current.value;\n  }\n  clear() {\n    _classPrivateFieldSet(this, _head, undefined);\n    _classPrivateFieldSet(this, _tail, undefined);\n    _classPrivateFieldSet(this, _size, 0);\n  }\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  *[_Symbol$iterator]() {\n    let current = _classPrivateFieldGet(this, _head);\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n}","map":{"version":3,"names":["Node","constructor","value","_defineProperty","_head","WeakMap","_tail","_size","_Symbol$iterator","Symbol","iterator","Queue","_classPrivateFieldInitSpec","writable","clear","enqueue","_this$size","_this$size2","node","_classPrivateFieldGet","next","_classPrivateFieldSet","dequeue","_this$size3","_this$size4","current","undefined","size"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/yocto-queue@1.0.0/node_modules/yocto-queue/index.js"],"sourcesContent":["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;;AAEA,MAAMA,IAAI,CAAC;EAIVC,WAAWA,CAACC,KAAK,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAClB,IAAI,CAACD,KAAK,GAAGA,KAAK;EACnB;AACD;AAAC,IAAAE,KAAA,oBAAAC,OAAA;AAAA,IAAAC,KAAA,oBAAAD,OAAA;AAAA,IAAAE,KAAA,oBAAAF,OAAA;AAAAG,gBAAA,GA8CGC,MAAM,CAACC,QAAQ;AA5CnB,eAAe,MAAMC,KAAK,CAAC;EAK1BV,WAAWA,CAAA,EAAG;IAAAW,0BAAA,OAAAR,KAAA;MAAAS,QAAA;MAAAX,KAAA;IAAA;IAAAU,0BAAA,OAAAN,KAAA;MAAAO,QAAA;MAAAX,KAAA;IAAA;IAAAU,0BAAA,OAAAL,KAAA;MAAAM,QAAA;MAAAX,KAAA;IAAA;IACb,IAAI,CAACY,KAAK,CAAC,CAAC;EACb;EAEAC,OAAOA,CAACb,KAAK,EAAE;IAAA,IAAAc,UAAA,EAAAC,WAAA;IACd,MAAMC,IAAI,GAAG,IAAIlB,IAAI,CAACE,KAAK,CAAC;IAE5B,IAAAiB,qBAAA,CAAI,IAAI,EAAAf,KAAA,GAAQ;MACfe,qBAAA,KAAI,EAAAb,KAAA,EAAOc,IAAI,GAAGF,IAAI;MACtBG,qBAAA,KAAI,EAAAf,KAAA,EAASY,IAAI;IAClB,CAAC,MAAM;MACNG,qBAAA,KAAI,EAAAjB,KAAA,EAASc,IAAI;MACjBG,qBAAA,KAAI,EAAAf,KAAA,EAASY,IAAI;IAClB;IAEAG,qBAAA,KAAI,EAAAd,KAAA,GAAAS,UAAA,GAAAG,qBAAA,CAAJ,IAAI,EAAAZ,KAAA,GAAAU,WAAA,GAAAD,UAAA,IAAAA,UAAA,IAAAC,WAAA;EACL;EAEAK,OAAOA,CAAA,EAAG;IAAA,IAAAC,WAAA,EAAAC,WAAA;IACT,MAAMC,OAAO,GAAAN,qBAAA,CAAG,IAAI,EAAAf,KAAA,CAAM;IAC1B,IAAI,CAACqB,OAAO,EAAE;MACb;IACD;IAEAJ,qBAAA,KAAI,EAAAjB,KAAA,EAASe,qBAAA,KAAI,EAAAf,KAAA,EAAOgB,IAAI;IAC5BC,qBAAA,KAAI,EAAAd,KAAA,GAAAgB,WAAA,GAAAJ,qBAAA,CAAJ,IAAI,EAAAZ,KAAA,GAAAiB,WAAA,GAAAD,WAAA,IAAAA,WAAA,IAAAC,WAAA;IACJ,OAAOC,OAAO,CAACvB,KAAK;EACrB;EAEAY,KAAKA,CAAA,EAAG;IACPO,qBAAA,KAAI,EAAAjB,KAAA,EAASsB,SAAS;IACtBL,qBAAA,KAAI,EAAAf,KAAA,EAASoB,SAAS;IACtBL,qBAAA,KAAI,EAAAd,KAAA,EAAS,CAAC;EACf;EAEA,IAAIoB,IAAIA,CAAA,EAAG;IACV,OAAAR,qBAAA,CAAO,IAAI,EAAAZ,KAAA;EACZ;EAEA,EAAAC,gBAAA,IAAsB;IACrB,IAAIiB,OAAO,GAAAN,qBAAA,CAAG,IAAI,EAAAf,KAAA,CAAM;IAExB,OAAOqB,OAAO,EAAE;MACf,MAAMA,OAAO,CAACvB,KAAK;MACnBuB,OAAO,GAAGA,OAAO,CAACL,IAAI;IACvB;EACD;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}