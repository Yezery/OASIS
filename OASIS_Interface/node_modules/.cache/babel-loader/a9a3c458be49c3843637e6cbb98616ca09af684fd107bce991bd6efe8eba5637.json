{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport { logger } from '@libp2p/logger';\nimport { pushable } from 'it-pushable';\nimport drain from 'it-drain';\nconst log = logger('datastore:core:tiered');\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nexport class TieredDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put(key, value, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value, options)));\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res) return res;\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    throw Errors.notFoundError();\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch ( /** @type {any} */err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async *putMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      });\n      drain(store.putMany(source, options)).catch(err => {\n        // store threw while putting, make sure we bubble the error up\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(pair));\n        yield pair;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async *deleteMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      });\n      drain(store.deleteMany(source, options)).catch(err => {\n        // store threw while deleting, make sure we bubble the error up\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(key));\n        yield key;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n}","map":{"version":3,"names":["BaseDatastore","Errors","logger","pushable","drain","log","TieredDatastore","constructor","stores","slice","open","Promise","all","map","store","err","dbOpenFailedError","put","key","value","options","dbWriteFailedError","get","res","error","notFoundError","has","s","delete","dbDeleteFailedError","putMany","source","pushables","objectMode","catch","pair","forEach","p","push","end","deleteMany","close","batch","batches","b","commit","query","q","length","queryKeys"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/datastore-core@8.0.4/node_modules/datastore-core/src/tiered.js"],"sourcesContent":["import { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport { logger } from '@libp2p/logger'\nimport { pushable } from 'it-pushable'\nimport drain from 'it-drain'\n\nconst log = logger('datastore:core:tiered')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Key} Key\n * @typedef {import('interface-datastore').Pair} Pair\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nexport class TieredDatastore extends BaseDatastore {\n  /**\n   * @param {Datastore[]} stores\n   */\n  constructor (stores) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await Promise.all(this.stores.map((store) => store.open()))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (key, value, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value, options)))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async get (key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n        if (res) return res\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async has (key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  async delete (key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)))\n    } catch (/** @type {any} */ err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      })\n\n      drain(store.putMany(source, options))\n        .catch(err => {\n          // store threw while putting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(pair))\n\n        yield pair\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    let error\n    const pushables = this.stores.map(store => {\n      const source = pushable({\n        objectMode: true\n      })\n\n      drain(store.deleteMany(source, options))\n        .catch(err => {\n          // store threw while deleting, make sure we bubble the error up\n          error = err\n        })\n\n      return source\n    })\n\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error\n        }\n\n        pushables.forEach(p => p.push(key))\n\n        yield key\n      }\n    } finally {\n      pushables.forEach(p => p.end())\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}