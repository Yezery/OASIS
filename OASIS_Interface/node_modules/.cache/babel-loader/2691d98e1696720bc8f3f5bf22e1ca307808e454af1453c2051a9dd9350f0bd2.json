{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { logger } from '@libp2p/logger';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { codes } from './errors.js';\nimport { Key } from 'interface-datastore/key';\nimport { base32 } from 'multiformats/bases/base32';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { Peer as PeerPB } from './pb/peer.js';\nimport mortice from 'mortice';\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals';\nconst log = logger('libp2p:peer-store:store');\nconst NAMESPACE_COMMON = '/peers/';\nexport class PersistentStore {\n  constructor(components) {\n    this.components = components;\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    });\n  }\n  _peerIdToDatastoreKey(peerId) {\n    if (peerId.type == null) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw new CodeError('peerId must be an instance of peer-id', codes.ERR_INVALID_PARAMETERS);\n    }\n    const b32key = peerId.toCID().toString();\n    return new Key(`${NAMESPACE_COMMON}${b32key}`);\n  }\n  async has(peerId) {\n    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId));\n  }\n  async delete(peerId) {\n    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId));\n  }\n  async load(peerId) {\n    const buf = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId));\n    const peer = PeerPB.decode(buf);\n    const metadata = new Map();\n    for (const meta of peer.metadata) {\n      metadata.set(meta.key, meta.value);\n    }\n    return {\n      ...peer,\n      id: peerId,\n      addresses: peer.addresses.map(({\n        multiaddr: ma,\n        isCertified\n      }) => {\n        return {\n          multiaddr: multiaddr(ma),\n          isCertified: isCertified ?? false\n        };\n      }),\n      metadata,\n      pubKey: peer.pubKey ?? undefined,\n      peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined\n    };\n  }\n  async save(peer) {\n    if (peer.pubKey != null && peer.id.publicKey != null && !uint8arrayEquals(peer.pubKey, peer.id.publicKey)) {\n      log.error('peer publicKey bytes do not match peer id publicKey bytes');\n      throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS);\n    }\n    // dedupe addresses\n    const addressSet = new Set();\n    const addresses = peer.addresses.filter(address => {\n      if (addressSet.has(address.multiaddr.toString())) {\n        return false;\n      }\n      addressSet.add(address.multiaddr.toString());\n      return true;\n    }).sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());\n    }).map(({\n      multiaddr,\n      isCertified\n    }) => ({\n      multiaddr: multiaddr.bytes,\n      isCertified\n    }));\n    const metadata = [];\n    [...peer.metadata.keys()].sort().forEach(key => {\n      const value = peer.metadata.get(key);\n      if (value != null) {\n        metadata.push({\n          key,\n          value\n        });\n      }\n    });\n    const buf = PeerPB.encode({\n      addresses,\n      protocols: peer.protocols.sort(),\n      pubKey: peer.pubKey,\n      metadata,\n      peerRecordEnvelope: peer.peerRecordEnvelope\n    });\n    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf.subarray());\n    return await this.load(peer.id);\n  }\n  async patch(peerId, data) {\n    const peer = await this.load(peerId);\n    return await this._patch(peerId, data, peer);\n  }\n  async patchOrCreate(peerId, data) {\n    let peer;\n    try {\n      peer = await this.load(peerId);\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n    return await this._patch(peerId, data, peer);\n  }\n  async _patch(peerId, data, peer) {\n    return await this.save({\n      ...peer,\n      ...data,\n      id: peerId\n    });\n  }\n  async merge(peerId, data) {\n    const peer = await this.load(peerId);\n    return await this._merge(peerId, data, peer);\n  }\n  async mergeOrCreate(peerId, data) {\n    /** @type {Peer} */\n    let peer;\n    try {\n      peer = await this.load(peerId);\n    } catch (err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n    return await this._merge(peerId, data, peer);\n  }\n  async _merge(peerId, data, peer) {\n    // if the peer has certified addresses, use those in\n    // favour of the supplied versions\n    const addresses = new Map();\n    peer.addresses.forEach(addr => {\n      addresses.set(addr.multiaddr.toString(), addr.isCertified);\n    });\n    (data.addresses ?? []).forEach(addr => {\n      const addrString = addr.multiaddr.toString();\n      const isAlreadyCertified = Boolean(addresses.get(addrString));\n      const isCertified = isAlreadyCertified || addr.isCertified;\n      addresses.set(addrString, isCertified);\n    });\n    return await this.save({\n      id: peerId,\n      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {\n        return {\n          multiaddr: multiaddr(addrStr),\n          isCertified\n        };\n      }),\n      protocols: Array.from(new Set([...(peer.protocols ?? []), ...(data.protocols ?? [])])),\n      metadata: new Map([...(peer.metadata?.entries() ?? []), ...(data.metadata?.entries() ?? [])]),\n      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : undefined),\n      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : undefined)\n    });\n  }\n  async *all() {\n    for await (const key of this.components.datastore.queryKeys({\n      prefix: NAMESPACE_COMMON\n    })) {\n      // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n      const base32Str = key.toString().split('/')[2];\n      const buf = base32.decode(base32Str);\n      yield this.load(peerIdFromBytes(buf));\n    }\n  }\n}","map":{"version":3,"names":["logger","peerIdFromBytes","CodeError","codes","Key","base32","multiaddr","Peer","PeerPB","mortice","equals","uint8arrayEquals","log","NAMESPACE_COMMON","PersistentStore","constructor","components","lock","name","singleProcess","_peerIdToDatastoreKey","peerId","type","error","ERR_INVALID_PARAMETERS","b32key","toCID","toString","has","datastore","delete","load","buf","get","peer","decode","metadata","Map","meta","set","key","value","id","addresses","map","ma","isCertified","pubKey","undefined","peerRecordEnvelope","save","publicKey","addressSet","Set","filter","address","add","sort","a","b","localeCompare","bytes","keys","forEach","push","encode","protocols","put","subarray","patch","data","_patch","patchOrCreate","err","code","ERR_NOT_FOUND","merge","_merge","mergeOrCreate","addr","addrString","isAlreadyCertified","Boolean","Array","from","entries","addrStr","all","queryKeys","prefix","base32Str","split"],"sources":["../../src/store.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}