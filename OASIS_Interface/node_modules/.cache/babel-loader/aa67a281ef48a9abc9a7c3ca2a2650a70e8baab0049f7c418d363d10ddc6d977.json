{"ast":null,"code":"/* eslint-disable no-unreachable */\n\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport parseDuration from 'parse-duration';\nimport { TimeoutError } from './errors.js';\n\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\nexport function withTimeoutOption(fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return (/** @returns {R} */( /** @type {Args} */...args) => {\n      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n      if (!options || !options.timeout) return fn(...args);\n      const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n      const controller = new TimeoutController(timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n      const fnRes = fn(...args);\n      // eslint-disable-next-line promise/param-names\n      const timeoutPromise = new Promise((_resolve, reject) => {\n        controller.signal.addEventListener('abort', () => {\n          reject(new TimeoutError());\n        });\n      });\n      const start = Date.now();\n      const maybeThrowTimeoutError = () => {\n        if (controller.signal.aborted) {\n          throw new TimeoutError();\n        }\n        const timeTaken = Date.now() - start;\n\n        // if we have starved the event loop by adding microtasks, we could have\n        // timed out already but the TimeoutController will never know because it's\n        // setTimeout will not fire until we stop adding microtasks\n        if (timeTaken > timeout) {\n          controller.abort();\n          throw new TimeoutError();\n        }\n      };\n\n      // @ts-expect-error\n      if (fnRes[Symbol.asyncIterator]) {\n        // @ts-expect-error\n        return async function* () {\n          // @ts-expect-error\n          const it = fnRes[Symbol.asyncIterator]();\n          try {\n            while (true) {\n              const {\n                value,\n                done\n              } = await Promise.race([it.next(), timeoutPromise]);\n              if (done) {\n                break;\n              }\n              maybeThrowTimeoutError();\n              yield value;\n            }\n          } catch ( /** @type {any} */err) {\n            maybeThrowTimeoutError();\n            throw err;\n          } finally {\n            controller.clear();\n            if (it.return) {\n              it.return();\n            }\n          }\n        }();\n      }\n\n      // @ts-expect-error\n      return (async () => {\n        try {\n          const res = await Promise.race([fnRes, timeoutPromise]);\n          maybeThrowTimeoutError();\n          return res;\n        } catch ( /** @type {any} */err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n        }\n      })();\n    }\n  );\n}","map":{"version":3,"names":["TimeoutController","anySignal","parseDuration","TimeoutError","withTimeoutOption","fn","optionsArgIndex","args","options","length","timeout","controller","signal","fnRes","timeoutPromise","Promise","_resolve","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","value","done","race","next","err","clear","return","res"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core-utils@0.18.1/node_modules/ipfs-core-utils/src/with-timeout-option.js"],"sourcesContent":["/* eslint-disable no-unreachable */\n\nimport { TimeoutController } from 'timeout-abort-controller'\nimport { anySignal } from 'any-signal'\nimport parseDuration from 'parse-duration'\nimport { TimeoutError } from './errors.js'\n\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\nexport function withTimeoutOption (fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return /** @returns {R} */(/** @type {Args} */...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    // eslint-disable-next-line promise/param-names\n    const timeoutPromise = new Promise((_resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    // @ts-expect-error\n    if (fnRes[Symbol.asyncIterator]) {\n      // @ts-expect-error\n      return (async function * () {\n        // @ts-expect-error\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (/** @type {any} */ err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    // @ts-expect-error\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (/** @type {any} */ err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}