{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EventEmitter } from 'events';\nimport { Stat } from './stat.js';\nimport { trackedMap } from '@libp2p/tracked-map';\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @typedef {[number, number, number]} AverageIntervals\n */\nconst defaultOptions = {\n  enabled: false,\n  computeThrottleTimeout: 1000,\n  computeThrottleMaxQueueSize: 1000,\n  movingAverageIntervals: /** @type {AverageIntervals} */[60 * 1000,\n  // 1 minute\n  5 * 60 * 1000,\n  // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ]\n};\n\nexport class Stats extends EventEmitter {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {string[]} [initialCounters]\n   * @param {object} _options\n   * @param {boolean} _options.enabled\n   * @param {number} _options.computeThrottleTimeout\n   * @param {number} _options.computeThrottleMaxQueueSize\n   */\n  constructor(libp2p, initialCounters = [], _options = defaultOptions) {\n    super();\n    const options = Object.assign({}, defaultOptions, _options);\n    if (typeof options.computeThrottleTimeout !== 'number') {\n      throw new Error('need computeThrottleTimeout');\n    }\n    if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n      throw new Error('need computeThrottleMaxQueueSize');\n    }\n    this._initialCounters = initialCounters;\n    this._options = options;\n    this._enabled = this._options.enabled;\n    this._global = new Stat(initialCounters, options);\n    this._global.on('update', stats => this.emit('update', stats));\n\n    /** @type {Map<string, Stat>} */\n    this._peers = trackedMap({\n      name: 'ipfs_bitswap_stats_peers',\n      metrics: libp2p.metrics\n    });\n  }\n  enable() {\n    this._enabled = true;\n    this._options.enabled = true;\n    this._global.enable();\n  }\n  disable() {\n    this._enabled = false;\n    this._options.enabled = false;\n    this._global.disable();\n  }\n  stop() {\n    this._enabled = false;\n    this._global.stop();\n    for (const peerStat of this._peers) {\n      peerStat[1].stop();\n    }\n  }\n  get snapshot() {\n    return this._global.snapshot;\n  }\n  get movingAverages() {\n    return this._global.movingAverages;\n  }\n\n  /**\n   * @param {PeerId|string} peerId\n   * @returns {Stat|undefined}\n   */\n  forPeer(peerId) {\n    const peerIdStr = typeof peerId !== 'string' && peerId.toString ? peerId.toString() : `${peerId}`;\n    return this._peers.get(peerIdStr);\n  }\n\n  /**\n   *\n   * @param {string|null} peer\n   * @param {string} counter\n   * @param {number} inc\n   */\n  push(peer, counter, inc) {\n    if (this._enabled) {\n      this._global.push(counter, inc);\n      if (peer) {\n        let peerStats = this._peers.get(peer);\n        if (!peerStats) {\n          peerStats = new Stat(this._initialCounters, this._options);\n          this._peers.set(peer, peerStats);\n        }\n        peerStats.push(counter, inc);\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peer\n   */\n  disconnected(peer) {\n    const peerId = peer.toString();\n    const peerStats = this._peers.get(peerId);\n    if (peerStats) {\n      peerStats.stop();\n      this._peers.delete(peerId);\n    }\n  }\n}","map":{"version":3,"names":["EventEmitter","Stat","trackedMap","defaultOptions","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","movingAverageIntervals","Stats","constructor","libp2p","initialCounters","_options","options","Object","assign","Error","_initialCounters","_enabled","_global","on","stats","emit","_peers","name","metrics","enable","disable","stop","peerStat","snapshot","movingAverages","forPeer","peerId","peerIdStr","toString","get","push","peer","counter","inc","peerStats","set","disconnected","delete"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/stats/index.js"],"sourcesContent":["import { EventEmitter } from 'events'\nimport { Stat } from './stat.js'\nimport { trackedMap } from '@libp2p/tracked-map'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n */\n\n/**\n * @typedef {[number, number, number]} AverageIntervals\n */\nconst defaultOptions = {\n  enabled: false,\n  computeThrottleTimeout: 1000,\n  computeThrottleMaxQueueSize: 1000,\n  movingAverageIntervals: /** @type {AverageIntervals} */ ([\n    60 * 1000, // 1 minute\n    5 * 60 * 1000, // 5 minutes\n    15 * 60 * 1000 // 15 minutes\n  ])\n}\n\nexport class Stats extends EventEmitter {\n  /**\n   * @param {import('@libp2p/interface-libp2p').Libp2p} libp2p\n   * @param {string[]} [initialCounters]\n   * @param {object} _options\n   * @param {boolean} _options.enabled\n   * @param {number} _options.computeThrottleTimeout\n   * @param {number} _options.computeThrottleMaxQueueSize\n   */\n  constructor (libp2p, initialCounters = [], _options = defaultOptions) {\n    super()\n\n    const options = Object.assign({}, defaultOptions, _options)\n\n    if (typeof options.computeThrottleTimeout !== 'number') {\n      throw new Error('need computeThrottleTimeout')\n    }\n\n    if (typeof options.computeThrottleMaxQueueSize !== 'number') {\n      throw new Error('need computeThrottleMaxQueueSize')\n    }\n\n    this._initialCounters = initialCounters\n    this._options = options\n    this._enabled = this._options.enabled\n\n    this._global = new Stat(initialCounters, options)\n    this._global.on('update', (stats) => this.emit('update', stats))\n\n    /** @type {Map<string, Stat>} */\n    this._peers = trackedMap({\n      name: 'ipfs_bitswap_stats_peers',\n      metrics: libp2p.metrics\n    })\n  }\n\n  enable () {\n    this._enabled = true\n    this._options.enabled = true\n    this._global.enable()\n  }\n\n  disable () {\n    this._enabled = false\n    this._options.enabled = false\n    this._global.disable()\n  }\n\n  stop () {\n    this._enabled = false\n    this._global.stop()\n    for (const peerStat of this._peers) {\n      peerStat[1].stop()\n    }\n  }\n\n  get snapshot () {\n    return this._global.snapshot\n  }\n\n  get movingAverages () {\n    return this._global.movingAverages\n  }\n\n  /**\n   * @param {PeerId|string} peerId\n   * @returns {Stat|undefined}\n   */\n  forPeer (peerId) {\n    const peerIdStr = (typeof peerId !== 'string' && peerId.toString)\n      ? peerId.toString()\n      : `${peerId}`\n\n    return this._peers.get(peerIdStr)\n  }\n\n  /**\n   *\n   * @param {string|null} peer\n   * @param {string} counter\n   * @param {number} inc\n   */\n  push (peer, counter, inc) {\n    if (this._enabled) {\n      this._global.push(counter, inc)\n\n      if (peer) {\n        let peerStats = this._peers.get(peer)\n        if (!peerStats) {\n          peerStats = new Stat(this._initialCounters, this._options)\n          this._peers.set(peer, peerStats)\n        }\n\n        peerStats.push(counter, inc)\n      }\n    }\n  }\n\n  /**\n   * @param {PeerId} peer\n   */\n  disconnected (peer) {\n    const peerId = peer.toString()\n    const peerStats = this._peers.get(peerId)\n    if (peerStats) {\n      peerStats.stop()\n      this._peers.delete(peerId)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}