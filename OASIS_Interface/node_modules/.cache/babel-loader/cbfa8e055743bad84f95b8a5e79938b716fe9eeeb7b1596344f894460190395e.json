{"ast":null,"code":"const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\nconst RateLimiterRes = require('./RateLimiterRes');\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor(opts = {}) {\n    super(opts);\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const secDuration = this._getKeySecDuration(options);\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise(resolve => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise(resolve => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n    return Promise.resolve(new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints));\n  }\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n    return Promise.resolve(new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points));\n  }\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n    return Promise.resolve(res);\n  }\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n}\nmodule.exports = RateLimiterMemory;","map":{"version":3,"names":["RateLimiterAbstract","require","MemoryStorage","RateLimiterRes","RateLimiterMemory","constructor","opts","_memoryStorage","consume","key","pointsToConsume","options","Promise","resolve","reject","rlKey","getKey","secDuration","_getKeySecDuration","res","incrby","remainingPoints","Math","max","points","consumedPoints","blockDuration","set","execEvenly","msBeforeNext","isFirstInDuration","delay","ceil","execEvenlyMinDelayMs","setTimeout","penalty","reward","block","msDuration","initPoints","duration","get","delete","module","exports"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/rate-limiter-flexible@2.4.2/node_modules/rate-limiter-flexible/lib/RateLimiterMemory.js"],"sourcesContent":["const RateLimiterAbstract = require('./RateLimiterAbstract');\nconst MemoryStorage = require('./component/MemoryStorage/MemoryStorage');\nconst RateLimiterRes = require('./RateLimiterRes');\n\nclass RateLimiterMemory extends RateLimiterAbstract {\n  constructor(opts = {}) {\n    super(opts);\n\n    this._memoryStorage = new MemoryStorage();\n  }\n  /**\n   *\n   * @param key\n   * @param pointsToConsume\n   * @param {Object} options\n   * @returns {Promise<RateLimiterRes>}\n   */\n  consume(key, pointsToConsume = 1, options = {}) {\n    return new Promise((resolve, reject) => {\n      const rlKey = this.getKey(key);\n      const secDuration = this._getKeySecDuration(options);\n      let res = this._memoryStorage.incrby(rlKey, pointsToConsume, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n\n      if (res.consumedPoints > this.points) {\n        // Block only first time when consumed more than points\n        if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n          // Block key\n          res = this._memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);\n        }\n        reject(res);\n      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n        // Execute evenly\n        let delay = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));\n        if (delay < this.execEvenlyMinDelayMs) {\n          delay = res.consumedPoints * this.execEvenlyMinDelayMs;\n        }\n\n        setTimeout(resolve, delay, res);\n      } else {\n        resolve(res);\n      }\n    });\n  }\n\n  penalty(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  reward(key, points = 1, options = {}) {\n    const rlKey = this.getKey(key);\n    return new Promise((resolve) => {\n      const secDuration = this._getKeySecDuration(options);\n      const res = this._memoryStorage.incrby(rlKey, -points, secDuration);\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n      resolve(res);\n    });\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block(key, secDuration) {\n    const msDuration = secDuration * 1000;\n    const initPoints = this.points + 1;\n\n    this._memoryStorage.set(this.getKey(key), initPoints, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, initPoints)\n    );\n  }\n\n  set(key, points, secDuration) {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000;\n\n    this._memoryStorage.set(this.getKey(key), points, secDuration);\n    return Promise.resolve(\n      new RateLimiterRes(0, msDuration === 0 ? -1 : msDuration, points)\n    );\n  }\n\n  get(key) {\n    const res = this._memoryStorage.get(this.getKey(key));\n    if (res !== null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);\n    }\n\n    return Promise.resolve(res);\n  }\n\n  delete(key) {\n    return Promise.resolve(this._memoryStorage.delete(this.getKey(key)));\n  }\n}\n\nmodule.exports = RateLimiterMemory;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}