{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EventEmitter } from 'events';\nimport MovingAverage from '@vascosantos/moving-average';\n\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n * @typedef {[string, number, number]} Op\n */\n\nexport class Stat extends EventEmitter {\n  /**\n   *\n   * @param {string[]} initialCounters\n   * @param {object} options\n   * @param {boolean} options.enabled\n   * @param {number} options.computeThrottleTimeout\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {import('.').AverageIntervals} options.movingAverageIntervals\n   */\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    /** @type {Op[]} */\n    this._queue = [];\n    /** @type {Record<string, bigint>} */\n    this._stats = {};\n    this._frequencyLastTime = Date.now();\n    /** @type {Record<string, number>} */\n    this._frequencyAccumulators = {};\n\n    /** @type {Record<string, Record<number, IMovingAverage>>} */\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    initialCounters.forEach(key => {\n      this._stats[key] = BigInt(0);\n      this._movingAverages[key] = {};\n      this._options.movingAverageIntervals.forEach(interval => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      });\n    });\n    this._enabled = this._options.enabled;\n  }\n  enable() {\n    this._enabled = true;\n  }\n  disable() {\n    this._disabled = true;\n  }\n  stop() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n  }\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n\n  /**\n   * @param {string} counter\n   * @param {number} inc\n   */\n  push(counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()]);\n      this._resetComputeTimeout();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _resetComputeTimeout() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n    this._timeout = setTimeout(this._update, this._nextTimeout());\n  }\n\n  /**\n   * @private\n   * @returns {number}\n   */\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n  }\n\n  /**\n   * @private\n   */\n  _update() {\n    this._timeout = null;\n    if (this._queue.length) {\n      let last;\n      while (this._queue.length) {\n        const op = last = this._queue.shift();\n        op && this._applyOp(op);\n      }\n      last && this._updateFrequency(last[2]); // contains timestamp of last op\n\n      this.emit('update', this._stats);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} latestTime\n   */\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n    if (timeDiff) {\n      Object.keys(this._stats).forEach(key => {\n        this._updateFrequencyFor(key, timeDiff, latestTime);\n      });\n    }\n    this._frequencyLastTime = latestTime;\n  }\n\n  /**\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS\n   * @param {number} latestTime\n   * @returns {void}\n   */\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0;\n    const hz = count / timeDiffMS * 1000;\n    let movingAverages = this._movingAverages[key];\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n    this._options.movingAverageIntervals.forEach(movingAverageInterval => {\n      let movingAverage = movingAverages[movingAverageInterval];\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n      movingAverage.push(latestTime, hz);\n    });\n  }\n\n  /**\n   * @private\n   * @param {Op} op\n   */\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`);\n    }\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      this._stats[key] = BigInt(0);\n    }\n    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n    this._frequencyAccumulators[key] += inc;\n  }\n}","map":{"version":3,"names":["EventEmitter","MovingAverage","Stat","constructor","initialCounters","options","_options","_queue","_stats","_frequencyLastTime","Date","now","_frequencyAccumulators","_movingAverages","_update","bind","forEach","key","BigInt","movingAverageIntervals","interval","ma","push","_enabled","enabled","enable","disable","_disabled","stop","_timeout","clearTimeout","snapshot","Object","assign","movingAverages","counter","inc","_resetComputeTimeout","setTimeout","_nextTimeout","urgency","length","computeThrottleMaxQueueSize","Math","max","computeThrottleTimeout","last","op","shift","_applyOp","_updateFrequency","emit","latestTime","timeDiff","keys","_updateFrequencyFor","timeDiffMS","count","hz","movingAverageInterval","movingAverage","Error","prototype","hasOwnProperty","call"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-bitswap@15.0.2/node_modules/ipfs-bitswap/src/stats/stat.js"],"sourcesContent":["import { EventEmitter } from 'events'\nimport MovingAverage from '@vascosantos/moving-average'\n\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n * @typedef {[string, number, number]} Op\n */\n\nexport class Stat extends EventEmitter {\n  /**\n   *\n   * @param {string[]} initialCounters\n   * @param {object} options\n   * @param {boolean} options.enabled\n   * @param {number} options.computeThrottleTimeout\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {import('.').AverageIntervals} options.movingAverageIntervals\n   */\n  constructor (initialCounters, options) {\n    super()\n\n    this._options = options\n    /** @type {Op[]} */\n    this._queue = []\n    /** @type {Record<string, bigint>} */\n    this._stats = {}\n\n    this._frequencyLastTime = Date.now()\n    /** @type {Record<string, number>} */\n    this._frequencyAccumulators = {}\n\n    /** @type {Record<string, Record<number, IMovingAverage>>} */\n    this._movingAverages = {}\n\n    this._update = this._update.bind(this)\n\n    initialCounters.forEach((key) => {\n      this._stats[key] = BigInt(0)\n      this._movingAverages[key] = {}\n      this._options.movingAverageIntervals.forEach((interval) => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval)\n        ma.push(this._frequencyLastTime, 0)\n      })\n    })\n\n    this._enabled = this._options.enabled\n  }\n\n  enable () {\n    this._enabled = true\n  }\n\n  disable () {\n    this._disabled = true\n  }\n\n  stop () {\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n    }\n  }\n\n  get snapshot () {\n    return Object.assign({}, this._stats)\n  }\n\n  get movingAverages () {\n    return Object.assign({}, this._movingAverages)\n  }\n\n  /**\n   * @param {string} counter\n   * @param {number} inc\n   */\n  push (counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()])\n      this._resetComputeTimeout()\n    }\n  }\n\n  /**\n   * @private\n   */\n  _resetComputeTimeout () {\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n    }\n    this._timeout = setTimeout(this._update, this._nextTimeout())\n  }\n\n  /**\n   * @private\n   * @returns {number}\n   */\n  _nextTimeout () {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)\n  }\n\n  /**\n   * @private\n   */\n  _update () {\n    this._timeout = null\n\n    if (this._queue.length) {\n      let last\n      while (this._queue.length) {\n        const op = last = this._queue.shift()\n        op && this._applyOp(op)\n      }\n\n      last && this._updateFrequency(last[2]) // contains timestamp of last op\n\n      this.emit('update', this._stats)\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} latestTime\n   */\n  _updateFrequency (latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime\n\n    if (timeDiff) {\n      Object.keys(this._stats).forEach((key) => {\n        this._updateFrequencyFor(key, timeDiff, latestTime)\n      })\n    }\n\n    this._frequencyLastTime = latestTime\n  }\n\n  /**\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS\n   * @param {number} latestTime\n   * @returns {void}\n   */\n  _updateFrequencyFor (key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0\n    this._frequencyAccumulators[key] = 0\n    const hz = (count / timeDiffMS) * 1000\n\n    let movingAverages = this._movingAverages[key]\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {}\n    }\n    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {\n      let movingAverage = movingAverages[movingAverageInterval]\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)\n      }\n      movingAverage.push(latestTime, hz)\n    })\n  }\n\n  /**\n   * @private\n   * @param {Op} op\n   */\n  _applyOp (op) {\n    const key = op[0]\n    const inc = op[1]\n\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`)\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      this._stats[key] = BigInt(0)\n    }\n\n    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc)\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0\n    }\n    this._frequencyAccumulators[key] += inc\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}