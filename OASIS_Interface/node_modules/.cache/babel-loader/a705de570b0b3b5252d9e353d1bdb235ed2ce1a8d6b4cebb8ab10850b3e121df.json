{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport $protobuf from 'protobufjs/minimal.js';\nimport { Key } from 'interface-datastore/key';\nimport { Protocols } from './pb/proto-book.js';\nimport { Addresses } from './pb/address-book.js';\nimport { Peer } from './pb/peer.js';\nimport { Envelope } from './pb/envelope.js';\nimport { PeerRecord } from './pb/peer-record.js';\nimport { multiaddr } from '@multiformats/multiaddr';\n\n// @ts-expect-error Explicitly disable long.js support\n$protobuf.util.Long = undefined;\n$protobuf.configure();\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a single datastore key');\n  await backends.datastore.open();\n\n  /** @type {Record<string, any>} */\n  const peers = {};\n  /** @type {Key[]} */\n  const keys = [];\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [, prefix, type, peerId, metadataKey] = keyStr.split('/');\n    if (prefix !== 'peers') {\n      continue;\n    }\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue;\n    }\n    if (!peerId) {\n      continue;\n    }\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    };\n    if (type === 'protos') {\n      const protos = Protocols.decode(value);\n      peers[peerId].protocols = protos.protocols.sort();\n    } else if (type === 'addrs') {\n      const addrs = Addresses.decode(value);\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString());\n      });\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({\n        key: metadataKey,\n        value\n      });\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value;\n    }\n  }\n  onProgress(33, 'Read peer data from store');\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n  onProgress(66, 'Removed existing peer data from store');\n  for (const peerId of Object.keys(peers)) {\n    const peer = peers[peerId];\n    peer.metadata = peer.metadata.sort(( /** @type {{ key: string }} */a, /** @type {{ key: string }} */b) => a.key.localeCompare(b.key));\n    const data = Peer.encode(peer).finish();\n    await backends.datastore.put(new Key(`/peers/${peerId}`), data);\n  }\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under a single datastore key');\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys');\n  await backends.datastore.open();\n\n  /** @type {Record<string, any>} */\n  const peers = {};\n  /** @type {Key[]} */\n  const keys = [];\n  for await (const {\n    key,\n    value\n  } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key);\n    const keyStr = key.toString();\n    const [,, peerId] = keyStr.split('/');\n    peers[peerId] = Peer.decode(value);\n  }\n  onProgress(33, 'Read peer data from store');\n  for (const key of keys) {\n    await backends.datastore.delete(key);\n  }\n  onProgress(66, 'Removed existing peer data from store');\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({\n        protocols: peer.protocols\n      }).finish());\n    }\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope;\n      let certifiedRecord;\n      if (peerRecordEnvelope) {\n        const envelope = Envelope.decode(peerRecordEnvelope);\n        const record = PeerRecord.decode(envelope.payload);\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        };\n      }\n      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish());\n    }\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const {\n        key,\n        value\n      } of peer.metadata) {\n        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);\n      }\n    }\n    if (peer.pubKey) {\n      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);\n    }\n  }\n  await backends.datastore.close();\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys');\n}\n\n/** @type {import('../../types').Migration} */\nexport const migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n};","map":{"version":3,"names":["$protobuf","Key","Protocols","Addresses","Peer","Envelope","PeerRecord","multiaddr","util","Long","undefined","configure","storePeerUnderSingleDatastoreKey","backends","onProgress","datastore","open","peers","keys","key","value","query","prefix","push","keyStr","toString","type","peerId","metadataKey","split","includes","addresses","protocols","metadata","protos","decode","sort","addrs","a","b","localeCompare","certifiedRecord","raw","peerRecordEnvelope","pubKey","delete","Object","peer","data","encode","finish","put","close","storePeerUnderMultipleDatastoreKeys","entries","length","envelope","record","payload","seq","migration","version","description","migrate","revert"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/migrations/migration-12/index.js"],"sourcesContent":["import $protobuf from 'protobufjs/minimal.js'\nimport { Key } from 'interface-datastore/key'\nimport { Protocols } from './pb/proto-book.js'\nimport { Addresses } from './pb/address-book.js'\nimport { Peer } from './pb/peer.js'\nimport { Envelope } from './pb/envelope.js'\nimport { PeerRecord } from './pb/peer-record.js'\nimport { multiaddr } from '@multiformats/multiaddr'\n\n// @ts-expect-error Explicitly disable long.js support\n$protobuf.util.Long = undefined\n$protobuf.configure()\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderSingleDatastoreKey (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a single datastore key')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n    const [, prefix, type, peerId, metadataKey] = keyStr.split('/')\n\n    if (prefix !== 'peers') {\n      continue\n    }\n\n    if (!['protos', 'addrs', 'metadata', 'keys'].includes(type)) {\n      continue\n    }\n\n    if (!peerId) {\n      continue\n    }\n\n    peers[peerId] = peers[peerId] || {\n      addresses: [],\n      protocols: [],\n      metadata: []\n    }\n\n    if (type === 'protos') {\n      const protos = Protocols.decode(value)\n\n      peers[peerId].protocols = protos.protocols.sort()\n    } else if (type === 'addrs') {\n      const addrs = Addresses.decode(value)\n\n      peers[peerId].addresses = addrs.addrs.sort((a, b) => {\n        return multiaddr(a.multiaddr).toString().localeCompare(multiaddr(b.multiaddr).toString())\n      })\n\n      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {\n        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw\n      }\n    } else if (type === 'metadata') {\n      peers[peerId].metadata.push({ key: metadataKey, value })\n    } else if (type === 'keys') {\n      peers[peerId].pubKey = value\n    }\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const peerId of Object.keys(peers)) {\n    const peer = peers[peerId]\n    peer.metadata = peer.metadata.sort((/** @type {{ key: string }} */ a, /** @type {{ key: string }} */ b) => a.key.localeCompare(b.key))\n\n    const data = Peer.encode(peer).finish()\n\n    await backends.datastore.put(new Key(`/peers/${peerId}`), data)\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under a single datastore key')\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {import('../../types').MigrationProgressCallback} onProgress\n */\nasync function storePeerUnderMultipleDatastoreKeys (backends, onProgress = () => {}) {\n  onProgress(0, 'Storing each peerstore key under a multiple datastore keys')\n\n  await backends.datastore.open()\n\n  /** @type {Record<string, any>} */\n  const peers = {}\n  /** @type {Key[]} */\n  const keys = []\n\n  for await (const { key, value } of backends.datastore.query({\n    prefix: '/peers'\n  })) {\n    keys.push(key)\n    const keyStr = key.toString()\n\n    const [, , peerId] = keyStr.split('/')\n\n    peers[peerId] = Peer.decode(value)\n  }\n\n  onProgress(33, 'Read peer data from store')\n\n  for (const key of keys) {\n    await backends.datastore.delete(key)\n  }\n\n  onProgress(66, 'Removed existing peer data from store')\n\n  for (const [peerId, peer] of Object.entries(peers)) {\n    if (peer.protocols && peer.protocols.length > 0) {\n      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({\n        protocols: peer.protocols\n      }).finish())\n    }\n\n    if (peer.addresses && peer.addresses.length > 0) {\n      const peerRecordEnvelope = peer.peerRecordEnvelope\n      let certifiedRecord\n\n      if (peerRecordEnvelope) {\n        const envelope = Envelope.decode(peerRecordEnvelope)\n        const record = PeerRecord.decode(envelope.payload)\n\n        certifiedRecord = {\n          raw: peerRecordEnvelope,\n          seq: record.seq\n        }\n      }\n\n      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({\n        addrs: peer.addresses,\n        certifiedRecord\n      }).finish())\n    }\n\n    if (peer.metadata && peer.metadata.length > 0) {\n      for (const { key, value } of peer.metadata) {\n        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value)\n      }\n    }\n\n    if (peer.pubKey) {\n      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey)\n    }\n  }\n\n  await backends.datastore.close()\n\n  onProgress(100, 'Stored each peerstore key under multiple datastore keys')\n}\n\n/** @type {import('../../types').Migration} */\nexport const migration = {\n  version: 12,\n  description: 'Store each peerstore peer under a single datastore key',\n  migrate: storePeerUnderSingleDatastoreKey,\n  revert: storePeerUnderMultipleDatastoreKeys\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}