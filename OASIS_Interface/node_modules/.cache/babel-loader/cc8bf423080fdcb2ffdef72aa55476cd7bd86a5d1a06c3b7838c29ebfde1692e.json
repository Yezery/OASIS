{"ast":null,"code":"\"use strict\";\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\nrequire(\"core-js/modules/es.array.push.js\");\nvar compile = require(\"./compile.js\");\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"];\n  var vars = [];\n  var thunkName = proc.funcName + \"_cwise_thunk\";\n\n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"));\n  var typesig = [];\n  var string_typesig = [];\n  var proc_args = [[\"array\", proc.arrayArgs[0], \".shape.slice(\",\n  // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? \",\" + proc.arrayBlockIndices[0] + \")\" : \")\"].join(\"\")];\n  var shapeLengthConditions = [],\n    shapeConditions = [];\n  // Process array arguments\n  for (var i = 0; i < proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i];\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\", \"r\", j, \"=array\", j, \".order\"].join(\"\"));\n    typesig.push(\"t\" + j);\n    typesig.push(\"r\" + j);\n    string_typesig.push(\"t\" + j);\n    string_typesig.push(\"r\" + j + \".join()\");\n    proc_args.push(\"array\" + j + \".data\");\n    proc_args.push(\"array\" + j + \".stride\");\n    proc_args.push(\"array\" + j + \".offset|0\");\n    if (i > 0) {\n      // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[i]) + \"]\");\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\");\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\");\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\");\n    code.push(\"}\");\n  }\n  // Process scalar arguments\n  for (var i = 0; i < proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i]);\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"));\n  vars.push(\"proc=CACHED[type]\");\n  code.push(\"var \" + vars.join(\",\"));\n  code.push([\"if(!proc){\", \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\", \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"));\n  if (proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\");\n  }\n\n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"));\n  return thunk(compile.bind(undefined, proc));\n}\nmodule.exports = createThunk;","map":{"version":3,"names":["require","compile","createThunk","proc","code","vars","thunkName","funcName","push","shimArgs","join","typesig","string_typesig","proc_args","arrayArgs","Math","max","arrayBlockIndices","shapeLengthConditions","shapeConditions","i","length","j","abs","scalarArgs","debug","console","log","thunk","Function","bind","undefined","module","exports"],"sources":["/Users/yezery/Desktop/OASIS/OASIS_Interface/node_modules/.store/cwise-compiler@1.1.3/node_modules/cwise-compiler/lib/thunk.js"],"sourcesContent":["\"use strict\"\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}