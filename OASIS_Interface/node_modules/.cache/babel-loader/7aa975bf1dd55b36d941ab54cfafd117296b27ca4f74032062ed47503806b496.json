{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport itPeekable from 'it-peekable';\nimport drain from 'it-drain';\nimport map from 'it-map';\nimport { logger } from '@libp2p/logger';\nconst log = logger('ipfs:components:dag:import');\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n */\nexport function createImport({\n  repo\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"import\"]}\n   */\n  async function* dagImport(sources, options = {}) {\n    const release = await repo.gcLock.readLock();\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable(sources);\n      const {\n        value,\n        done\n      } = await peekable.peek();\n      if (done) {\n        return;\n      }\n      if (value) {\n        // @ts-expect-error\n        peekable.push(value);\n      }\n\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n      let cars;\n      if (value instanceof Uint8Array) {\n        // @ts-expect-error\n        cars = [peekable];\n      } else {\n        // @ts-expect-error\n        cars = peekable;\n      }\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n        if (options.pinRoots !== false) {\n          // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n            try {\n              // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) {\n                // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch ( /** @type {any} */err) {\n              pinErrorMsg = err.message;\n            }\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n  return withTimeoutOption(dagImport);\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\nasync function importCar(repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain(repo.blocks.putMany(map(reader, ({\n    cid: key,\n    bytes: value\n  }) => {\n    log(`Import block ${key}`);\n    return {\n      key,\n      value\n    };\n  }), {\n    signal: options.signal\n  }));\n  return roots;\n}","map":{"version":3,"names":["CarBlockIterator","withTimeoutOption","itPeekable","drain","map","logger","log","createImport","repo","dagImport","sources","options","release","gcLock","readLock","abortOptions","signal","timeout","peekable","value","done","peek","push","cars","Uint8Array","car","roots","importCar","pinRoots","cid","pinErrorMsg","blocks","has","pins","pinRecursively","err","message","root","source","reader","fromIterable","getRoots","putMany","key","bytes"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/dag/import.js"],"sourcesContent":["import { CarBlockIterator } from '@ipld/car/iterator'\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport itPeekable from 'it-peekable'\nimport drain from 'it-drain'\nimport map from 'it-map'\nimport { logger } from '@libp2p/logger'\nconst log = logger('ipfs:components:dag:import')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {object} config\n * @param {IPFSRepo} config.repo\n */\nexport function createImport ({ repo }) {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API<{}>[\"import\"]}\n   */\n  async function * dagImport (sources, options = {}) {\n    const release = await repo.gcLock.readLock()\n\n    try {\n      const abortOptions = { signal: options.signal, timeout: options.timeout }\n      const peekable = itPeekable(sources)\n\n      const { value, done } = await peekable.peek()\n\n      if (done) {\n        return\n      }\n\n      if (value) {\n        // @ts-expect-error\n        peekable.push(value)\n      }\n\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n      let cars\n\n      if (value instanceof Uint8Array) {\n        // @ts-expect-error\n        cars = [peekable]\n      } else {\n        // @ts-expect-error\n        cars = peekable\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car)\n\n        if (options.pinRoots !== false) { // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = ''\n\n            try { // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) { // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`)\n                await repo.pins.pinRecursively(cid)\n              } else {\n                pinErrorMsg = 'blockstore: block not found'\n              }\n            } catch (/** @type {any} */ err) {\n              pinErrorMsg = err.message\n            }\n\n            yield { root: { cid, pinErrorMsg } }\n          }\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(dagImport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\nasync function importCar (repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source)\n  const roots = await reader.getRoots()\n\n  await drain(\n    repo.blocks.putMany(\n      map(reader, ({ cid: key, bytes: value }) => {\n        log(`Import block ${key}`)\n\n        return { key, value }\n      }),\n      { signal: options.signal }\n    )\n  )\n\n  return roots\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}