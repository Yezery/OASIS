{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { CID } from 'multiformats/cid';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as cbor from 'cborg';\nimport * as pinset from './pin-set.js';\nimport { cidToKey, PIN_DS_KEY, PinTypes } from './utils.js';\nimport length from 'it-length';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as mhd from 'multiformats/hashes/digest';\nimport { base32 } from 'multiformats/bases/base32';\n\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('../../types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').Version} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {\n  if (!(await datastore.has(PIN_DS_KEY))) {\n    return;\n  }\n  const mh = await datastore.get(PIN_DS_KEY);\n  const cid = CID.decode(mh);\n  const pinRootBuf = await blockstore.get(cid);\n  const pinRoot = dagPb.decode(pinRootBuf);\n  let counter = 0;\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)));\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++;\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: Infinity\n    };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid}`);\n  }\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++;\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: 0\n    };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid}`);\n  }\n  await blockstore.delete(cid);\n  await datastore.delete(PIN_DS_KEY);\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDAG(blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = [];\n  const directPins = [];\n  let counter = 0;\n  const pinCount = await length(pinstore.queryKeys({}));\n  for await (const {\n    key,\n    value\n  } of pinstore.query({})) {\n    counter++;\n    const pin = cbor.decode(value);\n    const cid = CID.create(pin.version || 0, pin.codec || dagPb.code, mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop())));\n    if (pin.depth === 0) {\n      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid}`);\n      directPins.push(cid);\n    } else {\n      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid}`);\n      recursivePins.push(cid);\n    }\n  }\n  onProgress(100, 'Updating pin root');\n  const pinRoot = {\n    Links: [await pinset.storeSet(blockstore, PinTypes.direct, directPins), await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)]\n  };\n  const buf = dagPb.encode(pinRoot);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  await datastore.put(PIN_DS_KEY, cid.bytes);\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process(backends, onProgress, fn) {\n  const blockstore = backends.blocks;\n  const datastore = backends.datastore;\n  const pinstore = backends.pins;\n  await blockstore.open();\n  await datastore.open();\n  await pinstore.open();\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress);\n  } finally {\n    await pinstore.close();\n    await datastore.close();\n    await blockstore.close();\n  }\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG);\n  }\n};","map":{"version":3,"names":["CID","dagPb","cbor","pinset","cidToKey","PIN_DS_KEY","PinTypes","length","sha256","mhd","base32","pinsToDatastore","blockstore","datastore","pinstore","onProgress","has","mh","get","cid","decode","pinRootBuf","pinRoot","counter","pinCount","loadSet","recursive","direct","pin","depth","Infinity","version","code","codec","put","encode","delete","pinsToDAG","recursivePins","directPins","queryKeys","key","value","query","create","toString","toLowerCase","split","pop","push","Links","storeSet","buf","digest","createV0","bytes","process","backends","fn","blocks","pins","open","close","migration","description","migrate","revert"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo-migrations@15.0.0/node_modules/ipfs-repo-migrations/src/migrations/migration-9/index.js"],"sourcesContent":["\nimport { CID } from 'multiformats/cid'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as cbor from 'cborg'\nimport * as pinset from './pin-set.js'\nimport { cidToKey, PIN_DS_KEY, PinTypes } from './utils.js'\nimport length from 'it-length'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as mhd from 'multiformats/hashes/digest'\nimport { base32 } from 'multiformats/bases/base32'\n\n/**\n * @typedef {import('../../types').Migration} Migration\n * @typedef {import('../../types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').Version} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDatastore (blockstore, datastore, pinstore, onProgress) {\n  if (!await datastore.has(PIN_DS_KEY)) {\n    return\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY)\n  const cid = CID.decode(mh)\n  const pinRootBuf = await blockstore.get(cid)\n  const pinRoot = dagPb.decode(pinRootBuf)\n  let counter = 0\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)))\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated recursive pin ${cid}`)\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated direct pin ${cid}`)\n  }\n\n  await blockstore.delete(cid)\n  await datastore.delete(PIN_DS_KEY)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDAG (blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = []\n  const directPins = []\n  let counter = 0\n  const pinCount = await length(pinstore.queryKeys({}))\n\n  for await (const { key, value } of pinstore.query({})) {\n    counter++\n    const pin = cbor.decode(value)\n    const cid = CID.create(\n      pin.version || 0,\n      pin.codec || dagPb.code,\n      mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop()))\n    )\n\n    if (pin.depth === 0) {\n      onProgress((counter / pinCount) * 100, `Reverted direct pin ${cid}`)\n\n      directPins.push(cid)\n    } else {\n      onProgress((counter / pinCount) * 100, `Reverted recursive pin ${cid}`)\n\n      recursivePins.push(cid)\n    }\n  }\n\n  onProgress(100, 'Updating pin root')\n  const pinRoot = {\n    Links: [\n      await pinset.storeSet(blockstore, PinTypes.direct, directPins),\n      await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)\n    ]\n  }\n  const buf = dagPb.encode(pinRoot)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n  await datastore.put(PIN_DS_KEY, cid.bytes)\n}\n\n/**\n * @param {import('../../types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process (backends, onProgress, fn) {\n  const blockstore = backends.blocks\n  const datastore = backends.datastore\n  const pinstore = backends.pins\n\n  await blockstore.open()\n  await datastore.open()\n  await pinstore.open()\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress)\n  } finally {\n    await pinstore.close()\n    await datastore.close()\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nexport const migration = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}