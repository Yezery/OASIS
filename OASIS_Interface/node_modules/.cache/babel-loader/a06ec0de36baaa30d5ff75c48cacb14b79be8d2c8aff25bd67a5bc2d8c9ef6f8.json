{"ast":null,"code":"import \"core-js/modules/web.immediate.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport filter from 'it-filter';\nimport { pushable } from 'it-pushable';\nimport drain from 'it-drain';\nimport { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport { identity } from 'multiformats/hashes/identity';\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nexport function createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n    close() {\n      return store.close();\n    },\n    query(query, options) {\n      return store.query(query, options);\n    },\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n      return store.get(cid, options);\n    },\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n    async put(cid, buf, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n      if (isIdentity) {\n        return;\n      }\n      await store.put(cid, buf, options);\n    },\n    async *putMany(pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable({\n        objectMode: true\n      });\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const {\n              key,\n              value\n            } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch ( /** @type {any} */err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n      return store.has(cid, options);\n    },\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n      return store.delete(cid, options);\n    },\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n          if (isIdentity) {\n            return;\n          }\n          batch.put(cid, buf);\n        },\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n          if (isIdentity) {\n            return;\n          }\n          batch.delete(cid);\n        },\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n  };\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":{"version":3,"names":["filter","pushable","drain","CID","errCode","identity","createIdStore","store","open","close","query","options","queryKeys","get","cid","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","objectMode","runner","globalThis","process","nextTick","setImmediate","setTimeout","key","value","push","end","err","has","delete","deleteMany","batch","commit","k","asCID","Error","multihash","code"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/idstore.js"],"sourcesContent":["\nimport filter from 'it-filter'\nimport { pushable } from 'it-pushable'\nimport drain from 'it-drain'\nimport { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\nimport { identity } from 'multiformats/hashes/identity'\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nexport function createIdStore (store) {\n  return {\n    open () {\n      return store.open()\n    },\n\n    close () {\n      return store.close()\n    },\n\n    query (query, options) {\n      return store.query(query, options)\n    },\n\n    queryKeys (query, options) {\n      return store.queryKeys(query, options)\n    },\n\n    async get (cid, options) {\n      const extracted = extractContents(cid)\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest)\n      }\n      return store.get(cid, options)\n    },\n\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    async put (cid, buf, options) {\n      const { isIdentity } = extractContents(cid)\n\n      if (isIdentity) {\n        return\n      }\n\n      await store.put(cid, buf, options)\n    },\n\n    async * putMany (pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable({\n        objectMode: true\n      })\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : (globalThis.setImmediate || globalThis.setTimeout)\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const { key, value } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield { key, value }\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({ key, value })\n            }\n          }()))\n\n          output.end()\n        } catch (/** @type {any} */ err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    has (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve(true)\n      }\n      return store.has(cid, options)\n    },\n\n    delete (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve()\n      }\n      return store.delete(cid, options)\n    },\n\n    deleteMany (cids, options) {\n      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options)\n    },\n\n    batch () {\n      const batch = store.batch()\n\n      return {\n        put (cid, buf) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.put(cid, buf)\n        },\n        delete (cid) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.delete(cid)\n        },\n        commit: (options) => {\n          return batch.commit(options)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents (k) {\n  const cid = CID.asCID(k)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    }\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  }\n}\n"],"mappings":";;AACA,OAAOA,MAAM,MAAM,WAAW;AAC9B,SAASC,QAAQ,QAAQ,aAAa;AACtC,OAAOC,KAAK,MAAM,UAAU;AAC5B,SAASC,GAAG,QAAQ,kBAAkB;AACtC,OAAOC,OAAO,MAAM,UAAU;AAC9B,SAASC,QAAQ,QAAQ,8BAA8B;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAAEC,KAAK,EAAE;EACpC,OAAO;IACLC,IAAIA,CAAA,EAAI;MACN,OAAOD,KAAK,CAACC,IAAI,CAAC,CAAC;IACrB,CAAC;IAEDC,KAAKA,CAAA,EAAI;MACP,OAAOF,KAAK,CAACE,KAAK,CAAC,CAAC;IACtB,CAAC;IAEDC,KAAKA,CAAEA,KAAK,EAAEC,OAAO,EAAE;MACrB,OAAOJ,KAAK,CAACG,KAAK,CAACA,KAAK,EAAEC,OAAO,CAAC;IACpC,CAAC;IAEDC,SAASA,CAAEF,KAAK,EAAEC,OAAO,EAAE;MACzB,OAAOJ,KAAK,CAACK,SAAS,CAACF,KAAK,EAAEC,OAAO,CAAC;IACxC,CAAC;IAED,MAAME,GAAGA,CAAEC,GAAG,EAAEH,OAAO,EAAE;MACvB,MAAMI,SAAS,GAAGC,eAAe,CAACF,GAAG,CAAC;MACtC,IAAIC,SAAS,CAACE,UAAU,EAAE;QACxB,OAAOC,OAAO,CAACC,OAAO,CAACJ,SAAS,CAACK,MAAM,CAAC;MAC1C;MACA,OAAOb,KAAK,CAACM,GAAG,CAACC,GAAG,EAAEH,OAAO,CAAC;IAChC,CAAC;IAED,OAAQU,OAAOA,CAAEC,IAAI,EAAEX,OAAO,EAAE;MAC9B,WAAW,MAAMG,GAAG,IAAIQ,IAAI,EAAE;QAC5B,MAAM,IAAI,CAACT,GAAG,CAACC,GAAG,EAAEH,OAAO,CAAC;MAC9B;IACF,CAAC;IAED,MAAMY,GAAGA,CAAET,GAAG,EAAEU,GAAG,EAAEb,OAAO,EAAE;MAC5B,MAAM;QAAEM;MAAW,CAAC,GAAGD,eAAe,CAACF,GAAG,CAAC;MAE3C,IAAIG,UAAU,EAAE;QACd;MACF;MAEA,MAAMV,KAAK,CAACgB,GAAG,CAACT,GAAG,EAAEU,GAAG,EAAEb,OAAO,CAAC;IACpC,CAAC;IAED,OAAQc,OAAOA,CAAEC,KAAK,EAAEf,OAAO,EAAE;MAC/B;MACA;MACA;MACA,MAAMgB,MAAM,GAAG1B,QAAQ,CAAC;QACtB2B,UAAU,EAAE;MACd,CAAC,CAAC;;MAEF;MACA;MACA,MAAMC,MAAM,GAAGC,UAAU,CAACC,OAAO,IAAID,UAAU,CAACC,OAAO,CAACC,QAAQ,GAAGF,UAAU,CAACC,OAAO,CAACC,QAAQ,GAAIF,UAAU,CAACG,YAAY,IAAIH,UAAU,CAACI,UAAW;MAEnJL,MAAM,CAAC,YAAY;QACjB,IAAI;UACF,MAAM3B,KAAK,CAACK,KAAK,CAACkB,OAAO,CAAC,mBAAoB;YAC5C,WAAW,MAAM;cAAEU,GAAG;cAAEC;YAAM,CAAC,IAAIV,KAAK,EAAE;cACxC,IAAI,CAACV,eAAe,CAACmB,GAAG,CAAC,CAAClB,UAAU,EAAE;gBACpC,MAAM;kBAAEkB,GAAG;kBAAEC;gBAAM,CAAC;cACtB;;cAEA;cACAT,MAAM,CAACU,IAAI,CAAC;gBAAEF,GAAG;gBAAEC;cAAM,CAAC,CAAC;YAC7B;UACF,CAAC,CAAC,CAAC,CAAC,CAAC;UAELT,MAAM,CAACW,GAAG,CAAC,CAAC;QACd,CAAC,CAAC,QAAO,kBAAmBC,GAAG,EAAE;UAC/BZ,MAAM,CAACW,GAAG,CAACC,GAAG,CAAC;QACjB;MACF,CAAC,CAAC;MAEF,OAAQZ,MAAM;IAChB,CAAC;IAEDa,GAAGA,CAAE1B,GAAG,EAAEH,OAAO,EAAE;MACjB,MAAM;QAAEM;MAAW,CAAC,GAAGD,eAAe,CAACF,GAAG,CAAC;MAC3C,IAAIG,UAAU,EAAE;QACd,OAAOC,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;MAC9B;MACA,OAAOZ,KAAK,CAACiC,GAAG,CAAC1B,GAAG,EAAEH,OAAO,CAAC;IAChC,CAAC;IAED8B,MAAMA,CAAE3B,GAAG,EAAEH,OAAO,EAAE;MACpB,MAAM;QAAEM;MAAW,CAAC,GAAGD,eAAe,CAACF,GAAG,CAAC;MAC3C,IAAIG,UAAU,EAAE;QACd,OAAOC,OAAO,CAACC,OAAO,CAAC,CAAC;MAC1B;MACA,OAAOZ,KAAK,CAACkC,MAAM,CAAC3B,GAAG,EAAEH,OAAO,CAAC;IACnC,CAAC;IAED+B,UAAUA,CAAEpB,IAAI,EAAEX,OAAO,EAAE;MACzB,OAAOJ,KAAK,CAACmC,UAAU,CAAC1C,MAAM,CAACsB,IAAI,EAAGR,GAAG,IAAK,CAACE,eAAe,CAACF,GAAG,CAAC,CAACG,UAAU,CAAC,EAAEN,OAAO,CAAC;IAC3F,CAAC;IAEDgC,KAAKA,CAAA,EAAI;MACP,MAAMA,KAAK,GAAGpC,KAAK,CAACoC,KAAK,CAAC,CAAC;MAE3B,OAAO;QACLpB,GAAGA,CAAET,GAAG,EAAEU,GAAG,EAAE;UACb,MAAM;YAAEP;UAAW,CAAC,GAAGD,eAAe,CAACF,GAAG,CAAC;UAE3C,IAAIG,UAAU,EAAE;YACd;UACF;UAEA0B,KAAK,CAACpB,GAAG,CAACT,GAAG,EAAEU,GAAG,CAAC;QACrB,CAAC;QACDiB,MAAMA,CAAE3B,GAAG,EAAE;UACX,MAAM;YAAEG;UAAW,CAAC,GAAGD,eAAe,CAACF,GAAG,CAAC;UAE3C,IAAIG,UAAU,EAAE;YACd;UACF;UAEA0B,KAAK,CAACF,MAAM,CAAC3B,GAAG,CAAC;QACnB,CAAC;QACD8B,MAAM,EAAGjC,OAAO,IAAK;UACnB,OAAOgC,KAAK,CAACC,MAAM,CAACjC,OAAO,CAAC;QAC9B;MACF,CAAC;IACH;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAASK,eAAeA,CAAE6B,CAAC,EAAE;EAC3B,MAAM/B,GAAG,GAAGX,GAAG,CAAC2C,KAAK,CAACD,CAAC,CAAC;EAExB,IAAI/B,GAAG,IAAI,IAAI,EAAE;IACf,MAAMV,OAAO,CAAC,IAAI2C,KAAK,CAAC,iBAAiB,CAAC,EAAE,iBAAiB,CAAC;EAChE;EAEA,IAAIjC,GAAG,CAACkC,SAAS,CAACC,IAAI,KAAK5C,QAAQ,CAAC4C,IAAI,EAAE;IACxC,OAAO;MACLhC,UAAU,EAAE;IACd,CAAC;EACH;EAEA,OAAO;IACLA,UAAU,EAAE,IAAI;IAChBG,MAAM,EAAEN,GAAG,CAACkC,SAAS,CAAC5B;EACxB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}