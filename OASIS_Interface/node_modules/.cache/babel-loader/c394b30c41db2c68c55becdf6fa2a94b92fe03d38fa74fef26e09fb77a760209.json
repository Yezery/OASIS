{"ast":null,"code":"/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { VisibilityChangeEmitter } from './visibility-change-emitter.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:connection-manager:latency-monitor');\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nexport class LatencyMonitor extends EventEmitter {\n  constructor(init = {}) {\n    super();\n    const {\n      latencyCheckIntervalMs,\n      dataEmitIntervalMs,\n      asyncTestFn,\n      latencyRandomPercentage\n    } = init;\n    // 0 isn't valid here, so its ok to use ||\n    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500; // 0.5s\n    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;\n    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100.0) * this.latencyCheckIntervalMs;\n    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;\n    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs ?? 5 * 1000; // 5s\n    log('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', this.latencyCheckIntervalMs, this.dataEmitIntervalMs);\n    if (this.dataEmitIntervalMs != null) {\n      log('Expecting ~%s events per summary', this.latencyCheckIntervalMs / this.dataEmitIntervalMs);\n    } else {\n      log('Not emitting summaries');\n    }\n    this.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n    // If process: use high resolution timer\n    if (globalThis.process?.hrtime != null) {\n      log('Using process.hrtime for timing');\n      this.now = globalThis.process.hrtime; // eslint-disable-line no-undef\n      this.getDeltaMS = startTime => {\n        const hrtime = this.now(startTime);\n        return hrtime[0] * 1000 + hrtime[1] / 1000000;\n      };\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && window.performance?.now != null) {\n      log('Using performance.now for timing');\n      this.now = window.performance.now.bind(window.performance);\n      this.getDeltaMS = startTime => Math.round(this.now() - startTime);\n    } else {\n      log('Using Date.now for timing');\n      this.now = Date.now;\n      this.getDeltaMS = startTime => this.now() - startTime;\n    }\n    this.latencyData = this.initLatencyData();\n  }\n  start() {\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    if (isBrowser()) {\n      this.visibilityChangeEmitter = new VisibilityChangeEmitter();\n      this.visibilityChangeEmitter.addEventListener('visibilityChange', evt => {\n        const {\n          detail: pageInFocus\n        } = evt;\n        if (pageInFocus) {\n          this._startTimers();\n        } else {\n          this._emitSummary();\n          this._stopTimers();\n        }\n      });\n    }\n    if (this.visibilityChangeEmitter?.isVisible() === true) {\n      this._startTimers();\n    }\n  }\n  stop() {\n    this._stopTimers();\n  }\n  /**\n   * Start internal timers\n   *\n   * @private\n   */\n  _startTimers() {\n    // Timer already started, ignore this\n    if (this.checkLatencyID != null) {\n      return;\n    }\n    this.checkLatency();\n    if (this.dataEmitIntervalMs != null) {\n      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);\n      if (typeof this.emitIntervalID.unref === 'function') {\n        this.emitIntervalID.unref(); // Doesn't block exit\n      }\n    }\n  }\n  /**\n   * Stop internal timers\n   *\n   * @private\n   */\n  _stopTimers() {\n    if (this.checkLatencyID != null) {\n      clearTimeout(this.checkLatencyID);\n      this.checkLatencyID = undefined;\n    }\n    if (this.emitIntervalID != null) {\n      clearInterval(this.emitIntervalID);\n      this.emitIntervalID = undefined;\n    }\n  }\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   *\n   * @private\n   */\n  _emitSummary() {\n    const summary = this.getSummary();\n    if (summary.events > 0) {\n      this.dispatchEvent(new CustomEvent('data', {\n        detail: summary\n      }));\n    }\n  }\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   */\n  getSummary() {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this.latencyData.events,\n      minMs: this.latencyData.minMs,\n      maxMs: this.latencyData.maxMs,\n      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this.latencyData.startTime)\n    };\n    this.latencyData = this.initLatencyData(); // Clear\n    log.trace('Summary: %O', latency);\n    return latency;\n  }\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   */\n  checkLatency() {\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;\n    // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n    const localData = {\n      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),\n      startTime: this.now()\n    };\n    const cb = () => {\n      // We are already stopped, ignore this datapoint\n      if (this.checkLatencyID == null) {\n        return;\n      }\n      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;\n      this.checkLatency(); // Start again ASAP\n      // Add the data point. If this gets complex, refactor it\n      this.latencyData.events++;\n      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);\n      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);\n      this.latencyData.totalMs += deltaMS;\n      log.trace('MS: %s Data: %O', deltaMS, this.latencyData);\n    };\n    log.trace('localData: %O', localData);\n    this.checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (this.asyncTestFn != null) {\n        // Clear timing related things\n        localData.deltaOffset = 0;\n        localData.startTime = this.now();\n        this.asyncTestFn(cb);\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1;\n        // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n        cb();\n      }\n    }, localData.deltaOffset);\n    if (typeof this.checkLatencyID.unref === 'function') {\n      this.checkLatencyID.unref(); // Doesn't block exit\n    }\n  }\n\n  initLatencyData() {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    };\n  }\n}\nfunction isBrowser() {\n  return typeof globalThis.window !== 'undefined';\n}","map":{"version":3,"names":["CustomEvent","EventEmitter","VisibilityChangeEmitter","logger","log","LatencyMonitor","constructor","init","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","latencyCheckMultiply","latencyCheckSubtract","undefined","globalThis","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","latencyData","initLatencyData","start","isBrowser","visibilityChangeEmitter","addEventListener","evt","detail","pageInFocus","_startTimers","_emitSummary","_stopTimers","isVisible","stop","checkLatencyID","checkLatency","emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","dispatchEvent","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","trace","randomness","random","localData","deltaOffset","ceil","cb","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY"],"sources":["../../../src/connection-manager/latency-monitor.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}