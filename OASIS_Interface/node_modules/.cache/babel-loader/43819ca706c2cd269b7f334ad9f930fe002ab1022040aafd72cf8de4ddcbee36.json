{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nimport debug from 'debug';\nimport first from 'it-first';\nimport { createUnsafe } from 'multiformats/block';\nimport * as cborg from 'cborg';\nimport * as dagPb from '@ipld/dag-pb';\nimport { cidToKey, keyToMultihash } from './utils/blockstore.js';\nimport { walkDag } from './utils/walk-dag.js';\nimport { PinTypes } from './pin-types.js';\nimport QuickLRU from 'quick-lru';\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').Version} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {object} FetchCompleteDagOptions\n * @property {AbortSignal} [signal]\n * @property {number} [cidCacheMaxSize]\n */\n\nconst CID_CACHE_MAX_SIZE = 2048;\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\n/**\n * @implements {Pins}\n */\nexport class PinManager {\n  /**\n   * @param {object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor({\n    pinstore,\n    blockstore,\n    loadCodec\n  }) {\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly(cid, options = {}) {\n    await this.blockstore.get(cid, options);\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]\n   */\n  async pinRecursively(cid, options = {}) {\n    await this.fetchCompleteDag(cid, options);\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    };\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async *indirectKeys(options) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n        if (result.pinned) {\n          continue;\n        }\n        yield childCid;\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n          const pin = cborg.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n      if (result) {\n        const pin = cborg.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n    const self = this;\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n    return {\n      cid,\n      pinned: false\n    };\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {FetchCompleteDagOptions} [options]\n   */\n  async fetchCompleteDag(cid, options = {}) {\n    const seen = new QuickLRU({\n      maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE\n    });\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n      seen.set(cid.toString(), true);\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block = createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block.links()].map(([, childCid]) => walkDag(childCid, options)));\n    };\n    await walkDag(cid, options);\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["CID","errCode","debug","first","createUnsafe","cborg","dagPb","cidToKey","keyToMultihash","walkDag","PinTypes","QuickLRU","CID_CACHE_MAX_SIZE","invalidPinTypeErr","type","errMsg","Error","PinManager","constructor","pinstore","blockstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","cid","options","get","pin","depth","version","code","codec","metadata","put","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","decode","value","multihash","key","create","recursiveKeys","indirectKeys","childCid","types","recursive","result","isPinnedWithType","pinned","Array","isArray","all","includes","direct","indirect","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","maxSize","cidCacheMaxSize","has","set","bytes","block","Promise","links","map","checkPinType","Object","keys"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-repo@17.0.0/node_modules/ipfs-repo/src/pin-manager.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n\nimport { CID } from 'multiformats/cid'\nimport errCode from 'err-code'\nimport debug from 'debug'\nimport first from 'it-first'\nimport { createUnsafe } from 'multiformats/block'\nimport * as cborg from 'cborg'\nimport * as dagPb from '@ipld/dag-pb'\nimport {\n  cidToKey,\n  keyToMultihash\n} from './utils/blockstore.js'\nimport { walkDag } from './utils/walk-dag.js'\nimport { PinTypes } from './pin-types.js'\nimport QuickLRU from 'quick-lru'\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').Version} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {object} FetchCompleteDagOptions\n * @property {AbortSignal} [signal]\n * @property {number} [cidCacheMaxSize]\n */\n\nconst CID_CACHE_MAX_SIZE = 2048\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\n/**\n * @implements {Pins}\n */\nexport class PinManager {\n  /**\n   * @param {object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor ({ pinstore, blockstore, loadCodec }) {\n    this.pinstore = pinstore\n    this.blockstore = blockstore\n    this.loadCodec = loadCodec\n    this.log = debug('ipfs:repo:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly (cid, options = {}) {\n    await this.blockstore.get(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin (cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & FetchCompleteDagOptions & AbortOptions} [options]\n   */\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * directKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * recursiveKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * indirectKeys (options) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType (cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cborg.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cborg.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {FetchCompleteDagOptions} [options]\n   */\n  async fetchCompleteDag (cid, options = {}) {\n    const seen = new QuickLRU({ maxSize: options.cidCacheMaxSize ?? CID_CACHE_MAX_SIZE })\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return\n      }\n\n      seen.set(cid.toString(), true)\n\n      const bytes = await this.blockstore.get(cid, options)\n      const codec = await this.loadCodec(cid.code)\n      const block = createUnsafe({ bytes, cid, codec })\n\n      await Promise.all(\n        [...block.links()].map(([, childCid]) => walkDag(childCid, options))\n      )\n    }\n\n    await walkDag(cid, options)\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n    return true\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}