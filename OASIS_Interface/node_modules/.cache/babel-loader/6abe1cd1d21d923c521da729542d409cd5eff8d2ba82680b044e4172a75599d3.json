{"ast":null,"code":"// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\nconst descriptors = ['then', 'catch', 'finally'].map(property => [property, Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nexport const mergePromise = (spawned, promise) => {\n  for (const [property, descriptor] of descriptors) {\n    // Starting the main `promise` is deferred to avoid consuming streams\n    const value = typeof promise === 'function' ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);\n    Reflect.defineProperty(spawned, property, {\n      ...descriptor,\n      value\n    });\n  }\n};\n\n// Use promises instead of `child_process` events\nexport const getSpawnedPromise = spawned => new Promise((resolve, reject) => {\n  spawned.on('exit', (exitCode, signal) => {\n    resolve({\n      exitCode,\n      signal\n    });\n  });\n  spawned.on('error', error => {\n    reject(error);\n  });\n  if (spawned.stdin) {\n    spawned.stdin.on('error', error => {\n      reject(error);\n    });\n  }\n});","map":{"version":3,"names":["nativePromisePrototype","constructor","prototype","descriptors","map","property","Reflect","getOwnPropertyDescriptor","mergePromise","spawned","promise","descriptor","value","args","apply","bind","defineProperty","getSpawnedPromise","Promise","resolve","reject","on","exitCode","signal","error","stdin"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/execa@7.2.0/node_modules/execa/lib/promise.js"],"sourcesContent":["// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nexport const mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function'\n\t\t\t? (...args) => Reflect.apply(descriptor.value, promise(), args)\n\t\t\t: descriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n};\n\n// Use promises instead of `child_process` events\nexport const getSpawnedPromise = spawned => new Promise((resolve, reject) => {\n\tspawned.on('exit', (exitCode, signal) => {\n\t\tresolve({exitCode, signal});\n\t});\n\n\tspawned.on('error', error => {\n\t\treject(error);\n\t});\n\n\tif (spawned.stdin) {\n\t\tspawned.stdin.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\t}\n});\n"],"mappings":"AAAA;AACA,MAAMA,sBAAsB,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,CAACC,WAAW,CAACC,SAAS;AAEvE,MAAMC,WAAW,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAACC,GAAG,CAACC,QAAQ,IAAI,CAChEA,QAAQ,EACRC,OAAO,CAACC,wBAAwB,CAACP,sBAAsB,EAAEK,QAAQ,CAAC,CAClE,CAAC;;AAEF;AACA,OAAO,MAAMG,YAAY,GAAGA,CAACC,OAAO,EAAEC,OAAO,KAAK;EACjD,KAAK,MAAM,CAACL,QAAQ,EAAEM,UAAU,CAAC,IAAIR,WAAW,EAAE;IACjD;IACA,MAAMS,KAAK,GAAG,OAAOF,OAAO,KAAK,UAAU,GACxC,CAAC,GAAGG,IAAI,KAAKP,OAAO,CAACQ,KAAK,CAACH,UAAU,CAACC,KAAK,EAAEF,OAAO,CAAC,CAAC,EAAEG,IAAI,CAAC,GAC7DF,UAAU,CAACC,KAAK,CAACG,IAAI,CAACL,OAAO,CAAC;IAEjCJ,OAAO,CAACU,cAAc,CAACP,OAAO,EAAEJ,QAAQ,EAAE;MAAC,GAAGM,UAAU;MAAEC;IAAK,CAAC,CAAC;EAClE;AACD,CAAC;;AAED;AACA,OAAO,MAAMK,iBAAiB,GAAGR,OAAO,IAAI,IAAIS,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;EAC5EX,OAAO,CAACY,EAAE,CAAC,MAAM,EAAE,CAACC,QAAQ,EAAEC,MAAM,KAAK;IACxCJ,OAAO,CAAC;MAACG,QAAQ;MAAEC;IAAM,CAAC,CAAC;EAC5B,CAAC,CAAC;EAEFd,OAAO,CAACY,EAAE,CAAC,OAAO,EAAEG,KAAK,IAAI;IAC5BJ,MAAM,CAACI,KAAK,CAAC;EACd,CAAC,CAAC;EAEF,IAAIf,OAAO,CAACgB,KAAK,EAAE;IAClBhB,OAAO,CAACgB,KAAK,CAACJ,EAAE,CAAC,OAAO,EAAEG,KAAK,IAAI;MAClCJ,MAAM,CAACI,KAAK,CAAC;IACd,CAAC,CAAC;EACH;AACD,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}