{"ast":null,"code":"/**\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n * @typedef {import('./types').LoadBaseFn} LoadBaseFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadBaseFn}\n */\nconst LOAD_BASE = name => Promise.reject(new Error(`No base found for \"${name}\"`));\nexport class Multibases {\n  /**\n   * @param {object} options\n   * @param {LoadBaseFn} [options.loadBase]\n   * @param {MultibaseCodec[]} options.bases\n   */\n  constructor(options) {\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByName = {};\n\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByPrefix = {};\n    this._loadBase = options.loadBase || LOAD_BASE;\n\n    // Enable all supplied codecs\n    for (const base of options.bases) {\n      this.addBase(base);\n    }\n  }\n\n  /**\n   * Add support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  addBase(base) {\n    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {\n      throw new Error(`Codec already exists for codec \"${base.name}\"`);\n    }\n    this._basesByName[base.name] = base;\n    this._basesByPrefix[base.prefix] = base;\n  }\n\n  /**\n   * Remove support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  removeBase(base) {\n    delete this._basesByName[base.name];\n    delete this._basesByPrefix[base.prefix];\n  }\n\n  /**\n   * @param {string} nameOrPrefix\n   */\n  async getBase(nameOrPrefix) {\n    if (this._basesByName[nameOrPrefix]) {\n      return this._basesByName[nameOrPrefix];\n    }\n    if (this._basesByPrefix[nameOrPrefix]) {\n      return this._basesByPrefix[nameOrPrefix];\n    }\n\n    // If not supported, attempt to dynamically load this codec\n    const base = await this._loadBase(nameOrPrefix);\n    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {\n      this.addBase(base);\n    }\n    return base;\n  }\n  listBases() {\n    return Object.values(this._basesByName);\n  }\n}","map":{"version":3,"names":["LOAD_BASE","name","Promise","reject","Error","Multibases","constructor","options","_basesByName","_basesByPrefix","_loadBase","loadBase","base","bases","addBase","prefix","removeBase","getBase","nameOrPrefix","listBases","Object","values"],"sources":["/Users/yezery/OASIS/OASIS_Interface/node_modules/.store/ipfs-core-utils@0.18.1/node_modules/ipfs-core-utils/src/multibases.js"],"sourcesContent":["/**\n * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec\n * @typedef {import('./types').LoadBaseFn} LoadBaseFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadBaseFn}\n */\nconst LOAD_BASE = (name) => Promise.reject(new Error(`No base found for \"${name}\"`))\n\nexport class Multibases {\n  /**\n   * @param {object} options\n   * @param {LoadBaseFn} [options.loadBase]\n   * @param {MultibaseCodec[]} options.bases\n   */\n  constructor (options) {\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByName = {}\n\n    // Object with current list of active resolvers\n    /** @type {Record<string, MultibaseCodec>}} */\n    this._basesByPrefix = {}\n\n    this._loadBase = options.loadBase || LOAD_BASE\n\n    // Enable all supplied codecs\n    for (const base of options.bases) {\n      this.addBase(base)\n    }\n  }\n\n  /**\n   * Add support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  addBase (base) {\n    if (this._basesByName[base.name] || this._basesByPrefix[base.prefix]) {\n      throw new Error(`Codec already exists for codec \"${base.name}\"`)\n    }\n\n    this._basesByName[base.name] = base\n    this._basesByPrefix[base.prefix] = base\n  }\n\n  /**\n   * Remove support for a multibase codec\n   *\n   * @param {MultibaseCodec} base\n   */\n  removeBase (base) {\n    delete this._basesByName[base.name]\n    delete this._basesByPrefix[base.prefix]\n  }\n\n  /**\n   * @param {string} nameOrPrefix\n   */\n  async getBase (nameOrPrefix) {\n    if (this._basesByName[nameOrPrefix]) {\n      return this._basesByName[nameOrPrefix]\n    }\n\n    if (this._basesByPrefix[nameOrPrefix]) {\n      return this._basesByPrefix[nameOrPrefix]\n    }\n\n    // If not supported, attempt to dynamically load this codec\n    const base = await this._loadBase(nameOrPrefix)\n\n    if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {\n      this.addBase(base)\n    }\n\n    return base\n  }\n\n  listBases () {\n    return Object.values(this._basesByName)\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMA,SAAS,GAAIC,IAAI,IAAKC,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAE,sBAAqBH,IAAK,GAAE,CAAC,CAAC;AAEpF,OAAO,MAAMI,UAAU,CAAC;EACtB;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAAEC,OAAO,EAAE;IACpB;IACA;IACA,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;;IAEtB;IACA;IACA,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IAExB,IAAI,CAACC,SAAS,GAAGH,OAAO,CAACI,QAAQ,IAAIX,SAAS;;IAE9C;IACA,KAAK,MAAMY,IAAI,IAAIL,OAAO,CAACM,KAAK,EAAE;MAChC,IAAI,CAACC,OAAO,CAACF,IAAI,CAAC;IACpB;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEE,OAAOA,CAAEF,IAAI,EAAE;IACb,IAAI,IAAI,CAACJ,YAAY,CAACI,IAAI,CAACX,IAAI,CAAC,IAAI,IAAI,CAACQ,cAAc,CAACG,IAAI,CAACG,MAAM,CAAC,EAAE;MACpE,MAAM,IAAIX,KAAK,CAAE,mCAAkCQ,IAAI,CAACX,IAAK,GAAE,CAAC;IAClE;IAEA,IAAI,CAACO,YAAY,CAACI,IAAI,CAACX,IAAI,CAAC,GAAGW,IAAI;IACnC,IAAI,CAACH,cAAc,CAACG,IAAI,CAACG,MAAM,CAAC,GAAGH,IAAI;EACzC;;EAEA;AACF;AACA;AACA;AACA;EACEI,UAAUA,CAAEJ,IAAI,EAAE;IAChB,OAAO,IAAI,CAACJ,YAAY,CAACI,IAAI,CAACX,IAAI,CAAC;IACnC,OAAO,IAAI,CAACQ,cAAc,CAACG,IAAI,CAACG,MAAM,CAAC;EACzC;;EAEA;AACF;AACA;EACE,MAAME,OAAOA,CAAEC,YAAY,EAAE;IAC3B,IAAI,IAAI,CAACV,YAAY,CAACU,YAAY,CAAC,EAAE;MACnC,OAAO,IAAI,CAACV,YAAY,CAACU,YAAY,CAAC;IACxC;IAEA,IAAI,IAAI,CAACT,cAAc,CAACS,YAAY,CAAC,EAAE;MACrC,OAAO,IAAI,CAACT,cAAc,CAACS,YAAY,CAAC;IAC1C;;IAEA;IACA,MAAMN,IAAI,GAAG,MAAM,IAAI,CAACF,SAAS,CAACQ,YAAY,CAAC;IAE/C,IAAI,IAAI,CAACV,YAAY,CAACI,IAAI,CAACX,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAACQ,cAAc,CAACG,IAAI,CAACG,MAAM,CAAC,IAAI,IAAI,EAAE;MACpF,IAAI,CAACD,OAAO,CAACF,IAAI,CAAC;IACpB;IAEA,OAAOA,IAAI;EACb;EAEAO,SAASA,CAAA,EAAI;IACX,OAAOC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACb,YAAY,CAAC;EACzC;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}