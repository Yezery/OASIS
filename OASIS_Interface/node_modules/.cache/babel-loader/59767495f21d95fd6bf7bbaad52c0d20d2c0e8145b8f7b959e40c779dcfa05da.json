{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';\nimport errCode from 'err-code';\nimport { NotEnabledError } from '../errors.js';\nimport get from 'dlv';\n\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<CustomEvent<Message>>} EventHandler\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageEventHandler\n */\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\nexport function createPubsub({\n  network,\n  config\n}) {\n  const isEnabled = get(config || {}, 'Pubsub.Enabled', true);\n\n  /** @type {Record<string, MessageEventHandler[]>} */\n  const handlers = {};\n  /** @type {EventHandler | undefined} */\n  let onMessage;\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  };\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"subscribe\"]}\n   */\n  async function subscribe(topic, handler, options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n    libp2p.pubsub.subscribe(topic);\n\n    // listen for 'message' events if we aren't already\n    if (onMessage == null) {\n      onMessage = evt => {\n        const msg = evt.detail;\n        if (handlers[msg.topic]) {\n          handlers[msg.topic].forEach(handler => {\n            if (typeof handler === 'function') {\n              handler(msg);\n              return;\n            }\n            if (handler != null && handler.handleEvent != null) {\n              handler.handleEvent(msg);\n            }\n          });\n        }\n      };\n      libp2p.pubsub.addEventListener('message', onMessage);\n    }\n\n    // store handler for future invocation\n    if (handler != null) {\n      if (handlers[topic] == null) {\n        handlers[topic] = [];\n      }\n      handlers[topic].push(handler);\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"unsubscribe\"]}\n   */\n  async function unsubscribe(topic, handler, options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n\n    // remove handler from local map\n    if (handler != null && handlers[topic] != null) {\n      handlers[topic] = handlers[topic].filter(h => h !== handler);\n      if (handlers[topic].length === 0) {\n        delete handlers[topic];\n      }\n    }\n\n    // remove all handlers\n    if (typeof handler !== 'function') {\n      delete handlers[topic];\n    }\n\n    // no more handlers for this topic, unsubscribe\n    if (handlers[topic] == null) {\n      libp2p.pubsub.unsubscribe(topic);\n    }\n\n    // no more pubsub handlers, remove message listener\n    if (Object.keys(handlers).length === 0) {\n      libp2p.pubsub.removeEventListener('message', onMessage);\n      onMessage = undefined;\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"publish\"]}\n   */\n  async function publish(topic, data, options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n    if (!data) {\n      throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED');\n    }\n    await libp2p.pubsub.publish(topic, data);\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"ls\"]}\n   */\n  async function ls(options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n    return libp2p.pubsub.getTopics();\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"peers\"]}\n   */\n  async function peers(topic, options = {}) {\n    const {\n      libp2p\n    } = await network.use(options);\n    return libp2p.pubsub.getSubscribers(topic);\n  }\n}\nconst notEnabled = async () => {\n  // eslint-disable-line require-await\n  throw new NotEnabledError('pubsub not enabled');\n};","map":{"version":3,"names":["withTimeoutOption","errCode","NotEnabledError","get","createPubsub","network","config","isEnabled","handlers","onMessage","subscribe","notEnabled","unsubscribe","publish","ls","peers","topic","handler","options","libp2p","use","pubsub","evt","msg","detail","forEach","handleEvent","addEventListener","push","filter","h","length","Object","keys","removeEventListener","undefined","data","Error","getTopics","getSubscribers"],"sources":["/Users/yezery/Oasis/OASIS/node_modules/.store/ipfs-core@0.18.1/node_modules/ipfs-core/src/components/pubsub.js"],"sourcesContent":["import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option'\nimport errCode from 'err-code'\nimport { NotEnabledError } from '../errors.js'\nimport get from 'dlv'\n\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<CustomEvent<Message>>} EventHandler\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageEventHandler\n */\n\n/**\n * @param {object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\nexport function createPubsub ({ network, config }) {\n  const isEnabled = get(config || {}, 'Pubsub.Enabled', true)\n\n  /** @type {Record<string, MessageEventHandler[]>} */\n  const handlers = {}\n  /** @type {EventHandler | undefined} */\n  let onMessage\n\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"subscribe\"]}\n   */\n  async function subscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    libp2p.pubsub.subscribe(topic)\n\n    // listen for 'message' events if we aren't already\n    if (onMessage == null) {\n      onMessage = (evt) => {\n        const msg = evt.detail\n\n        if (handlers[msg.topic]) {\n          handlers[msg.topic].forEach(handler => {\n            if (typeof handler === 'function') {\n              handler(msg)\n              return\n            }\n\n            if (handler != null && handler.handleEvent != null) {\n              handler.handleEvent(msg)\n            }\n          })\n        }\n      }\n\n      libp2p.pubsub.addEventListener('message', onMessage)\n    }\n\n    // store handler for future invocation\n    if (handler != null) {\n      if (handlers[topic] == null) {\n        handlers[topic] = []\n      }\n\n      handlers[topic].push(handler)\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"unsubscribe\"]}\n   */\n  async function unsubscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    // remove handler from local map\n    if (handler != null && handlers[topic] != null) {\n      handlers[topic] = handlers[topic].filter(h => h !== handler)\n\n      if (handlers[topic].length === 0) {\n        delete handlers[topic]\n      }\n    }\n\n    // remove all handlers\n    if (typeof handler !== 'function') {\n      delete handlers[topic]\n    }\n\n    // no more handlers for this topic, unsubscribe\n    if (handlers[topic] == null) {\n      libp2p.pubsub.unsubscribe(topic)\n    }\n\n    // no more pubsub handlers, remove message listener\n    if (Object.keys(handlers).length === 0) {\n      libp2p.pubsub.removeEventListener('message', onMessage)\n      onMessage = undefined\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"publish\"]}\n   */\n  async function publish (topic, data, options = {}) {\n    const { libp2p } = await network.use(options)\n    if (!data) {\n      throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED')\n    }\n\n    await libp2p.pubsub.publish(topic, data)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    const { libp2p } = await network.use(options)\n\n    return libp2p.pubsub.getTopics()\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API<{}>[\"peers\"]}\n   */\n  async function peers (topic, options = {}) {\n    const { libp2p } = await network.use(options)\n\n    return libp2p.pubsub.getSubscribers(topic)\n  }\n}\n\nconst notEnabled = async () => { // eslint-disable-line require-await\n  throw new NotEnabledError('pubsub not enabled')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}