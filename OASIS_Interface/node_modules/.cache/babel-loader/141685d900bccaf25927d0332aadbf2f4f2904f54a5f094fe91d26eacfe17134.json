{"ast":null,"code":"import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport * as mss from '@libp2p/multistream-select';\nimport { codes } from './errors.js';\nimport { createConnection } from './connection/index.js';\nimport { CustomEvent, EventEmitter } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { abortableDuplex } from 'abortable-iterator';\nimport { setMaxListeners } from 'events';\nconst log = logger('libp2p:upgrader');\nfunction findIncomingStreamLimit(protocol, registrar) {\n  try {\n    const {\n      options\n    } = registrar.getHandler(protocol);\n    return options.maxInboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n  return DEFAULT_MAX_INBOUND_STREAMS;\n}\nfunction findOutgoingStreamLimit(protocol, registrar) {\n  try {\n    const {\n      options\n    } = registrar.getHandler(protocol);\n    return options.maxOutboundStreams;\n  } catch (err) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err;\n    }\n  }\n  return DEFAULT_MAX_OUTBOUND_STREAMS;\n}\nfunction countStreams(protocol, direction, connection) {\n  let streamCount = 0;\n  connection.streams.forEach(stream => {\n    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {\n      streamCount++;\n    }\n  });\n  return streamCount;\n}\nexport class DefaultUpgrader extends EventEmitter {\n  constructor(components, init) {\n    super();\n    this.components = components;\n    this.connectionEncryption = new Map();\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter);\n    });\n    this.muxers = new Map();\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer);\n    });\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;\n  }\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound(maConn, opts) {\n    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);\n    if (!accept) {\n      throw errCode(new Error('connection denied'), codes.ERR_CONNECTION_DENIED);\n    }\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let muxerFactory;\n    let cryptoProtocol;\n    const timeoutController = new TimeoutController(this.inboundUpgradeTimeout);\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, timeoutController.signal);\n    } catch {}\n    try {\n      const abortableStream = abortableDuplex(maConn, timeoutController.signal);\n      maConn.source = abortableStream.source;\n      maConn.sink = abortableStream.sink;\n      if (await this.components.connectionGater.denyInboundConnection(maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n      this.components.metrics?.trackMultiaddrConnection(maConn);\n      log('starting the inbound connection upgrade');\n      // Protect\n      let protectedConn = maConn;\n      if (opts?.skipProtection !== true) {\n        const protector = this.components.connectionProtector;\n        if (protector != null) {\n          log('protecting the inbound connection');\n          protectedConn = await protector.protect(maConn);\n        }\n      }\n      try {\n        // Encrypt the connection\n        encryptedConn = protectedConn;\n        if (opts?.skipEncryption !== true) {\n          ({\n            conn: encryptedConn,\n            remotePeer,\n            protocol: cryptoProtocol\n          } = await this._encryptInbound(protectedConn));\n          if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, {\n            ...protectedConn,\n            ...encryptedConn\n          })) {\n            throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n          }\n        } else {\n          const idStr = maConn.remoteAddr.getPeerId();\n          if (idStr == null) {\n            throw errCode(new Error('inbound connection that skipped encryption must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n          }\n          const remotePeerId = peerIdFromString(idStr);\n          cryptoProtocol = 'native';\n          remotePeer = remotePeerId;\n        }\n        upgradedConn = encryptedConn;\n        if (opts?.muxerFactory != null) {\n          muxerFactory = opts.muxerFactory;\n        } else if (this.muxers.size > 0) {\n          // Multiplex the connection\n          const multiplexed = await this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.muxers);\n          muxerFactory = multiplexed.muxerFactory;\n          upgradedConn = multiplexed.stream;\n        }\n      } catch (err) {\n        log.error('Failed to upgrade inbound connection', err);\n        throw err;\n      }\n      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, {\n        ...protectedConn,\n        ...encryptedConn\n      })) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n      log('Successfully upgraded inbound connection');\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer\n      });\n    } finally {\n      this.components.connectionManager.afterUpgradeInbound();\n      timeoutController.clear();\n    }\n  }\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound(maConn, opts) {\n    const idStr = maConn.remoteAddr.getPeerId();\n    let remotePeerId;\n    if (idStr != null) {\n      remotePeerId = peerIdFromString(idStr);\n      if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      }\n    }\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let muxerFactory;\n    this.components.metrics?.trackMultiaddrConnection(maConn);\n    log('Starting the outbound connection upgrade');\n    // If the transport natively supports encryption, skip connection\n    // protector and encryption\n    // Protect\n    let protectedConn = maConn;\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector;\n      if (protector != null) {\n        protectedConn = await protector.protect(maConn);\n      }\n    }\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn;\n      if (opts?.skipEncryption !== true) {\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptOutbound(protectedConn, remotePeerId));\n        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, {\n          ...protectedConn,\n          ...encryptedConn\n        })) {\n          throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n        }\n      } else {\n        if (remotePeerId == null) {\n          throw errCode(new Error('Encryption was skipped but no peer id was passed'), codes.ERR_INVALID_PEER);\n        }\n        cryptoProtocol = 'native';\n        remotePeer = remotePeerId;\n      }\n      upgradedConn = encryptedConn;\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory;\n      } else if (this.muxers.size > 0) {\n        // Multiplex the connection\n        const multiplexed = await this._multiplexOutbound({\n          ...protectedConn,\n          ...encryptedConn\n        }, this.muxers);\n        muxerFactory = multiplexed.muxerFactory;\n        upgradedConn = multiplexed.stream;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, {\n      ...protectedConn,\n      ...encryptedConn\n    })) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection(opts) {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory\n    } = opts;\n    let muxer;\n    let newStream;\n    let connection; // eslint-disable-line prefer-const\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return;\n          }\n          void Promise.resolve().then(async () => {\n            const protocols = this.components.registrar.getProtocols();\n            const {\n              stream,\n              protocol\n            } = await mss.handle(muxedStream, protocols);\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (connection == null) {\n              return;\n            }\n            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);\n            const streamCount = countStreams(protocol, 'inbound', connection);\n            if (streamCount === incomingLimit) {\n              muxedStream.abort(errCode(new Error(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));\n              return;\n            }\n            // after the handshake the returned stream can have early data so override\n            // the souce/sink\n            muxedStream.source = stream.source;\n            muxedStream.sink = stream.sink;\n            muxedStream.stat.protocol = protocol;\n            // If a protocol stream has been successfully negotiated and is to be passed to the application,\n            // the peerstore should ensure that the peer is registered with that protocol\n            this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err));\n            connection.addStream(muxedStream);\n            this.components.metrics?.trackProtocolStream(muxedStream, connection);\n            this._onStream({\n              connection,\n              stream: muxedStream,\n              protocol\n            });\n          }).catch(err => {\n            log.error(err);\n            if (muxedStream.stat.timeline.close == null) {\n              muxedStream.close();\n            }\n          });\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection?.removeStream(muxedStream.id);\n        }\n      });\n      newStream = async (protocols, options = {}) => {\n        if (muxer == null) {\n          throw errCode(new Error('Stream is not multiplexed'), codes.ERR_MUXER_UNAVAILABLE);\n        }\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = await muxer.newStream();\n        let controller;\n        try {\n          if (options.signal == null) {\n            log('No abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols);\n            controller = new TimeoutController(30000);\n            options.signal = controller.signal;\n            try {\n              // fails on node < 15.4\n              setMaxListeners?.(Infinity, controller.signal);\n            } catch {}\n          }\n          const {\n            stream,\n            protocol\n          } = await mss.select(muxedStream, protocols, options);\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar);\n          const streamCount = countStreams(protocol, 'outbound', connection);\n          if (streamCount === outgoingLimit) {\n            const err = errCode(new Error(`Too many outbound protocol streams for protocol \"${protocol}\" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);\n            muxedStream.abort(err);\n            throw err;\n          }\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch(err => log.error(err));\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source;\n          muxedStream.sink = stream.sink;\n          muxedStream.stat.protocol = protocol;\n          this.components.metrics?.trackProtocolStream(muxedStream, connection);\n          return muxedStream;\n        } catch (err) {\n          log.error('could not create new stream', err);\n          if (muxedStream.stat.timeline.close == null) {\n            muxedStream.close();\n          }\n          if (err.code != null) {\n            throw err;\n          }\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        } finally {\n          if (controller != null) {\n            controller.clear();\n          }\n        }\n      };\n      // Pipe all data through the muxer\n      void Promise.all([muxer.sink(upgradedConn.source), upgradedConn.sink(muxer.source)]).catch(err => {\n        log.error(err);\n      });\n    }\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'OPEN') {\n                await connection.close();\n              }\n            } catch (err) {\n              log.error(err);\n            } finally {\n              this.dispatchEvent(new CustomEvent('connectionEnd', {\n                detail: connection\n              }));\n            }\n          })().catch(err => {\n            log.error(err);\n          });\n        }\n        return Reflect.set(...args);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n    };\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer: remotePeer,\n      stat: {\n        status: 'OPEN',\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: muxer?.protocol,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close();\n        // Ensure remaining streams are closed\n        if (muxer != null) {\n          muxer.close();\n        }\n      }\n    });\n    this.dispatchEvent(new CustomEvent('connection', {\n      detail: connection\n    }));\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream(opts) {\n    const {\n      connection,\n      stream,\n      protocol\n    } = opts;\n    const {\n      handler\n    } = this.components.registrar.getHandler(protocol);\n    handler({\n      connection,\n      stream\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound(connection) {\n    const protocols = Array.from(this.connectionEncryption.keys());\n    log('handling inbound crypto protocol selection', protocols);\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      });\n      const encrypter = this.connectionEncryption.get(protocol);\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n      log('encrypting inbound connection...');\n      return {\n        ...(await encrypter.secureInbound(this.components.peerId, stream)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound(connection, remotePeerId) {\n    const protocols = Array.from(this.connectionEncryption.keys());\n    log('selecting outbound crypto protocol', protocols);\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        writeBytes: true\n      });\n      const encrypter = this.connectionEncryption.get(protocol);\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n      log('encrypting outbound connection to %p', remotePeerId);\n      return {\n        ...(await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound(connection, muxers) {\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        writeBytes: true\n      });\n      log('%s selected as muxer protocol', protocol);\n      const muxerFactory = muxers.get(protocol);\n      return {\n        stream,\n        muxerFactory\n      };\n    } catch (err) {\n      log.error('error multiplexing outbound stream', err);\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound(connection, muxers) {\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(connection, protocols, {\n        writeBytes: true\n      });\n      const muxerFactory = muxers.get(protocol);\n      return {\n        stream,\n        muxerFactory\n      };\n    } catch (err) {\n      log.error('error multiplexing inbound stream', err);\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n}","map":{"version":3,"names":["logger","errCode","mss","codes","createConnection","CustomEvent","EventEmitter","peerIdFromString","DEFAULT_MAX_INBOUND_STREAMS","DEFAULT_MAX_OUTBOUND_STREAMS","TimeoutController","abortableDuplex","setMaxListeners","log","findIncomingStreamLimit","protocol","registrar","options","getHandler","maxInboundStreams","err","code","ERR_NO_HANDLER_FOR_PROTOCOL","findOutgoingStreamLimit","maxOutboundStreams","countStreams","direction","connection","streamCount","streams","forEach","stream","stat","DefaultUpgrader","constructor","components","init","connectionEncryption","Map","encrypter","set","muxers","muxer","inboundUpgradeTimeout","upgradeInbound","maConn","opts","accept","connectionManager","acceptIncomingConnection","Error","ERR_CONNECTION_DENIED","encryptedConn","remotePeer","upgradedConn","muxerFactory","cryptoProtocol","timeoutController","Infinity","signal","abortableStream","source","sink","connectionGater","denyInboundConnection","ERR_CONNECTION_INTERCEPTED","metrics","trackMultiaddrConnection","protectedConn","skipProtection","protector","connectionProtector","protect","skipEncryption","conn","_encryptInbound","denyInboundEncryptedConnection","idStr","remoteAddr","getPeerId","ERR_INVALID_MULTIADDR","remotePeerId","size","multiplexed","_multiplexInbound","error","denyInboundUpgradedConnection","_createConnection","afterUpgradeInbound","clear","upgradeOutbound","denyOutboundConnection","_encryptOutbound","denyOutboundEncryptedConnection","ERR_INVALID_PEER","_multiplexOutbound","close","denyOutboundUpgradedConnection","newStream","createStreamMuxer","onIncomingStream","muxedStream","Promise","resolve","then","protocols","getProtocols","handle","incomingLimit","abort","ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS","peerStore","protoBook","add","catch","addStream","trackProtocolStream","_onStream","timeline","onStreamEnd","removeStream","id","ERR_MUXER_UNAVAILABLE","controller","select","outgoingLimit","ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS","ERR_UNSUPPORTED_PROTOCOL","all","_timeline","Proxy","args","status","dispatchEvent","detail","Reflect","upgraded","Date","now","errConnectionNotMultiplexed","ERR_CONNECTION_NOT_MULTIPLEXED","multiplexer","encryption","getStreams","handler","Array","from","keys","writeBytes","get","secureInbound","peerId","ERR_ENCRYPTION_FAILED","secureOutbound"],"sources":["../../src/upgrader.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}