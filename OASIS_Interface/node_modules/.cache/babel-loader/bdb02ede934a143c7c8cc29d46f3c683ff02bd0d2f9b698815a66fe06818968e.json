{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { xor as uint8ArrayXor } from 'uint8arrays/xor';\nimport GENERATED_PREFIXES from './generated-prefix-list.js';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { randomBytes } from '@libp2p/crypto';\nimport { peerIdFromBytes } from '@libp2p/peer-id';\nimport { logger } from '@libp2p/logger';\nimport length from 'it-length';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } from '../constants.js';\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nexport class RoutingTableRefresh {\n  constructor(init) {\n    const {\n      peerRouting,\n      routingTable,\n      refreshInterval,\n      refreshQueryTimeout,\n      lan\n    } = init;\n    this.log = logger(`libp2p:kad-dht:${lan ? 'lan' : 'wan'}:routing-table:refresh`);\n    this.peerRouting = peerRouting;\n    this.routingTable = routingTable;\n    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;\n    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;\n    this.commonPrefixLengthRefreshedAt = [];\n    this.refreshTable = this.refreshTable.bind(this);\n  }\n  async start() {\n    this.log(`refreshing routing table every ${this.refreshInterval}ms`);\n    this.refreshTable(true);\n  }\n  async stop() {\n    if (this.refreshTimeoutId != null) {\n      clearTimeout(this.refreshTimeoutId);\n    }\n  }\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   */\n  refreshTable(force = false) {\n    this.log('refreshing routing table');\n    const prefixLength = this._maxCommonPrefix();\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n    this.log(`max common prefix length ${prefixLength}`);\n    this.log(`tracked CPLs [ ${refreshCpls.map(date => date.toISOString()).join(', ')} ]`);\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n      try {\n        await this._refreshCommonPrefixLength(index, lastRefresh, force);\n        if (this._numPeersForCpl(prefixLength) === 0) {\n          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n          for (let n = index + 1; n < lastCpl + 1; n++) {\n            try {\n              await this._refreshCommonPrefixLength(n, lastRefresh, force);\n            } catch (err) {\n              this.log.error(err);\n            }\n          }\n        }\n      } catch (err) {\n        this.log.error(err);\n      }\n    })).catch(err => {\n      this.log.error(err);\n    }).then(() => {\n      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);\n      if (this.refreshTimeoutId.unref != null) {\n        this.refreshTimeoutId.unref();\n      }\n    }).catch(err => {\n      this.log.error(err);\n    });\n  }\n  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {\n      this.log('not running refresh for cpl %s as time since last refresh not above interval', cpl);\n      return;\n    }\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl);\n    this.log('starting refreshing cpl %s with key %p (routing table size was %s)', cpl, peerId, this.routingTable.size);\n    const controller = new TimeoutController(this.refreshQueryTimeout);\n    try {\n      const peers = await length(this.peerRouting.getClosestPeers(peerId.toBytes(), {\n        signal: controller.signal\n      }));\n      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);\n      this.log('finished refreshing cpl %s with key %p (routing table size is now %s)', cpl, peerId, this.routingTable.size);\n    } finally {\n      controller.clear();\n    }\n  }\n  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n    }\n    const dates = [];\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? new Date();\n    }\n    return dates;\n  }\n  async _generateRandomPeerId(targetCommonPrefixLength) {\n    if (this.routingTable.kb == null) {\n      throw new Error('Routing table not started');\n    }\n    const randomData = randomBytes(2);\n    const randomUint16 = (randomData[1] << 8) + randomData[0];\n    const key = await this._makePeerId(this.routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n    return peerIdFromBytes(key);\n  }\n  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n    }\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n    const localPrefix = view.getUint16(0, false);\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength;\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n    const keyBuffer = new ArrayBuffer(34);\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n    keyView.setUint8(0, sha256.code);\n    keyView.setUint8(1, 32);\n    keyView.setUint32(2, keyPrefix, false);\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n  }\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix() {\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0;\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length;\n      }\n    }\n    return prefixLength;\n  }\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   */\n  _numPeersForCpl(prefixLength) {\n    let count = 0;\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++;\n      }\n    }\n    return count;\n  }\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  *_prefixLengths() {\n    if (this.routingTable.kb == null) {\n      return;\n    }\n    for (const {\n      id\n    } of this.routingTable.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.routingTable.kb.localNodeId, id);\n      let leadingZeros = 0;\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++;\n        } else {\n          break;\n        }\n      }\n      yield leadingZeros;\n    }\n  }\n}","map":{"version":3,"names":["xor","uint8ArrayXor","GENERATED_PREFIXES","sha256","randomBytes","peerIdFromBytes","logger","length","TimeoutController","TABLE_REFRESH_INTERVAL","TABLE_REFRESH_QUERY_TIMEOUT","MAX_COMMON_PREFIX_LENGTH","RoutingTableRefresh","constructor","init","peerRouting","routingTable","refreshInterval","refreshQueryTimeout","lan","log","commonPrefixLengthRefreshedAt","refreshTable","bind","start","stop","refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","toISOString","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","err","error","catch","then","setTimeout","unref","cpl","getTime","Date","now","peerId","_generateRandomPeerId","size","controller","peers","getClosestPeers","toBytes","signal","clear","maxCommonPrefix","dates","i","targetCommonPrefixLength","kb","Error","randomData","randomUint16","key","_makePeerId","localNodeId","localKadId","randomPrefix","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","count","id","toIterable","distance","leadingZeros","byte"],"sources":["../../../src/routing-table/refresh.ts"],"sourcesContent":[null],"mappings":";;;AAAA,SAASA,GAAG,IAAIC,aAAa,QAAQ,iBAAiB;AACtD,OAAOC,kBAAkB,MAAM,4BAA4B;AAC3D,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,eAAe,QAAQ,iBAAiB;AACjD,SAASC,MAAM,QAAQ,gBAAgB;AACvC,OAAOC,MAAM,MAAM,WAAW;AAC9B,SAASC,iBAAiB,QAAQ,0BAA0B;AAC5D,SAASC,sBAAsB,EAAEC,2BAA2B,QAAQ,iBAAiB;AAMrF;;;AAGA,MAAMC,wBAAwB,GAAG,EAAE;AAUnC;;;;AAIA,OAAM,MAAOC,mBAAmB;EAS9BC,YAAaC,IAA6B;IACxC,MAAM;MAAEC,WAAW;MAAEC,YAAY;MAAEC,eAAe;MAAEC,mBAAmB;MAAEC;IAAG,CAAE,GAAGL,IAAI;IACrF,IAAI,CAACM,GAAG,GAAGd,MAAM,CAAC,kBAAkBa,GAAG,GAAG,KAAK,GAAG,KAAK,wBAAwB,CAAC;IAChF,IAAI,CAACJ,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,eAAe,GAAGA,eAAe,IAAIR,sBAAsB;IAChE,IAAI,CAACS,mBAAmB,GAAGA,mBAAmB,IAAIR,2BAA2B;IAC7E,IAAI,CAACW,6BAA6B,GAAG,EAAE;IAEvC,IAAI,CAACC,YAAY,GAAG,IAAI,CAACA,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC;EAClD;EAEA,MAAMC,KAAKA,CAAA;IACT,IAAI,CAACJ,GAAG,CAAC,kCAAkC,IAAI,CAACH,eAAe,IAAI,CAAC;IACpE,IAAI,CAACK,YAAY,CAAC,IAAI,CAAC;EACzB;EAEA,MAAMG,IAAIA,CAAA;IACR,IAAI,IAAI,CAACC,gBAAgB,IAAI,IAAI,EAAE;MACjCC,YAAY,CAAC,IAAI,CAACD,gBAAgB,CAAC;;EAEvC;EAEA;;;;;;EAMAJ,YAAYA,CAAEM,KAAA,GAAiB,KAAK;IAClC,IAAI,CAACR,GAAG,CAAC,0BAA0B,CAAC;IAEpC,MAAMS,YAAY,GAAG,IAAI,CAACC,gBAAgB,EAAE;IAC5C,MAAMC,WAAW,GAAG,IAAI,CAACC,wCAAwC,CAACH,YAAY,CAAC;IAE/E,IAAI,CAACT,GAAG,CAAC,4BAA4BS,YAAY,EAAE,CAAC;IACpD,IAAI,CAACT,GAAG,CAAC,kBAAkBW,WAAW,CAACE,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,WAAW,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAEtF;;;;;;;;;;;;;;;IAeAC,OAAO,CAACC,GAAG,CACTP,WAAW,CAACE,GAAG,CAAC,OAAOM,WAAW,EAAEC,KAAK,KAAI;MAC3C,IAAI;QACF,MAAM,IAAI,CAACC,0BAA0B,CAACD,KAAK,EAAED,WAAW,EAAEX,KAAK,CAAC;QAEhE,IAAI,IAAI,CAACc,eAAe,CAACb,YAAY,CAAC,KAAK,CAAC,EAAE;UAC5C,MAAMc,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIL,KAAK,GAAG,CAAC,CAAC,EAAET,WAAW,CAACxB,MAAM,GAAG,CAAC,CAAC;UAEjE,KAAK,IAAIuC,CAAC,GAAGN,KAAK,GAAG,CAAC,EAAEM,CAAC,GAAGH,OAAO,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;YAC5C,IAAI;cACF,MAAM,IAAI,CAACL,0BAA0B,CAACK,CAAC,EAAEP,WAAW,EAAEX,KAAK,CAAC;aAC7D,CAAC,OAAOmB,GAAQ,EAAE;cACjB,IAAI,CAAC3B,GAAG,CAAC4B,KAAK,CAACD,GAAG,CAAC;;;;OAI1B,CAAC,OAAOA,GAAQ,EAAE;QACjB,IAAI,CAAC3B,GAAG,CAAC4B,KAAK,CAACD,GAAG,CAAC;;IAEvB,CAAC,CAAC,CACH,CAACE,KAAK,CAACF,GAAG,IAAG;MACZ,IAAI,CAAC3B,GAAG,CAAC4B,KAAK,CAACD,GAAG,CAAC;IACrB,CAAC,CAAC,CAACG,IAAI,CAAC,MAAK;MACX,IAAI,CAACxB,gBAAgB,GAAGyB,UAAU,CAAC,IAAI,CAAC7B,YAAY,EAAE,IAAI,CAACL,eAAe,CAAC;MAE3E,IAAI,IAAI,CAACS,gBAAgB,CAAC0B,KAAK,IAAI,IAAI,EAAE;QACvC,IAAI,CAAC1B,gBAAgB,CAAC0B,KAAK,EAAE;;IAEjC,CAAC,CAAC,CAACH,KAAK,CAACF,GAAG,IAAG;MACb,IAAI,CAAC3B,GAAG,CAAC4B,KAAK,CAACD,GAAG,CAAC;IACrB,CAAC,CAAC;EACJ;EAEA,MAAMN,0BAA0BA,CAAEY,GAAW,EAAEd,WAAiB,EAAEX,KAAc;IAC9E,IAAI,CAACA,KAAK,IAAIW,WAAW,CAACe,OAAO,EAAE,GAAIC,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAACvC,eAAgB,EAAE;MACzE,IAAI,CAACG,GAAG,CAAC,8EAA8E,EAAEiC,GAAG,CAAC;MAC7F;;IAGF;IACA,MAAMI,MAAM,GAAG,MAAM,IAAI,CAACC,qBAAqB,CAACL,GAAG,CAAC;IAEpD,IAAI,CAACjC,GAAG,CAAC,oEAAoE,EAAEiC,GAAG,EAAEI,MAAM,EAAE,IAAI,CAACzC,YAAY,CAAC2C,IAAI,CAAC;IAEnH,MAAMC,UAAU,GAAG,IAAIpD,iBAAiB,CAAC,IAAI,CAACU,mBAAmB,CAAC;IAElE,IAAI;MACF,MAAM2C,KAAK,GAAG,MAAMtD,MAAM,CAAC,IAAI,CAACQ,WAAW,CAAC+C,eAAe,CAACL,MAAM,CAACM,OAAO,EAAE,EAAE;QAAEC,MAAM,EAAEJ,UAAU,CAACI;MAAM,CAAE,CAAC,CAAC;MAE7G,IAAI,CAAC5C,GAAG,CAAC,SAASyC,KAAK,6CAA6C,EAAEJ,MAAM,CAAC;MAC7E,IAAI,CAACrC,GAAG,CAAC,uEAAuE,EAAEiC,GAAG,EAAEI,MAAM,EAAE,IAAI,CAACzC,YAAY,CAAC2C,IAAI,CAAC;KACvH,SAAS;MACRC,UAAU,CAACK,KAAK,EAAE;;EAEtB;EAEAjC,wCAAwCA,CAAEkC,eAAuB;IAC/D,IAAIA,eAAe,GAAGvD,wBAAwB,EAAE;MAC9CuD,eAAe,GAAGvD,wBAAwB;;IAG5C,MAAMwD,KAAK,GAAG,EAAE;IAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIF,eAAe,EAAEE,CAAC,EAAE,EAAE;MACzC;MACAD,KAAK,CAACC,CAAC,CAAC,GAAG,IAAI,CAAC/C,6BAA6B,CAAC+C,CAAC,CAAC,IAAI,IAAIb,IAAI,EAAE;;IAGhE,OAAOY,KAAK;EACd;EAEA,MAAMT,qBAAqBA,CAAEW,wBAAgC;IAC3D,IAAI,IAAI,CAACrD,YAAY,CAACsD,EAAE,IAAI,IAAI,EAAE;MAChC,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;;IAG9C,MAAMC,UAAU,GAAGpE,WAAW,CAAC,CAAC,CAAC;IACjC,MAAMqE,YAAY,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC;IAEzD,MAAME,GAAG,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC3D,YAAY,CAACsD,EAAE,CAACM,WAAW,EAAEH,YAAY,EAAEJ,wBAAwB,CAAC;IAE5G,OAAOhE,eAAe,CAACqE,GAAG,CAAC;EAC7B;EAEA,MAAMC,WAAWA,CAAEE,UAAsB,EAAEC,YAAoB,EAAET,wBAAgC;IAC/F,IAAIA,wBAAwB,GAAG1D,wBAAwB,EAAE;MACvD,MAAM,IAAI4D,KAAK,CAAC,iEAAiE5D,wBAAwB,EAAE,CAAC;;IAG9G,MAAMoE,IAAI,GAAG,IAAIC,QAAQ,CAACH,UAAU,CAACI,MAAM,EAAEJ,UAAU,CAACK,UAAU,EAAEL,UAAU,CAACM,UAAU,CAAC;IAC1F,MAAMC,WAAW,GAAGL,IAAI,CAACM,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;IAE5C;IACA;IACA;IACA,MAAMC,kBAAkB,GAAGF,WAAW,GAAI,MAAM,IAAIf,wBAAyB;IAE7E;IACA;IACA,MAAMkB,IAAI,GAAG,KAAK,IAAK,EAAE,IAAIlB,wBAAwB,GAAG,CAAC,CAAE;IAC3D,MAAMmB,YAAY,GAAIF,kBAAkB,GAAGC,IAAI,GAAKT,YAAY,GAAG,CAACS,IAAK;IAEzE;IACA,MAAME,SAAS,GAAGvF,kBAAkB,CAACsF,YAAY,CAAC;IAElD,MAAME,SAAS,GAAG,IAAIC,WAAW,CAAC,EAAE,CAAC;IACrC,MAAMC,OAAO,GAAG,IAAIZ,QAAQ,CAACU,SAAS,EAAE,CAAC,EAAEA,SAAS,CAACP,UAAU,CAAC;IAChES,OAAO,CAACC,QAAQ,CAAC,CAAC,EAAE1F,MAAM,CAAC2F,IAAI,CAAC;IAChCF,OAAO,CAACC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;IACvBD,OAAO,CAACG,SAAS,CAAC,CAAC,EAAEN,SAAS,EAAE,KAAK,CAAC;IAEtC,OAAO,IAAIO,UAAU,CAACJ,OAAO,CAACX,MAAM,EAAEW,OAAO,CAACV,UAAU,EAAEU,OAAO,CAACT,UAAU,CAAC;EAC/E;EAEA;;;;EAIArD,gBAAgBA,CAAA;IACd;IACA;IACA,IAAID,YAAY,GAAG,CAAC;IAEpB,KAAK,MAAMtB,MAAM,IAAI,IAAI,CAAC0F,cAAc,EAAE,EAAE;MAC1C,IAAI1F,MAAM,GAAGsB,YAAY,EAAE;QACzBA,YAAY,GAAGtB,MAAM;;;IAIzB,OAAOsB,YAAY;EACrB;EAEA;;;EAGAa,eAAeA,CAAEb,YAAoB;IACnC,IAAIqE,KAAK,GAAG,CAAC;IAEb,KAAK,MAAM3F,MAAM,IAAI,IAAI,CAAC0F,cAAc,EAAE,EAAE;MAC1C,IAAI1F,MAAM,KAAKsB,YAAY,EAAE;QAC3BqE,KAAK,EAAE;;;IAIX,OAAOA,KAAK;EACd;EAEA;;;EAGA,CAAED,cAAcA,CAAA;IACd,IAAI,IAAI,CAACjF,YAAY,CAACsD,EAAE,IAAI,IAAI,EAAE;MAChC;;IAGF,KAAK,MAAM;MAAE6B;IAAE,CAAE,IAAI,IAAI,CAACnF,YAAY,CAACsD,EAAE,CAAC8B,UAAU,EAAE,EAAE;MACtD,MAAMC,QAAQ,GAAGpG,aAAa,CAAC,IAAI,CAACe,YAAY,CAACsD,EAAE,CAACM,WAAW,EAAEuB,EAAE,CAAC;MACpE,IAAIG,YAAY,GAAG,CAAC;MAEpB,KAAK,MAAMC,IAAI,IAAIF,QAAQ,EAAE;QAC3B,IAAIE,IAAI,KAAK,CAAC,EAAE;UACdD,YAAY,EAAE;SACf,MAAM;UACL;;;MAIJ,MAAMA,YAAY;;EAEtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}