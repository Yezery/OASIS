{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { isMultiaddr, multiaddr, resolvers } from '@multiformats/multiaddr';\nimport { TimeoutController } from 'timeout-abort-controller';\nimport { anySignal } from 'any-signal';\nimport { setMaxListeners } from 'events';\nimport { DialRequest } from './dial-request.js';\nimport { publicAddressesFirst } from '@libp2p/utils/address-sort';\nimport { trackedMap } from '@libp2p/tracked-map';\nimport { codes } from '../../errors.js';\nimport { DIAL_TIMEOUT, MAX_PARALLEL_DIALS, MAX_PER_PEER_DIALS, MAX_ADDRS_TO_DIAL } from '../../constants.js';\nimport { isPeerId } from '@libp2p/interface-peer-id';\nimport { getPeerAddress } from '../../get-peer.js';\nconst log = logger('libp2p:dialer');\nexport class DefaultDialer {\n  constructor(components, init = {}) {\n    this.started = false;\n    this.addressSorter = init.addressSorter ?? publicAddressesFirst;\n    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;\n    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;\n    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;\n    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);\n    this.components = components;\n    this.pendingDials = trackedMap({\n      name: 'libp2p_dialler_pending_dials',\n      metrics: components.metrics\n    });\n    this.pendingDialTargets = trackedMap({\n      name: 'libp2p_dialler_pending_dial_targets',\n      metrics: components.metrics\n    });\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value);\n    }\n  }\n  isStarted() {\n    return this.started;\n  }\n  async start() {\n    this.started = true;\n  }\n  /**\n   * Clears any pending dials\n   */\n  async stop() {\n    this.started = false;\n    for (const dial of this.pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    this.pendingDials.clear();\n    for (const pendingTarget of this.pendingDialTargets.values()) {\n      pendingTarget.abort();\n    }\n    this.pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   */\n  async dial(peerIdOrMultiaddr, options = {}) {\n    const {\n      peerId,\n      multiaddr\n    } = getPeerAddress(peerIdOrMultiaddr);\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw errCode(new Error('Tried to dial self'), codes.ERR_DIALED_SELF);\n      }\n      if (multiaddr != null) {\n        log('storing multiaddrs %p', peerId, multiaddr);\n        await this.components.peerStore.addressBook.add(peerId, [multiaddr]);\n      }\n      if (await this.components.connectionGater.denyDialPeer(peerId)) {\n        throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED);\n      }\n    }\n    log('creating dial target for %p', peerId);\n    // resolving multiaddrs can involve dns lookups so allow them to be aborted\n    const controller = new AbortController();\n    const controllerId = randomId();\n    this.pendingDialTargets.set(controllerId, controller);\n    let signal = controller.signal;\n    // merge with the passed signal, if any\n    if (options.signal != null) {\n      signal = anySignal([signal, options.signal]);\n    }\n    let dialTarget;\n    try {\n      dialTarget = await this._createDialTarget({\n        peerId,\n        multiaddr\n      }, {\n        ...options,\n        signal\n      });\n    } finally {\n      // done resolving the multiaddrs so remove the abort controller\n      this.pendingDialTargets.delete(controllerId);\n    }\n    if (dialTarget.addrs.length === 0) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n    // try to join an in-flight dial for this peer if one is available\n    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      log('dial failed to %s', dialTarget.id, err);\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   *\n   * If a multiaddr is received it should be the only address attempted.\n   *\n   * Multiaddrs not supported by the available transports will be filtered out.\n   */\n  async _createDialTarget(peerIdOrMultiaddr, options) {\n    let addrs = [];\n    if (isMultiaddr(peerIdOrMultiaddr.multiaddr)) {\n      addrs.push(peerIdOrMultiaddr.multiaddr);\n    }\n    // only load addresses if a peer id was passed, otherwise only dial the passed multiaddr\n    if (!isMultiaddr(peerIdOrMultiaddr.multiaddr) && isPeerId(peerIdOrMultiaddr.peerId)) {\n      addrs.push(...(await this._loadAddresses(peerIdOrMultiaddr.peerId)));\n    }\n    addrs = (await Promise.all(addrs.map(async ma => await this._resolve(ma, options)))).flat()\n    // Multiaddrs not supported by the available transports will be filtered out.\n    .filter(ma => Boolean(this.components.transportManager.transportForMultiaddr(ma)));\n    // deduplicate addresses\n    addrs = [...new Set(addrs.map(ma => ma.toString()))].map(ma => multiaddr(ma));\n    if (addrs.length > this.maxAddrsToDial) {\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n    }\n    const peerId = isPeerId(peerIdOrMultiaddr.peerId) ? peerIdOrMultiaddr.peerId : undefined;\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;\n      addrs = addrs.map(addr => {\n        const addressPeerId = addr.getPeerId();\n        if (addressPeerId == null || !peerId.equals(addressPeerId)) {\n          return addr.encapsulate(peerIdMultiaddr);\n        }\n        return addr;\n      });\n    }\n    return {\n      id: peerId == null ? randomId() : peerId.toString(),\n      addrs\n    };\n  }\n  /**\n   * Loads a list of addresses from the peer store for the passed peer id\n   */\n  async _loadAddresses(peer) {\n    const addresses = await this.components.peerStore.addressBook.get(peer);\n    return (await Promise.all(addresses.map(async address => {\n      const deny = await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr);\n      if (deny) {\n        return false;\n      }\n      return address;\n    }))).filter(isTruthy)\n    // Sort addresses so, for example, we try certified public address first\n    .sort(this.addressSorter).map(address => address.multiaddr);\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   */\n  _createPendingDial(dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = async (addr, options = {}) => {\n      if (options.signal?.aborted === true) {\n        throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      }\n      return await this.components.transportManager.dial(addr, options).catch(err => {\n        log.error('dial to %s failed', addr, err);\n        throw err;\n      });\n    };\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    });\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal != null && signals.push(options.signal);\n    const signal = anySignal(signals);\n    // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n    try {\n      // fails on node < 15.4\n      setMaxListeners?.(Infinity, signal);\n    } catch {}\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({\n        ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n        this.pendingDials.delete(dialTarget.id);\n      }\n    };\n    this.pendingDials.set(dialTarget.id, pendingDial);\n    return pendingDial;\n  }\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.includes(token)) {\n      return;\n    }\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively\n   */\n  async _resolve(ma, options) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr');\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma];\n    }\n    const resolvedMultiaddrs = await this._resolveRecord(ma, options);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async nm => {\n      return await this._resolve(nm, options);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (array.find(m => m.equals(newM)) == null) {\n        array.push(newM);\n      }\n      return array;\n    }, []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   */\n  async _resolveRecord(ma, options) {\n    try {\n      ma = multiaddr(ma.toString()); // Use current multiaddr module\n      const multiaddrs = await ma.resolve(options);\n      return multiaddrs;\n    } catch (err) {\n      log.error(`multiaddr ${ma.toString()} could not be resolved`, err);\n      return [];\n    }\n  }\n}\n/**\n * Type safe version of `list.filter(Boolean)`\n */\nfunction isTruthy(e) {\n  return Boolean(e);\n}\n/**\n * Returns a random string\n */\nfunction randomId() {\n  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;\n}","map":{"version":3,"names":["logger","errCode","isMultiaddr","multiaddr","resolvers","TimeoutController","anySignal","setMaxListeners","DialRequest","publicAddressesFirst","trackedMap","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","isPeerId","getPeerAddress","log","DefaultDialer","constructor","components","init","started","addressSorter","maxAddrsToDial","timeout","dialTimeout","maxDialsPerPeer","tokens","Array","maxParallelDials","map","_","index","pendingDials","name","metrics","pendingDialTargets","key","value","Object","entries","set","isStarted","start","stop","dial","values","controller","abort","err","error","clear","pendingTarget","peerIdOrMultiaddr","options","peerId","equals","Error","ERR_DIALED_SELF","peerStore","addressBook","add","connectionGater","denyDialPeer","ERR_PEER_DIAL_INTERCEPTED","AbortController","controllerId","randomId","signal","dialTarget","_createDialTarget","delete","addrs","length","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","connection","promise","aborted","code","ERR_TIMEOUT","destroy","push","_loadAddresses","Promise","all","ma","_resolve","flat","filter","Boolean","transportManager","transportForMultiaddr","Set","toString","ERR_TOO_MANY_ADDRESSES","undefined","peerIdMultiaddr","addr","addressPeerId","getPeerId","encapsulate","peer","addresses","address","deny","denyDialMultiaddr","isTruthy","sort","dialAction","ERR_ALREADY_ABORTED","catch","dialRequest","dialer","timeoutController","signals","Infinity","run","getTokens","num","total","Math","min","splice","releaseToken","token","includes","resolvableProto","protoNames","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","nm","reduce","array","newM","find","m","multiaddrs","resolve","e","parseInt","String","random","Date","now"],"sources":["../../../../src/connection-manager/dialer/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}